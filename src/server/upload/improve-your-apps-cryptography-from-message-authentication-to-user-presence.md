Trong một thế giới hoàn hảo, không ai cần mật mã. Mọi người đều giữ tay, mắt và tai cho chính mình; mọi bưu kiện được chuyển đến người nhận mà không bị giả mạo; và mọi người gửi đều đáng tin cậy. 
Nhưng chúng ta không sống trong một thế giới hoàn hảo. Trong nhiều thập kỷ qua, mật mã đã phát triển để đảm bảo không chỉ tính bí mật thông qua mã hóa mà còn đảm bảo tính toàn vẹn, xác thực và không thoái thác của message  - tất cả đều nhằm nỗ lực giữ cho tin nhắn riêng tư, xác thực và đáng tin cậy.

Có thể bạn sẽ cảm thấy hấp dẫn khi nghĩ rằng nếu hệ thống của bạn có triển khai mật mã vững chắc, thì bạn không cần sinh trắc học để xác minh sự hiện diện của người dùng. Để hiểu tại sao việc xác minh sự hiện diện của người dùng có thể quan trọng trong thế giới mật mã, chúng ta hãy lần lượt xem xét những thành công và thất bại của một số thuộc tính của mật mã. Từ đó, hãy xem tại sao bạn - một nhà cung cấp các dịch vụ giá trị cao như ngân hàng hoặc chăm sóc sức khỏe - có thể muốn triển khai xác thực sinh trắc học ngoài mật mã.
# Chỉ mã hóa không ngăn được một số loại tấn công nhất định

Bạn có thể coi mã hóa như một hàm, chẳng hạn như E, nhận vào một thông điệp m và một khóa k và từ các tham số đó, tạo ra một bản mã c. Bản mã thường được mọi người gọi là mã hóa, nhưng trên thực tế, mã hóa là thuật toán tạo ra thông điệp lộn xộn mà đối thủ không thể đọc được. Bản thân thông điệp xáo trộn được gọi là bản mã.

**c = E (m, k)**

Thực tế không thể xác định khóa bí mật k khi bạn chỉ biết một phần m hoặc c, miễn là giá trị của k đủ lớn.
Nhưng kẻ xấu không cần phải giải mã một ciphertext để giả mạo nó. Kẻ xấu có thể chỉnh sửa ciphertext, xóa ciphertext hoặc gửi lại message có chứa ciphertext (sử dụng process gọi replay).

Không phải tất cả các đối thủ đều muốn lấy cắp dữ liệu của bạn; họ có thể chỉ muốn làm phiền bạn. Hãy tưởng tượng một kẻ thù chỉ cần phát lại giao dịch mã hóa 2.000 đô la mà bạn đã trả cho cửa hàng máy tính để mua máy tính xách tay của mình. Giả sử đây là đối thủ bên thứ ba không có liên kết với cửa hàng máy tính, đối thủ này không đánh cắp được gì. Và bạn sẽ nhận lại được tiền của mình sau một số tranh chấp với cửa hàng máy tính. 
Tuy nhiên, bạn vẫn phải chịu một số thiệt hại về thời gian. Tệ hơn nữa, một kẻ thù tinh ý có thể thay thế tài khoản ngân hàng của cửa hàng máy tính bằng một số tài khoản ngân hàng khác - tất cả mà không cần giải mã bản mã.
Có nhiều cuộc tấn công nổi tiếng hơn chống lại các giải pháp chỉ mã hóa. Và ngay cả khi thuật toán mã hóa của bạn quản lý để ngăn chặn tất cả các cuộc tấn công đã biết, bạn vẫn không thể giữ một tin nhắn riêng tư mãi mãi. Ngay cả với những thiết kế mật mã thực tế tốt nhất, tốc độ của những tiến bộ công nghệ hiện tại chỉ cho phép các tin nhắn của bạn được giữ riêng tư trong khoảng 30 năm nữa, có thể là 50 năm nếu may mắn. Do đó, bản thân mã hóa không phải là điều tốt để chống lại những kẻ tấn công toàn vẹn messages . Bạn sẽ cần một số loại xác thực mà phần tiếp theo sẽ khám phá.
# Duy trì tính nguyên bản với message authentication
Thông tin sai lệch trong những trường hợp nhạy cảm có thể gây tổn hại to lớn. Đó là sự thật thiết yếu đã truyền cảm hứng cho các kỹ sư bảo mật tạo ra Message Authentication Code (hay còn gọi là MAC hoặc HMAC). Nếu ta gửi MAC cùng với tin nhắn, thì kẻ thù không thể sửa đổi tin nhắn và giả vờ rằng đó là tin nhắn gốc. Kẻ thù cũng không thể gửi lại message. Điều tốt nhất mà kẻ thù có thể làm là xóa tin nhắn để việc liên lạc hoàn toàn không thành công.
MAC là gì? MAC tương tự như ciphertext ở chỗ nó được tính bằng cách sử dụng thông điệp và khóa bí mật. Về cơ bản, người gửi chạy thông điệp m và một khóa bí mật k thông qua một hàm h, và một MAC được tạo ra. Sau đó người gửi sẽ gửi cả tin nhắn và MAC cho người nhận.

```
m, a = h (m, k)
```

MAC không phải là duy nhất cho mỗi tin nhắn do nguyên tắc pigeonhole , về cơ bản nếu bạn có nhiều chim bồ câu hơn số lỗ thì một số lỗ sẽ phải chứa nhiều chim bồ câu. MAC có kích thước được xác định trước, do đó có thể có nhiều thông điệp hơn MAC. Chỉ là không gian tìm kiếm quá lớn để kẻ thù có thể đoán được MAC nào sẽ đi với một thông điệp đã sửa đổi mà không cần biết khóa bí mật. Do đó, lý do MAC có hiệu quả chống lại việc sửa đổi thông điệp là vì khóa bí mật k chỉ người gửi và người nhận dự định biết. Nếu một đối thủ thay đổi thông điệp, đối thủ đó cũng sẽ phải thay đổi MAC để phù hợp và nếu không biết khóa bí mật, điều đó thực tế là không thể. Các cuộc tấn công phát lại không thành công vì chạy m, a = h (m, k) hai lần liên tiếp sẽ dẫn đến hai MAC khác nhau. Đó là bởi vì trong thực tế, thường có một tham số thứ ba tăng dần trong hàm: do đó chúng ta có thể viết lại phương trình dưới dạng m, a = h (m, k, t). Do đó, chức năng MAC giúp người nhận hợp lệ dễ dàng xác minh xem có xảy ra tấn công phát lại hay không.

Về cơ bản, MAC yêu cầu kẻ tấn công bẻ khóa bí mật. Khi có MAC, việc bắt chước thông điệp gốc không còn có thể thành công. Tính toàn vẹn được tích hợp sẵn. Cũng hữu ích như MAC, chúng có một số hạn chế khi nói đến tính bảo mật, phần sau sẽ giải thích.
# Signed but not sealed
Điều quan trọng cần lưu ý là MAC chỉ ký một tin nhắn nhưng không đóng dấu nó - vì vậy không có tính bảo mật. Kẻ thù vẫn có thể đọc tin nhắn; họ chỉ không thể thay đổi nó một cách hiệu quả. Nhưng không khó để ký và đóng dấu một tin nhắn. Thay vì tính m, a = h (m, kₐ), chỉ cần sử dụng phép thay thế đại số để thu được c, a = h (c, kₐ) trong đó c là bản mã thu được từ c = E (m, k𝒸).

Các thuật toán mật mã tốt giống như những ngôi nhà tốt. Chúng được cho là có thể chịu được bão không chỉ trong một ngày mà trong 30 năm hoặc lâu hơn. Đặc biệt hơn, đối với các nhà mật mã học, điều này có nghĩa là dự đoán những kẻ thù sẽ cố gắng bẻ khóa thuật toán của bạn không chỉ vào ngày mai hoặc tháng sau mà trong 10, 30 năm nữa - khi đó họ sẽ có lợi thế từ những công nghệ thậm chí còn chưa được phát minh. Do đó, MAC không thể phá vỡ mã hóa. Nó chỉ làm cho công việc của một đối thủ khó khăn hơn. Những kẻ tấn công trong 30 năm tới có thể sử dụng các kỹ thuật như  birthday attacks hoặc meet-in-the-middle attacks để đoán giá trị của MAC cho một tin nhắn đã chỉnh sửa, do đó khiến người nhận chấp nhận tin nhắn giả mạo.
# Asymmetric encryption scales more elegantly
Cho đến nay chúng ta đã thảo luận về cách các nhà mật mã ghép nối mã hóa với MAC để tạo ra các thông điệp được ký và niêm phong. Tôi cũng đã nói rằng điều tốt nhất mà kẻ tấn công có thể làm là xóa các tin nhắn như vậy; nếu không thì tin nhắn được gửi thành công, riêng tư và nguyên vẹn. Có vẻ như đây là tất cả những gì chúng ta cần. Nhưng còn nhiều hơn thế. Nhưng trước khi chúng ta thảo luận về “nhiều hơn”, hãy trò chuyện một chút về quy mô.

Hầu hết các kỹ thuật được thảo luận cho đến nay được gọi chung là mật mã đối xứng. Nói một cách đơn giản, chúng phụ thuộc vào cả người gửi và người nhận bằng cách sử dụng các khóa bí mật chính xác giống nhau để mã hóa và giải mã tin nhắn cũng như để tạo và xác minh các MAC. Vấn đề của cách tiếp cận này là, nếu một nhóm có 10 thành viên, thì mỗi thành viên cần chia sẻ và lưu trữ 9 khóa bí mật khác nhau để gửi tin nhắn được mã hóa giữa hai thành viên bất kỳ. Đó là tổng cộng 45 khóa. Đối với hai mươi người, đó là 190 chìa khóa; nói chung hơn, đối với n người thì đó là (n-1) n / 2 chìa khóa. Hãy tưởng tượng nếu, đối với mỗi người trong danh sách liên lạc của bạn, bạn phải có một số điện thoại cá nhân khác nhau cho mỗi người? Vì vậy, thay vì chỉ có một số điện thoại mà bạn cung cấp cho mỗi lần liên lạc, mỗi lần kết bạn mới, bạn sẽ cần phải mua thêm một số điện thoại! Đó là vấn đề với mã hóa đối xứng. Mở rộng quy mô là khó khăn. Rất may, có mật mã không đối xứng.

Mật mã không đối xứng sử dụng những hiểu biết sâu sắc từ lý thuyết số - cụ thể là lý thuyết trường hữu hạn và các hàm một chiều. Về cơ bản mỗi người tạo một khóa công khai và khóa riêng. Bất kỳ ai muốn liên lạc với bạn đều có thể sử dụng khóa công khai của bạn để gửi cho bạn các tin nhắn được mã hóa, nhưng chỉ khóa riêng của bạn mới có thể giải mã các tin nhắn đó.
Mục đích ở đây không phải là đi quá sâu vào lý thuyết số, mà là đưa mã hóa bất đối xứng vào cuộc trò chuyện. Bạn phải sử dụng mã hóa không đối xứng để hỗ trợ tính không từ chối, thuộc tính tiếp theo của mật mã mà chúng ta thảo luận bên dưới.

Sự cần thiết của nonrepudiation

Không từ chối chỉ đơn giản là một cách chuyên nghiệp để nói "không nhận lại." Cuộc cách mạng thương mại điện tử đã đưa quy tắc chơi công bằng rất đơn giản này trở thành trung tâm của thế giới tiền mã hóa.
Trong thế giới của các khóa mật mã đối xứng, người nhận được một tin nhắn (giả sử Bob) không thể chứng minh cho quan tòa rằng người gửi (giả sử Alice) là người thực sự gửi tin nhắn. Đó là vì cả Alice và Bob đều dùng chung một khóa bí mật. Có thể Alice đã gửi tin nhắn ban đầu nhưng Bob đã thay đổi nó, hoặc có thể Alice đang nói dối. Dù bằng cách nào, một thẩm phán không thể nói.

Tuy nhiên, với khóa không đối xứng, chỉ người nắm giữ khóa cá nhân mới có thể ký tin nhắn. Bất kỳ ai trên thế giới đều có thể đọc chữ ký vì sau cùng thì khóa công khai là khóa công khai. Do đó, nó sẽ diễn ra như thế này: khi Alice cần mua thứ gì đó từ Bob, cô ấy sẽ sử dụng khóa công khai của Bob để mã hóa giao dịch nhưng sử dụng khóa riêng của chính mình để thêm chữ ký vào giao dịch. Sau đó, khi Bob nhận được tin nhắn, anh ta sẽ sử dụng khóa công khai của Alice để xác minh rằng khóa riêng tư của Alice đã được sử dụng để ký giao dịch và sau đó sử dụng khóa riêng của anh ta để giải mã tin nhắn. Do đó, chữ ký được sử dụng để cung cấp sự không từ chối. MAC và Signature về cơ bản là giống nhau, ngoại trừ một cái dành cho mã hóa đối xứng và cái còn lại dành cho mã hóa bất đối xứng.
# Tóm tắt ngắn gọn
Bây giờ chúng ta hãy tóm tắt lại. Mật mã được sử dụng để mã hóa và xác thực tin nhắn, đồng thời cung cấp tính năng không từ chối. Khi các kỹ thuật phù hợp được áp dụng, các phần xác thực và mã hóa có thể khó bị phá vỡ - chúng phụ thuộc vào các bài toán rất khó như thừa số nguyên tố, logarit rời rạc và đường cong elliptic, sau đó được áp dụng cho các trường hữu hạn. Điều quan trọng là chỉ ra rằng mặc dù việc lấy khóa mã hóa bằng cách sử dụng các phân tích toán học có thể khó khăn, nhưng có nhiều cách khác để xâm nhập vào một hệ thống an toàn, chẳng hạn như  social engineering, nơi một cá nhân có thể bị lừa để tiết lộ thông tin bí mật. Ngoài ra, chúng tôi không bao gồm việc tạo khóa và chứng nhận trong cuộc thảo luận của mình vì quan điểm đã được đưa ra đầy đủ: Là một ngành kỹ thuật, Mật mã sẽ cần phải tiếp tục phát triển để đáp ứng nhu cầu của thời đại, nhằm nỗ lực đi trước đối thủ.
Tuy nhiên, không giống như mã hóa và xác thực, không từ chối phức tạp hơn một chút, đó là nơi xác minh sự hiện diện của người dùng có thể tạo thêm một lớp khó khăn cho đối thủ.
# Tầm quan trọng của sự hiện diện
Tại thời điểm này, chúng tôi đã chỉ ra rằng mật mã là tất cả về cấp độ bảo mật: nó tốn kém như thế nào (thời gian, tiền bạc, năng lượng) để kẻ thù giả mạo thư từ. Tuy nhiên, vẫn còn một vấn đề lớn: Chỉ vì một tin nhắn bắt nguồn từ một thiết bị mà tôi sở hữu và được ký bằng khóa riêng của tôi không có nghĩa là tôi đã gửi tin nhắn. Thay vào đó, vi-rút hoặc người dùng trái phép có thể đã gửi tin nhắn. Vì những lý do này và các lý do tương tự, mặc dù chữ ký điện tử đã được quốc tế hóa với tên gọi ESIGN, nhưng nhiều thương nhân toàn cầu vẫn không tin tưởng chúng vì khó có thể tranh luận về việc không từ chối nếu không có bằng chứng về sự hiện diện của người dùng và trách nhiệm chứng minh thuộc về người bán .

Để củng cố niềm tin của người bán vào việc không từ chối, ngành đã giới thiệu Xác thực hai yếu tố (2FA). Vì tội phạm mạng đã nhiều lần đột nhập vào các tài khoản trực tuyến chỉ được bảo vệ bằng tên người dùng và mật khẩu, 2FA đưa ra ý tưởng yêu cầu một điều nữa từ tác nhân tự nhận là người dùng hợp pháp. Một điều nữa thường thuộc một trong ba loại: thứ bạn biết, thứ bạn có hoặc thứ bạn đang có. Mục đích của 2FA là cung cấp cho người bán sự tin tưởng rằng người dùng thực sự có mặt trong một giao dịch. Hai trong số các hình thức phổ biến nhất của 2FA là mã chính và mã xác minh thường được gửi bằng SMS. Vấn đề với key fob và các token phần cứng tương tự là chúng có thể bị mất hoặc bị đánh cắp. Và một tin nhắn SMS cung cấp khả năng phòng thủ chuyên sâu cho 2FA nếu thiết bị bị xâm phạm là cùng một thiết bị nhận SMS hoặc thông báo đẩy. Do đó, các hình thức 2FA tiên tiến nhất ngày nay thuộc về bạn. Xác thực sinh trắc học là một ví dụ về 2FA tiên tiến như vậy.

Bằng cách bao gồm sinh trắc học - xác minh sự hiện diện của người dùng - trong triển khai bảo mật, ứng dụng của bạn thậm chí còn trở nên an toàn hơn và tính không từ chối trở thành một tính năng đáng tin cậy của mô hình kinh doanh của bạn. Đối với ứng dụng chăm sóc sức khỏe hoặc khách sạn, điều này có thể đồng nghĩa với việc người dùng đăng ký hoặc hủy đăng ký đáng tin cậy hơn. Đối với ứng dụng thương mại điện tử hoặc ngân hàng, điều này có thể có nghĩa là nhóm dịch vụ khách hàng của bạn dành ít thời gian hơn để hoàn tiền cho các giao dịch mua không chủ ý của trẻ mới biết đi và nhiều thời gian hơn để làm cho khách hàng của bạn hài lòng theo những cách thú vị hơn.

Lý do cơ bản khiến xác thực sinh trắc học trở thành một rào cản bổ sung thực sự chống lại các đối thủ của hệ thống bảo mật của bạn là vì trong khi sinh trắc học và mật mã hoàn toàn độc lập với nhau, cả hai đều rất khó để kẻ thù giả mạo. Ergo, sức mạnh tổng hợp của họ khiến công việc của một kẻ thù khó hơn nhiều.

Ví dụ: trên Android, xác minh sinh trắc học là một con đường một chiều. Thông tin sinh trắc học của người dùng không bao giờ rời khỏi thiết bị và không bao giờ được chia sẻ với các ứng dụng. Khi người dùng quyết định thêm sinh trắc học vào thiết bị Android của họ, họ phải thực hiện việc đó thông qua ứng dụng Cài đặt của hệ thống. Nếu họ đang sử dụng dấu vân tay (hoặc khuôn mặt) của mình, họ đặt ngón tay lên một cảm biến sẽ truyền trực tiếp hình ảnh dấu vân tay đến một khu vực hạn chế trên thiết bị Android, được gọi là Môi trường thực thi tin cậy (TEE). Sau đó, khi ứng dụng của bạn muốn xác minh sự hiện diện của người dùng thông qua xác thực sinh trắc học, Android Framework và hệ thống sinh trắc học trên Android, nằm trong TEE, sẽ xử lý toàn bộ quy trình xác minh sự hiện diện của người dùng cho ứng dụng của bạn. Và bởi vì Framework khiến việc giả mạo sinh trắc học của chủ sở hữu thiết bị trở nên cực kỳ khó khăn, bạn có thể có mức độ tin cậy cao về xác nhận sự hiện diện của người dùng.

Để tìm hiểu sâu hơn về cách hoạt động của sinh trắc học trên Android nhằm tăng cường các giải pháp bảo mật của bạn với tính năng không từ chối, hãy xem bài đăng trên blog của chúng tôi về cách sử dụng BiometricPrompt với CryptoObject.