# M·ªôt s·ªë ki·∫øn th·ª©c c·∫ßn n·∫Øm

M√¨nh khuy·∫øn kh√≠ch m·ªçi ng∆∞·ªùi tr∆∞·ªõc khi ƒë·ªçc b√†i n√†y th√¨ n√™n t√¨m hi·ªÉu **Quantum Computing** ho·∫∑c ƒë·ªçc b√†i  [gi·ªõi thi·ªáu c∆° b·∫£n v·ªÅ t√≠nh to√°n l∆∞·ª£ng t·ª≠](https://viblo.asia/p/gioi-thieu-co-ban-ve-tinh-toan-luong-tu-07LKXRdplV4) m√† m√¨nh ƒë√£ vi·∫øt ƒë·ªÉ c√≥ th·ªÉ hi·ªÉu r√µ h∆°n. Tuy nhi√™n, m√¨nh v·∫´n s·∫Ω t√≥m t·∫Øt l·∫°i c√°c √Ω ch√≠nh c·ªßa ph·∫ßn tr∆∞·ªõc ·ªü ƒë√¢y ƒë·ªìng th·ªùi c√≥ th√™m m·ªôt s·ªë ƒëo·∫°n code ƒë·ªÉ c√°c b·∫°n d·ªÖ h√¨nh dung h∆°n. ·ªû b√†i vi·∫øt n√†y m√¨nh s·∫Ω l∆∞·ª£c qua m·ªôt s·ªë ki·∫øn th·ª©c ti·∫øp theo v·ªÅ quantum circuit c≈©ng nh∆∞ m·ªôt s·ªë thao t√°c c∆° b·∫£n v·ªõi th∆∞ vi·ªán [Paddle Quantum](https://qml.baidu.com/) ƒë·ªÉ x√¢y d·ª±ng **Quantum Neural Network** v√¨ th∆∞ vi·ªán n√†y kh√° d·ªÖ d√πng v√† t∆∞·ªùng minh, nh·ªØng b√†i vi·∫øt sau m√¨nh s·∫Ω gi·ªõi thi·ªáu ƒë·∫øn c√°c b·∫°n m·ªôt th∆∞ vi·ªán kh√°c l√† **IBM Qiskit** v√† t·∫≠p trung khai th√°c v√†o th∆∞ vi·ªán n√†y v√¨ t√≠nh linh ho·∫°t v√† ·ª©ng d·ª•ng cao c·ªßa n√≥ khi c√≥ th·ªÉ k·∫øt h·ª£p v·ªõi **Pytorch** ƒë·ªÉ x√¢y d·ª±ng model v√† can thi·ªáp s√¢u v√†o qu√° tr√¨nh training c≈©ng nh∆∞  c√≥ th·ªÉ x√¢y d·ª±ng nhi·ªÅu h∆∞·ªõng nh∆∞ Quantum thu·∫ßn hay Quantum - Classical,... H∆°n n·ªØa c√≤n c√≥ th·ªÉ ch·∫°y code v·ªõi m√°y t√≠nh l∆∞·ª£ng t·ª≠ ƒë∆∞·ª£c h·ªó tr·ª£ b·ªüi IBM =)) C√≤n m·ªôt ƒëi·ªÅu n·ªØa kh√° quan tr·ªçng l√† nh·ªØng ph·∫ßn code ƒë∆∞·ª£c x√¢y d·ª±ng v·ªõi hai th∆∞ vi·ªán m√† m√¨nh gi·ªõi thi·ªáu v·ªõi c√°c b·∫°n ho√†n to√†n c√≥ th·ªÉ ch·∫°y ·ªü m√°y t√≠nh b√¨nh th∆∞·ªùng  v·ªõi m·ª•c ƒë√≠ch test thu·∫≠t to√°n v√† m√¥ ph·ªèng b·ªüi simulator c·ªßa IBM hay Baidu cung c·∫•p, trong t∆∞∆°ng lai n·∫øu c√≥ √Ω ƒë·ªãnh th√¨ ch√∫ng ta c≈©ng ho√†n to√†n c√≥ th·ªÉ d·ªÖ d√†ng request account ƒë·ªÉ c√≥ th·ªÉ ch·∫°y ·ªü m√°y t√≠nh l∆∞·ª£ng t·ª≠ th·∫≠t s·ª±. 

# ƒê·∫∑t v·∫•n ƒë·ªÅ
T√≠nh to√°n to√°n l∆∞·ª£ng t·ª≠ (Quantum Computing) s·ª≠ d·ª•ng c√°c hi·ªán t∆∞·ª£ng ƒë·ªôc ƒë√°o trong v·∫≠t l√Ω l∆∞·ª£ng t·ª≠ (ch·ªìng ch·∫•t l∆∞·ª£ng t·ª≠, giao thoa l∆∞·ª£ng t·ª≠ v√† r·ªëi l∆∞·ª£ng t·ª≠) ƒë·ªÉ thi·∫øt k·∫ø c√°c thu·∫≠t to√°n v√† gi√∫p gi·∫£i quy·∫øt c√°c nhi·ªám v·ª• c·ª• th·ªÉ trong v·∫≠t l√Ω, h√≥a h·ªçc v√† thuy·∫øt t·ªëi ∆∞u h√≥a. M·ªôt s·ªë m√¥ h√¨nh t√≠nh to√°n l∆∞·ª£ng t·ª≠ hi·ªán c√≥ bao g·ªìm T√≠nh to√°n l∆∞·ª£ng t·ª≠ ƒëo·∫°n nhi·ªát (AQC) d·ª±a tr√™n ƒë·ªãnh l√Ω ƒëo·∫°n nhi·ªát v√† T√≠nh to√°n l∆∞·ª£ng t·ª≠ d·ª±a tr√™n ph√©p measure (MBQC). Ph·∫ßn gi·ªõi thi·ªáu n√†y s·∫Ω t·∫≠p trung v√†o m√¥ h√¨nh vi m·∫°ch l∆∞·ª£ng t·ª≠ ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i nh·∫•t. Trong c√°c m·∫°ch l∆∞·ª£ng t·ª≠, ƒë∆°n v·ªã t√≠nh to√°n c∆° b·∫£n l√† bit l∆∞·ª£ng t·ª≠ (qubit), t∆∞∆°ng t·ª± nh∆∞ kh√°i ni·ªám bit trong m√°y t√≠nh c·ªï ƒëi·ªÉn. C√°c bit c·ªï ƒëi·ªÉn ch·ªâ c√≥ th·ªÉ ·ªü m·ªôt trong hai tr·∫°ng th√°i 0 ho·∫∑c 1. ƒê·ªÉ so s√°nh, c√°c qubit kh√¥ng ch·ªâ c√≥ th·ªÉ ·ªü nhi·ªÅu tr·∫°ng th√°i c∆° b·∫£n kh√°c nhau m√† c√≤n ·ªü tr·∫°ng th√°i ch·ªìng ch·∫•t. M√¥ h√¨nh m·∫°ch l∆∞·ª£ng t·ª≠ s·ª≠ d·ª•ng c√°c c·ªïng logic l∆∞·ª£ng t·ª≠ ƒë·ªÉ ƒëi·ªÅu khi·ªÉn tr·∫°ng th√°i c·ªßa c√°c qubit n√†y. 

# Qubit l√† g√¨?
## Bi·ªÉu di·ªÖn to√°n h·ªçc

Trong c∆° h·ªçc l∆∞·ª£ng t·ª≠, tr·∫°ng th√°i c·ªßa h·ªá l∆∞·ª£ng t·ª≠ hai c·∫•p (v√≠ d·ª•: spin c·ªßa ƒëi·ªán t·ª≠) c√≥ th·ªÉ ƒë∆∞·ª£c bi·ªÉu th·ªã d∆∞·ªõi d·∫°ng m·ªôt vect∆° tr·∫°ng th√°i thu ƒë∆∞·ª£c th√¥ng qua c√°c t·ªï h·ª£p tuy·∫øn t√≠nh c·ªßa c∆° s·ªü tr·ª±c chu·∫©n sau ƒë√¢y:
$$\ket{0} := \begin{bmatrix} 1 \\ 0 \end{bmatrix}, \quad \ket{1} := \begin{bmatrix} 0 \\ 1 \end{bmatrix}  \tag{1}$$

Bi·ªÉu di·ªÖn vect∆° ·ªü ƒë√¢y tu√¢n theo k√Ω hi·ªáu Dirac (bra-ket) trong v·∫≠t l√Ω l∆∞·ª£ng t·ª≠. C∆° s·ªü tr·ª±c chu·∫©n $\{\ket{0}, \ket{1}\}$ ch√≠nh l√† c∆° s·ªü t√≠nh to√°n. V·ªÅ m·∫∑t v·∫≠t l√Ω, ng∆∞·ªùi ta c√≥ th·ªÉ coi $\ket{0}$ v√† $\ket{1}$ l·∫ßn l∆∞·ª£t l√† tr·∫°ng th√°i nƒÉng l∆∞·ª£ng c∆° b·∫£n v√† tr·∫°ng th√°i k√≠ch th√≠ch c·ªßa m·ªôt nguy√™n t·ª≠. T·∫•t c·∫£ c√°c tr·∫°ng th√°i thu·∫ßn t√∫y c√≥ th·ªÉ c√≥ c·ªßa qubit c√≥ th·ªÉ ƒë∆∞·ª£c coi l√† vect∆° chu·∫©n h√≥a trong kh√¥ng gian Hilbert hai chi·ªÅu. H∆°n n·ªØa, c√°c tr·∫°ng th√°i nhi·ªÅu qubit c√≥ th·ªÉ ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·∫±ng c√°c vect∆° ƒë∆°n v·ªã trong kh√¥ng gian Hilbert nhi·ªÅu chi·ªÅu m√† c∆° s·ªü l√† t√≠ch tensor c·ªßa $\{\ket{0}, \ket{1}\}$ . V√≠ d·ª•, tr·∫°ng th√°i l∆∞·ª£ng t·ª≠ 2 qubit c√≥ th·ªÉ ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·∫±ng m·ªôt vect∆° ƒë∆°n v·ªã ph·ª©c trong kh√¥ng gian Hilbert 4 chi·ªÅu v·ªõi c∆° s·ªü tr·ª±c chu·∫©n:
$$\left\{
\ket{00} = \ket{0}\otimes \ket{0} := \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}, \quad 
\ket{01} = \ket{0}\otimes \ket{1} := \begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \end{bmatrix}, \quad
\ket{10} = \ket{1}\otimes \ket{0} := \begin{bmatrix} 0 \\ 0 \\ 1 \\ 0 \end{bmatrix}, \quad
\ket{11} = \ket{1}\otimes \ket{1} := \begin{bmatrix} 0 \\ 0 \\ 0 \\ 1 \end{bmatrix}
\right\} \qquad \quad (2)$$

Theo quy ∆∞·ªõc, v·ªã tr√≠ ngo√†i c√πng b√™n tr√°i trong k√Ω hi·ªáu ket ƒë·∫°i di·ªán cho qubit ƒë·∫ßu ti√™n $q_0$, v·ªã tr√≠ th·ª© hai ƒë·∫°i di·ªán cho qubit th·ª© hai $q_1$,... .Bi·ªÉu t∆∞·ª£ng $\otimes$ bi·ªÉu th·ªã ph√©p nh√¢n c·ªßa t√≠ch tensor, ph√©p nh√¢n ho·∫°t ƒë·ªông nh∆∞ sau: cho hai ma tr·∫≠n $A_{m\times n}$ v√† $B_{p\times q}$ khi ƒë√≥ t√≠ch tensor c·ªßa $A,B$ l√†:
$$A \otimes B =
\begin{bmatrix}
a_{11}B   & \cdots &  a_{1n}B\\
\vdots     & \ddots &  \vdots     \\
a_{m1}B & \cdots &  a_{m n}B
\end{bmatrix}_{(mp)\times (nq)}
\tag{3}$$

B·∫•t k·ª≥ tr·∫°ng th√°i l∆∞·ª£ng t·ª≠ qubit ƒë∆°n $\ket{\psi}$ n√†o c≈©ng c√≥ th·ªÉ ƒë∆∞·ª£c vi·∫øt d∆∞·ªõi d·∫°ng k·∫øt h·ª£p tuy·∫øn t√≠nh (ch·ªìng ch·∫•t) c·ªßa c√°c vect∆° c∆° s·ªü $\ket{0}$ v√† $\ket{1}$.
$$|\psi\rangle = \alpha |0\rangle + \beta |1\rangle:= \begin{bmatrix} \alpha \\ \beta \end{bmatrix}. \tag{4}$$

trong ƒë√≥ $\alpha$ v√† $\beta$ l√† c√°c s·ªë ph·ª©c ƒë∆∞·ª£c g·ªçi l√† bi√™n ƒë·ªô x√°c su·∫•t. Theo Quy t·∫Øc Sinh trong c∆° h·ªçc l∆∞·ª£ng t·ª≠, x√°c su·∫•t ƒë·ªÉ t√¨m th·∫•y qubit ·ªü tr·∫°ng th√°i $\ket{0}$ l√† $|\alpha|^2$; v√† x√°c su·∫•t c·ªßa $\ket{1}$ l√† $|\beta|^2$. V√¨ t·ªïng c√°c x√°c su·∫•t b·∫±ng 1, n√™n ng∆∞·ªùi ta ƒë∆∞a ra r√†ng bu·ªôc:$|\alpha|^2 + |\beta|^2 = 1$.

## Bi·ªÉu di·ªÖn bloch sphere
Qu·∫£ c·∫ßu Bloch l√† m·ªôt qu·∫£ c·∫ßu c√≥ b√°n k√≠nh ƒë∆°n v·ªã. N√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ bi·ªÉu di·ªÖn c√°c qubit m·ªôt c√°ch tr·ª±c quan. V·ªã tr√≠ c·ªßa m·ªói qubit ƒë∆∞·ª£c x√°c ƒë·ªãnh r√µ r√†ng th√¥ng qua c√°c tham s·ªë $\theta$ v√† $\varphi$.
$$|\psi\rangle = \alpha |0\rangle + \beta |1\rangle= \cos\bigg(\frac{\theta}{2}\bigg) |0\rangle + e^{i\varphi}\sin\bigg(\frac{\theta}{2}\bigg)|1\rangle \tag{5}$$

V·ªõi $0 ‚â§ œÜ <  2œÄ$ v√† $0 ‚â§ Œ∏ < \frac{\pi}{2}$, hay l√† ch·ªâ v·ªõi m·ªôt n·ª≠a qu·∫£ c·∫ßu ta ƒë√£ c√≥ th·ªÉ bi·ªÉu di·ªÖn v√¥ h·∫°n to√†n b·ªô c√°c qubit

![](https://images.viblo.asia/857eceed-9671-4952-a7d0-23fce5c6d629.png)

**Bi·ªÉu di·ªÖn bloch sphere v·ªõi paddle quantum**

L√Ω thuy·∫øt nh∆∞ v·∫≠y l√† ƒë·ªß r·ªìi, b√¢y gi·ªù ch√∫ng ta s·∫Ω b·∫Øt ƒë·∫ßu l√†m quen v·ªõi th∆∞ vi·ªán paddle-quantum nh√©. ƒê·∫ßu ti√™n ƒë·ªÉ c√†i th∆∞ vi·ªán ch√∫ng ta ch·ªâ c·∫©n ch·∫°y d√≤ng l·ªánh:`pip install paddle-quantum` tr√™n terminal.

Ch√∫ng ta s·∫Ω d√πng th·ª≠ th∆∞ vi·ªán n√†y ƒë·ªÉ bi·ªÉu di·ªÖn c√°c tr·∫°ng th√°i l∆∞·ª£ng t·ª≠ c·ªßa qubit tr√™n bloch sphere :

```
from paddle_quantum.circuit import UAnsatz
from paddle_quantum.utils import plot_state_in_bloch_sphere, plot_rotation_in_bloch_sphere
import numpy as np
import paddle

# Set random seed
np.random.seed(42)
# Number of samples
num_samples = 15
# Store the sampled quantum states
state = []

for i in range(num_samples):
    
    # Create a single qubit circuit
    cir = UAnsatz(1)
    # Generate random rotation angles
    phi, theta, omega = 2 * np.pi * np.random.uniform(size=3)
    phi = paddle.to_tensor(phi, dtype='float64')
    theta = paddle.to_tensor(theta, dtype='float64')
    omega = paddle.to_tensor(omega, dtype='float64')
    
    # Quantum gate operation
    cir.rz(phi, 0)
    cir.ry(theta, 0)
    cir.rz(omega, 0)
    
    # Store the sampled quantum states
    state.append(cir.run_state_vector())

# Call the Bloch sphere display function, enter the state parameter, and display the vector.
plot_state_in_bloch_sphere(state, show_arrow=True, save_gif=True)
```

![](https://images.viblo.asia/b7fdec3e-00ee-4e8b-8913-5a22a1dadea2.gif)

Nh∆∞ trong h√¨nh tr√™n, m√¨nh ƒë√£ l·∫•y m·∫´u ng·∫´u nhi√™n 15 l·∫ßn ƒë·ªÉ t·∫°o ra 15 tr·∫°ng th√°i l∆∞·ª£ng t·ª≠ qubit ƒë∆°n kh√°c nhau v√† hi·ªÉn th·ªã l·∫ßn l∆∞·ª£t 15 tr·∫°ng th√°i l∆∞·ª£ng t·ª≠ n√†y tr√™n qu·∫£ c·∫ßu Bloch.

L√†m th·∫ø n√†o ƒë·ªÉ m√¥ t·∫£ "qu·ªπ ƒë·∫°o" chuy·ªÉn ƒë·ªông quay c·ªßa m·ªôt tr·∫°ng th√°i l∆∞·ª£ng t·ª≠ qubit ƒë∆°n tr√™n qu·∫£ c·∫ßu Bloch? 
L·∫•y v√≠ d·ª• to√°n t·ª≠ ƒë∆°n nh·∫•t c·ªßa m·ªôt qubit  l√† ph√©p quay m·ªôt vect∆° tr√™n h√¨nh c·∫ßu Bloch. Tr·∫°ng th√°i ban ƒë·∫ßu c·ªßa m·∫°ch l∆∞·ª£ng t·ª≠ t∆∞∆°ng ·ª©ng v·ªõi v·ªã tr√≠ ban ƒë·∫ßu c·ªßa vect∆° ƒë·∫ßu tr√™n qu·∫£ c·∫ßu Bloch, v√† tr·∫°ng th√°i cu·ªëi c√πng c·ªßa m·∫°ch l∆∞·ª£ng t·ª≠ t∆∞∆°ng ·ª©ng v·ªõi v·ªã tr√≠ cu·ªëi c√πng c·ªßa vect∆° sau khi quay tr√™n qu·∫£ c·∫ßu Bloch. Ta x√©t tr·∫°ng th√°i l∆∞·ª£ng t·ª≠ c·ªßa $\ket{0}$ qua c·ªïng quay $R_y(\frac{\pi}{4})$ v√† $R_z(\frac{\pi}{2})$ l√† tr·∫°ng th√°i ban ƒë·∫ßu, v√† tr·∫°ng th√°i sau khi qua c·ªïng $U3(\theta = \frac{\pi}{2}, \phi = \frac{7\pi}{8}, \lambda = 2\pi)$ l√† cu·ªëi c√πng. Code m√¥ t·∫£ chuy·ªÉn ƒë·ªông c·ªßa vector: 
```
# Set the initial state of the quantum state
cir.ry(paddle.to_tensor(np.pi/4, dtype="float64"), 0)
cir.rz(paddle.to_tensor(np.pi/2, dtype="float64"), 0)
init_state = cir.run_density_matrix()

# Unitary operator operation to be performed
theta = np.pi/2
phi = 7*np.pi/8
lam = 2*np.pi
rotating_angle = [theta, phi, lam]

# Call Bloch sphere display functionÔºåinput init_stateÔºårotating_angle
plot_rotation_in_bloch_sphere(init_state, rotating_angle)
```

![](https://images.viblo.asia/80059f39-4a91-49a7-892f-2c1585dd94f0.gif)


# C·ªïng Logic Quantum 

Trong m√°y t√≠nh c·ªï ƒëi·ªÉn, ch√∫ng ta c√≥ th·ªÉ √°p d·ª•ng c√°c ph√©p to√°n logic c∆° b·∫£n (c·ªïng NOT, c·ªïng NAND, c·ªïng XOR, c·ªïng AND v√† c·ªïng OR) tr√™n c√°c bit c·ªï ƒëi·ªÉn v√† k·∫øt h·ª£p ch√∫ng th√†nh c√°c ph√©p to√°n ph·ª©c t·∫°p h∆°n. M√°y t√≠nh l∆∞·ª£ng t·ª≠ c√≥ m·ªôt t·∫≠p h·ª£p c√°c ph√©p to√°n logic ho√†n to√†n kh√°c, ch√∫ng ƒë∆∞·ª£c g·ªçi l√† c√°c c·ªïng l∆∞·ª£ng t·ª≠ v√† ch√∫ng ta kh√¥ng th·ªÉ bi√™n d·ªãch c√°c ch∆∞∆°ng tr√¨nh C ++ hi·ªán c√≥ tr√™n m√°y t√≠nh l∆∞·ª£ng t·ª≠. B·ªüi v√¨ m√°y t√≠nh c·ªï ƒëi·ªÉn v√† m√°y t√≠nh l∆∞·ª£ng t·ª≠ c√≥ c·∫•u tr√∫c c·ªïng logic kh√°c nhau, c√°c thu·∫≠t to√°n l∆∞·ª£ng t·ª≠ c·∫ßn ƒë∆∞·ª£c x√¢y d·ª±ng b·∫±ng c√°ch s·ª≠ d·ª•ng c·ªïng l∆∞·ª£ng t·ª≠. V·ªÅ m·∫∑t to√°n h·ªçc, m·ªôt c·ªïng l∆∞·ª£ng t·ª≠ c√≥ th·ªÉ ƒë∆∞·ª£c bi·ªÉu di·ªÖn nh∆∞ m·ªôt ma tr·∫≠n ƒë∆°n nguy√™n. C√°c ph√©p to√°n ƒë∆°n nguy√™n c√≥ th·ªÉ b·∫£o to√†n ƒë·ªô d√†i vect∆° - ƒë√¢y l√† thu·ªôc t√≠nh m√† ch√∫ng ta mong mu·ªën. Ma tr·∫≠n ƒë∆°n nguy√™n ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a nh∆∞ sau:
$$U^{\dagger}U = UU^{\dagger} = I, \quad \text{v√†} \quad \Vert |\psi\rangle \Vert = \Vert U|\psi\rangle\Vert = 1. \tag{6}$$
Trong ƒë√≥ $U^{\dagger}$ l√† chuy·ªÉn v·ªã li√™n h·ª£p c·ªßa $U$ v√† l√† ƒë·∫°i di·ªán cho ma tr·∫≠n ƒë∆°n v·ªã. 

**V·∫≠y √Ω nghƒ©a v·∫≠t l√Ω c·ªßa vi·ªác bi·ªÉu di·ªÖn c√°c c·ªïng l∆∞·ª£ng t·ª≠ d∆∞·ªõi d·∫°ng ma tr·∫≠n ƒë∆°n nguy√™n l√† g√¨?** ƒêi·ªÅu n√†y ng·ª• √Ω r·∫±ng t·∫•t c·∫£ c√°c c·ªïng l∆∞·ª£ng t·ª≠ ƒë·ªÅu c√≥ th·ªÉ ƒë·∫£o ng∆∞·ª£c. ƒê·ªëi v·ªõi b·∫•t k·ª≥ c·ªïng logic $U$ n√†o, ng∆∞·ªùi ta lu√¥n c√≥ th·ªÉ t√¨m th·∫•y c·ªïng ƒë·∫£o $U^{\dagger}$ t∆∞∆°ng ·ª©ng. Ngo√†i ra, ma tr·∫≠n ƒë∆°n nguy√™n ph·∫£i l√† ma tr·∫≠n vu√¥ng, v√¨ ƒë·∫ßu v√†o v√† ƒë·∫ßu ra c·ªßa ph√©p to√°n l∆∞·ª£ng t·ª≠ y√™u c·∫ßu c√πng m·ªôt l∆∞·ª£ng qubit. C·ªïng l∆∞·ª£ng t·ª≠ t√°c ƒë·ªông l√™n $n$ qubit c√≥ th·ªÉ ƒë∆∞·ª£c vi·∫øt d∆∞·ªõi d·∫°ng $2^n \times 2^n$ ma tr·∫≠n ƒë∆°n nguy√™n. C√°c c·ªïng l∆∞·ª£ng t·ª≠ ph·ªï bi·∫øn nh·∫•t ho·∫°t ƒë·ªông tr√™n m·ªôt ho·∫∑c hai qubit, gi·ªëng nh∆∞ c√°c c·ªïng logic c·ªï ƒëi·ªÉn.

## C·ªïng ƒë∆°n qubit 
Ti·∫øp theo ƒë√¢y m√¨nh s·∫Ω gi·ªõi thi·ªáu ƒë·∫øn c√°c b·∫°n b·ªô 3 ma tr·∫≠n Pauli $\{X, Y, Z\}$ t∆∞∆°ng ·ª©ng v·ªõi 3 c·ªïng quay $\{R_x, R_y, R_z\}$ v√† sau ƒë√≥ s·∫Ω l√† c·ªïng Hadamard $H$. ƒê·∫ßu ti√™n ch√∫ng ta n√≥i qua v·ªÅ c·ªïng **NOT** - m·ªôt c·ªïng kh√° c∆° b·∫£n v√† quan tr·ªçng ·ªü c·∫£ t√≠nh to√°n c·ªï ƒëi·ªÉn v√† l∆∞·ª£ng t·ª≠,
$$X := \begin{bmatrix} 0 &1 \\ 1 &0 \end{bmatrix}. \tag{7}$$
C·ªïng Pauli $X$ c√≤n ƒë∆∞·ª£c g·ªçi l√† c·ªïng NOT. C·ªïng n√†y c√≥ √Ω nghƒ©a l√† t·∫°o ra trang th√°i "ng∆∞·ª£c" v·ªõi tr·∫°ng th√°i $\ket{0}$ ho·∫∑c $\ket{1}$ ƒë·∫ßu v√†o, t∆∞∆°ng ƒë∆∞∆°ng v·ªõi vi·ªác quay tr·∫°ng th√°i qubit tr√™n m·∫∑t c·∫ßu Bloch sang ƒëi·ªÉm ƒë·ªëi di·ªán v·ªõi n√≥ tr√™n m·∫∑t c·∫ßu v√† c√°c thao t√°c t√≠nh to√°n v·ªõi c·ªïng n√†y ƒë∆°n gi·∫£n ch·ªâ l√† nh√¢n ma tr·∫≠n v·ªõi vector c·ªôt : 
$$X |0\rangle := \begin{bmatrix} 0 &1 \\ 1 &0 \end{bmatrix} \begin{bmatrix} 1 \\0 \end{bmatrix}
=\begin{bmatrix} 0 \\1 \end{bmatrix} = |1\rangle, \quad \text{v√†} \quad X |1\rangle := \begin{bmatrix} 0 &1 \\ 1 &0 \end{bmatrix} \begin{bmatrix} 0 \\1 \end{bmatrix} =\begin{bmatrix} 1 \\0 \end{bmatrix}=|0\rangle. $$
X√©t tr√™n qu·∫£ c·∫ßu bloch, khi ma tr·∫≠n $X$ n√†y t√≠nh to√°n v·ªõi tr·∫°ng th√°i c·ªßa 1 qubit th√¨ t∆∞∆°ng ·ª©ng v·ªõi m·ªôt ph√©p quay ·ªü tr·ª•c $x$ c·ªßa qu·∫£ c·∫ßu v·ªõi g√≥c $\pi$. ƒêi·ªÅu n√†y l√Ω gi·∫£i t·∫°i sao ma tr·∫≠n $X$ ƒë∆∞·ª£c bi·ªÉu di·ªÖn d∆∞·ªõi d·∫°ng $R_x(\pi)$ ( ƒë∆∞·ª£c ph√¢n bi·ªát v·ªõi pha to√†n c·ª•c $e^{-i\pi/2} = -i$). Hai ma tr·∫≠n Pauli kh√°c l√† $Y \text{ v√† } Z$ c≈©ng c√≥ th·ªÉ ƒë∆∞·ª£c gi·∫£i th√≠ch theo c√°ch t∆∞∆°ng t·ª± (ƒë·∫°i bi·ªÉu cho ph√©p quay quanh tr·ª•c $y \text{ v√† } z$ v·ªõi g√≥c $\pi$:
$$Y := \begin{bmatrix} 0 &-i \\ i &0 \end{bmatrix}, \quad \text{ v√†} \quad  Z := \begin{bmatrix} 1 &0 \\ 0 &-1 \end{bmatrix}. \tag{9}$$

N√≥i chung, b·∫•t k·ª≥ c·ªïng l∆∞·ª£ng t·ª≠ n√†o quay m·ªôt g√≥c $\theta$ quanh tr·ª•c t∆∞∆°ng ·ª©ng tr√™n h√¨nh c·∫ßu Bloch c√≥ th·ªÉ ƒë∆∞·ª£c bi·ªÉu th·ªã nh∆∞ sau : 
$$R_x(\theta) := 
\begin{bmatrix} 
\cos \frac{\theta}{2} &-i\sin \frac{\theta}{2} \\ 
-i\sin \frac{\theta}{2} &\cos \frac{\theta}{2} 
\end{bmatrix}
,\quad 
R_y(\theta) := 
\begin{bmatrix}
\cos \frac{\theta}{2} &-\sin \frac{\theta}{2} \\ 
\sin \frac{\theta}{2} &\cos \frac{\theta}{2} 
\end{bmatrix}
,\quad 
R_z(\theta) := 
\begin{bmatrix}
e^{-i\frac{\theta}{2}} & 0 \\ 
0 & e^{i\frac{\theta}{2}}
\end{bmatrix}.
\tag{10}$$

M√¨nh s·∫Ω v√≠ d·ª• t·∫°o c·ªïng $R_x$ v·ªõi paddle, c√°c c·ªïng $R_y,R_z$ ho√†n to√†n t∆∞∆°ng t·ª±:
```
# Set the angle parameter theta = pi
theta = np.pi

# Set the number of qubits required for calculation
num_qubits = 1

# Initialize the single-bit quantum circuit
cir = Circuit(num_qubits)

# Apply an Rx rotation gate to the first qubit (q0), the angle is pi
cir.rx(0, param=theta)

# Convert to numpy.ndarray
# Print out this quantum gate
print('The matrix representation of quantum gate is:')
print(cir.unitary_matrix().numpy())

```

Output:
```

The matrix representation of quantum gate is:
[[-4.371139e-08+0.j  0.000000e+00-1.j]
 [ 0.000000e+00-1.j -4.371139e-08+0.j]]
```

Ngo√†i c√°c c·ªïng xoay n√≥i tr√™n, c·ªïng ƒë∆°n qubit cu·ªëi c√πng v√† c≈©ng l√† quan tr·ªçng nh·∫•t m√† m√¨nh mu·ªën n√≥i ƒë·∫øn l√† c·ªïng Hadamard. X√©t tr√™n qu·∫£ c·∫ßu Bloch th√¨ c·ªïng n√†y bao g·ªìm hai ph√©p quay ri√™ng bi·ªát, ƒë·∫ßu ti√™n quay m·ªôt g√≥c $\pi$ quanh tr·ª•c $z$  v√† sau ƒë√≥ quay g√≥c $\pi/2$ quanh tr·ª•c $y$. C·ªïng n√†y c√≥ √Ω nghƒ©a l√† t·∫°o ra trang th√°i "tr·ªôn" ƒë·ªÅu t·ª´ tr·∫°ng th√°i  $\ket{0}$ ho·∫∑c $\ket{1}$ ƒë·∫ßu v√†o. Bi·ªÉu di·ªÖn ma tr·∫≠n c·ªßa n√≥ nh∆∞ sau : 
$$H := \frac{1}{\sqrt{2}}\begin{bmatrix} 1 &1 \\ 1 &-1 \end{bmatrix}.
\tag{11}$$

![image.png](https://images.viblo.asia/e0ca690a-c72e-4921-bd27-daa4722f4107.png)
M·ªôt m·∫°ch l∆∞·ª£ng t·ª≠ t·∫°o b·ªüi c√°c c·ªïng Hadamard nh∆∞ h√¨nh tr√™n ƒë∆∞·ª£c g·ªçi l√† m·∫°ch kh·ªüi t·∫°o thanh ghi l∆∞·ª£ng t·ª≠. ƒê·∫ßu ra c·ªßa m·∫°ch n√†y l√†: 

$$\ \ket{\psi} =\frac{1}{\sqrt{2}}(\ket{0}+\ket{1})\frac{1}{\sqrt{2}}(\ket{0}+\ket{1})...\frac{1}{\sqrt{2}}(\ket{0}+\ket{1}) \\ 
=\frac{1}{2^{N/2}}(\ket{00...0}+\ket{00...1}+...+\ket{11...1})$$

·ªû ƒë√¢y, $N$ l√† s·ªë qubit ƒë·∫ßu v√†o. Nh∆∞ v·∫≠y ƒë·∫ßu ra c·ªßa m·∫°ch kh·ªüi t·∫°o thanh ghi l∆∞·ª£ng t·ª≠, v·ªõi ƒë·∫ßu v√†o $N$ qubit ·ªü tr·∫°ng th√°i $\ket{0}$, l√† tr·∫°ng th√°i "tr·ªôn" ƒë·ªÅu c·ªßa t·∫•t c·∫£ c√°c v√©c t∆° trong h·ªá c∆° s·ªü c·ªßa kh√¥ng gian $2^N$ chi·ªÅu ch·ª©a c√°c tr·∫°ng th√°i c·ªßa $N$ qubit.



## C·ªïng ƒëa qubit
Nh∆∞ ƒë√£ n√≥i ·ªü b√†i [tr∆∞·ªõc](https://viblo.asia/p/gioi-thieu-co-ban-ve-tinh-toan-luong-tu-07LKXRdplV4) th√¨ multiple qubit ch√≠nh l√† s·ª± k·∫øt h·ª£p c·ªßa nhi·ªÅu qubit ƒë∆°n l·∫ª t·∫°o th√†nh m·ªôt h·ªá ƒëa qubit v√† m·ªôt h·ªá ƒëa qubit nh∆∞ v·∫≠y c·∫ßn c√°c c·ªïng ƒëa qubit ƒë·ªÉ c√≥ th·ªÉ t∆∞∆°ng t√°c v·ªõi nhau. Ch√∫ng ta s·∫Ω b·∫Øt ƒë·∫ßu ph·∫ßn n√†y v·ªõi vi·ªác t√¨m hi·ªÉu m·ªôt c·ªïng logic kh√° c∆° b·∫£n ƒë√≥ l√† **CNOT**.

![Untitled Diagram.drawio(1).png](https://images.viblo.asia/6dc8bf5a-6efa-4a89-b21f-445be0da4137.png)

<br>$\text{CNOT} |00\rangle = |00\rangle, \quad 
\text{CNOT} |01\rangle = |01\rangle,  \quad 
\text{CNOT} |10\rangle = |11\rangle, \quad
\text{CNOT} |11\rangle = |10\rangle.$ <br>


C√°ch ho·∫°t ƒë·ªông c·ªßa c·ªïng CNOT kh√° d·ªÖ h√¨nh dung, ƒë·∫ßu v√†o c·ªßa c·ªïng CNOT g·ªìm 2 Qubit: qubit th·ª© nh·∫•t l√† qubit ƒêi·ªÅu khi·ªÉn (control), qubit th·ª© hai l√† qubit m·ª•c ti√™u (target). Qubit ƒêi·ªÅu khi·ªÉn s·∫Ω kh√¥ng b·ªã thay ƒë·ªïi sau khi qua c·ªïng CNOT, qubit M·ª•c ti√™u s·∫Ω b·ªã ƒë·∫£o ng∆∞·ª£c khi v√† ch·ªâ khi Qubit ƒêi·ªÅu khi·ªÉn l√† 1, gi√° tr·ªã c·ªßa Qubit M·ª•c ti√™u ch√≠nh l√† k·∫øt qu·∫£ c·ªßa ph√©p XOR gi·ªØa hai Qubit ƒë·∫ßu v√†o. Nh∆∞ng v·∫´n c√≥ m·ªôt ƒëi·ªÅu m√† ch√∫ng ta c·∫ßn l∆∞u t√¢m, n·∫øu qubit ƒëi·ªÅu khi·ªÉn l√† $\ket{0}$ ho·∫∑c $\ket{1}$ th√¨ nh·ªØng ƒëi·ªÅu m√¨nh n√≥i ·ªü tr√™n l√† ƒë√∫ng. V·∫≠y n·∫øu n√≥ n·∫±m ngo√†i 2 tr∆∞·ªùng h·ª£p tr√™n th√¨ sao ? C√πng xem qua 3 v√≠ d·ª• n√†y nh√©!

* V√≠ d·ª• 1: X√©t qubit $|\psi\rangle=a|0\rangle+b|1\rangle=\left[\begin{array}{}a \\ b\end{array}\right]$ l√† qubit m·ª•c ti√™u v√† $\ket{1}$ l√† qubit ƒëi·ªÅu khi·ªÉn.  Ta s·∫Ω d√πng ma tr·∫≠n ƒë·ªÉ t√≠nh k·∫øt qu·∫£ c·ªßa CNOT $\ket{1, \psi}$
  <br> $\text{Ta c√≥: }|1, \psi\rangle=a|10\rangle+b|11\rangle=\left[\begin{array}{l}0 \\ 0 \\ a \\ b\end{array}\right]$<br>

$~~~~~~~~~$ $\mathrm{CNOT}$ $|1, \psi\rangle=\left[\begin{array}{llll}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{array}\right]\left[\begin{array}{l}0 \\ 0 \\ a \\ b\end{array}\right]=\left[\begin{array}{l}0 \\ 0 \\ b \\ a\end{array}\right]=|1, \phi\rangle$. V·ªõi $|\phi\rangle=b|0\rangle+a|1\rangle$. 
  
  $~~~~~~~~~~$ V·∫≠y $\ket{1, \psi}$ sau khi ƒëi qua CNOT s·∫Ω th√†nh $\ket{1, \phi}$
  
![Untitled Diagram.drawio(2).png](https://images.viblo.asia/db404235-c294-4267-8550-aeae41aeaf95.png)
* V√≠ d·ª• 2 : X√©t qubit $\ket{1}$ l√† qubit m·ª•c ti√™u v√†  $\psi = \frac{1}{\sqrt{2}}\ket{0}+\frac{1}{\sqrt{2}}\ket{1}$ l√† qubit ƒëi·ªÅu khi·ªÉn. 
<br>$\text{Ta c√≥: }|\psi, 1\rangle=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\otimes|1\rangle=\frac{1}{\sqrt{2}}(|01\rangle+|11\rangle)=\left[\begin{array}{c}0 \\ \frac{1}{\sqrt{2}} \\ 0 \\ \frac{1}{\sqrt{2}}\end{array}\right] .$<br>

$~~~~~~~~~\mathrm{CNOT}|\psi, 1\rangle=\left[\begin{array}{cccc}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{array}\right]\left[\begin{array}{c}0 \\ \frac{1}{\sqrt{2}} \\ 0 \\ \frac{1}{\sqrt{2}}\end{array}\right]=\left[\begin{array}{c}0 \\ \frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} \\ 0\end{array}\right]=|\phi\rangle$
<br>$~~~~~~~~~~\ket{\phi}=\frac{1}{\sqrt{2}}(\ket{01}+\ket{10})$. Nh∆∞ v·∫≠y h·ªá $\ket{\psi}$ ƒë√£ b·ªã r·ªëi l∆∞·ª£ng t·ª≠ sau khi ƒëi qua c·ªïng CNOT<br>

![Untitled Diagram.drawio(3).png](https://images.viblo.asia/fcc198ec-afcf-419b-993f-8ec28f4e31f0.png)

* V√≠ d·ª• 3 : X√©t h·ªá r·ªëi l∆∞·ª£ng t·ª≠ $|\phi\rangle=\frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)=\left[\begin{array}{c}\frac{1}{\sqrt{2}} \\ 0 \\ 0 \\ \frac{1}{\sqrt{2}}\end{array}\right]$. Cho h·ªá ƒëi qua c·ªïng CNOT: 
<br>$\mathrm{CNOT}|\phi\rangle=\left[\begin{array}{cccc}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{array}\right]\left[\begin{array}{c}\frac{1}{\sqrt{2}} \\ 0 \\ 0 \\ \frac{1}{\sqrt{2}}\end{array}\right]=\left[\begin{array}{c}\frac{1}{\sqrt{2}} \\ 0 \\ \frac{1}{\sqrt{2}} \\ 0\end{array}\right]=|\psi\rangle$.<br>

$~~~~~~~~~~|\psi\rangle=\frac{1}{\sqrt{2}}(|00\rangle+|10\rangle)=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)|0\rangle$. Nh∆∞ v·∫≠y h·ªá $\phi$ ƒë√£ ƒë∆∞·ª£c g·ª° r·ªëi.

Ba v√≠ d·ª• tr√™n ƒë√£ minh h·ªça cho ch√∫ng ta 3 c√°ch s·ª≠ d·ª•ng c·ªßa c·ªïng CNOT ƒë√≥ l√† : ƒë·∫£o bit c√≥ ƒëi·ªÅu ki·ªán, t·∫°o r·ªëi l∆∞·ª£ng t·ª≠, g·ª° r·ªëi l∆∞·ª£ng t·ª≠. Ngo√†i ra c√≤n m·ªôt s·ªë c·ªïng n·ªØa m√¨nh kh√¥ng ti·ªán ƒë·ªÅ c·∫≠p ·ªü ƒë√¢y, c√°c b·∫°n c√≥ th·ªÉ v√†o link wiki [n√†y](https://en.wikipedia.org/wiki/Quantum_logic_gate) ƒë·ªÉ t√¨m hi·ªÉu.

![image.png](https://images.viblo.asia/708517f6-0c04-487f-931c-c318921790df.png)
$~~~~~~~~~~~~~~~~~~~~~~~~$[https://en.wikipedia.org/wiki/Quantum_logic_gate](https://en.wikipedia.org/wiki/Quantum_logic_gate)

# Measurement
ƒê·ªëi v·ªõi h·ªá l∆∞·ª£ng t·ª≠ hai c·∫•p, ch·∫≥ng h·∫°n nh∆∞ spin c·ªßa electron, n√≥ c√≥ th·ªÉ quay l√™n  $\uparrow$  ho·∫∑c quay xu·ªëng $\downarrow$ , t∆∞∆°ng ·ª©ng v·ªõi tr·∫°ng th√°i $\ket{0}$ v√† $\ket{1}$. Nh∆∞ ƒë√£ ƒë·ªÅ c·∫≠p tr∆∞·ªõc ƒë√¢y, electron c√≥ th·ªÉ ·ªü tr·∫°ng th√°i ch·ªìng ch·∫•t c·ªßa spin $\uparrow$ v√† $\downarrow$ : $|\psi\rangle =\alpha |0\rangle + \beta |1\rangle$ v√† ph√©p measurement s·∫Ω gi√∫p ch√∫ng ta hi·ªÉu th√™m v·ªÅ tr·∫°ng th√°i ch·ªìng ch·∫•t l√† g√¨. C·∫ßn l∆∞u √Ω r·∫±ng ph√©p measurement trong c∆° h·ªçc l∆∞·ª£ng t·ª≠ th∆∞·ªùng mang t√≠nh th·ªëng k√™ x√°c su·∫•t h∆°n l√† m·ªôt ph√©p measurement ƒë∆°n l·∫ª. ƒêi·ªÅu n√†y l√† do b·∫£n ch·∫•t c·ªßa c√°c ph√©p measurement trong v·∫≠t l√Ω l∆∞·ª£ng t·ª≠, n√≥ l√†m s·ª•p ƒë·ªï tr·∫°ng th√°i l∆∞·ª£ng t·ª≠ quan s√°t ƒë∆∞·ª£c. V√≠ d·ª•, n·∫øu ch√∫ng ta measure m·ªôt electron ·ªü tr·∫°ng th√°i $|\psi\rangle =\alpha |0\rangle + \beta |1\rangle$, ch√∫ng ta s·∫Ω c√≥ x√°c su·∫•t $|\alpha|^2$ thu ƒë∆∞·ª£c k·∫øt qu·∫£ measure spin up, v√† sau khi measure, tr·∫°ng th√°i l∆∞·ª£ng t·ª≠ chuy·ªÉn sang tr·∫°ng th√°i sau ƒëo $|0\rangle$. T∆∞∆°ng t·ª±, ch√∫ng ta c≈©ng c√≥ x√°c su·∫•t $|\beta|^2$ ƒë·ªÉ c√≥ ƒë∆∞·ª£c tr·∫°ng th√°i $|1\rangle$ quay xu·ªëng sau khi measure. V√¨ v·∫≠y, n·∫øu ch√∫ng ta mu·ªën nh·∫≠n ƒë∆∞·ª£c gi√° tr·ªã ch√≠nh x√°c c·ªßa $\alpha$ , ch·ªâ m·ªôt th·ª≠ nghi·ªám th√¨ r√µ r√†ng l√† kh√¥ng ƒë·ªß. Ch√∫ng ta c·∫ßn chu·∫©n b·ªã r·∫•t nhi·ªÅu electron ·ªü tr·∫°ng th√°i ch·ªìng ch·∫•t, measure spin c·ªßa t·ª´ng electron, r·ªìi ƒë·∫øm t·∫ßn s·ªë. Ph√©p measure c√≥ m·ªôt v·ªã tr√≠ ƒë·∫∑c bi·ªát trong c∆° h·ªçc l∆∞·ª£ng t·ª≠ v√† m·∫°ng neuron l∆∞·ª£ng t·ª≠. N·∫øu b·∫°n ƒë·ªçc c·∫£m th·∫•y kh√≥ hi·ªÉu, c√°c b·∫°n c√≥ th·ªÉ tham kh·∫£o link [Measurement in quantum mechanics](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics) ƒë·ªÉ t√¨m hi·ªÉu k·ªπ h∆°n

# Quantum Neural Network
M·∫°ng n∆°ron l∆∞·ª£ng t·ª≠ l√† m·ªôt l·ªõp con c·ªßa c√°c thu·∫≠t to√°n bi·∫øn ƒë·ªïi l∆∞·ª£ng t·ª≠ , bao g·ªìm c√°c m·∫°ch l∆∞·ª£ng t·ª≠ c√≥ ch·ª©a c√°c ho·∫°t ƒë·ªông c·ªïng l∆∞·ª£ng t·ª≠ tham s·ªë h√≥a. D·ªØ li·ªáu ƒë·∫ßu ti√™n ƒë∆∞·ª£c m√£ h√≥a th√†nh tr·∫°ng th√°i l∆∞·ª£ng t·ª≠ th√¥ng qua c√°c c·ªïng l∆∞·ª£ng t·ª≠ ho·∫∑c b·∫£n ƒë·ªì ƒë·∫∑c tr∆∞ng. Vi·ªác l·ª±a ch·ªçn b·∫£n ƒë·ªì ƒë·∫∑c tr∆∞ng th∆∞·ªùng h∆∞·ªõng t·ªõi vi·ªác n√¢ng cao hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh l∆∞·ª£ng t·ª≠ v√† th∆∞·ªùng kh√¥ng ƒë∆∞·ª£c t·ªëi ∆∞u h√≥a c≈©ng nh∆∞ kh√¥ng ƒë∆∞·ª£c training. Khi d·ªØ li·ªáu ƒë∆∞·ª£c m√£ h√≥a sang tr·∫°ng th√°i l∆∞·ª£ng t·ª≠, m·ªôt m√¥ h√¨nh bi·∫øn th·ªÉ ch·ª©a c√°c c·ªïng tham s·ªë h√≥a s·∫Ω ƒë∆∞·ª£c √°p d·ª•ng v√† t·ªëi ∆∞u h√≥a cho m·ªôt task c·ª• th·ªÉ. ƒêi·ªÅu n√†y ƒë∆∞·ª£c th·ª±c hi·ªán th√¥ng qua t·ªëi thi·ªÉu h√†m m·∫•t m√°t t∆∞∆°ng t·ª± nh∆∞ nh·ªØng b√†i to√°n machine learning th√¥ng th∆∞·ªùng, sau ƒë√≥ ƒë·∫ßu ra c·ªßa m√¥ h√¨nh l∆∞·ª£ng t·ª≠ ƒë∆∞·ª£c measure th√¥ng qua h√†m Hamiltonian nh∆∞ l√† c√°c c·ªïng Pauli ch·∫≥ng h·∫°n.
![image.png](https://images.viblo.asia/0c4e957c-4264-4421-b81c-952fb0e4bc67.png)
> **T·ªïng quan v·ªÅ quantum neural network**: ƒë·∫ßu v√†o $x \in \mathbb{R}^{s_{\text {in }}}$ ƒë·∫ßu ti√™n ƒë∆∞·ª£c m√£ h√≥a v√†o kh√¥ng gian l∆∞·ª£ng t·ª≠  $Hilbert$ $S$-qubit th√¥ng qua kh·ªëi feature mapping $\left|\psi_{x}\right\rangle:=\mathcal{U}_{x}|0\rangle^{\otimes S}$ (m·ªôt m·∫°ch tham s·ªë h√≥a l∆∞·ª£ng t·ª≠ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a s·∫µn). D·ªØ li·ªáu sau khi m√£ h√≥a s·∫Ω ƒë∆∞·ª£c "h·ªçc" b·ªüi kh·ªëi variational model hay c≈©ng ch√≠nh l√† c√°c m·∫°ch tham s·ªë h√≥a l∆∞·ª£ng t·ª≠ $| g _ { \theta } \left ( x \right ) \rangle : = G _ { \theta } | \psi _ { x } \rangle$. ƒê·∫ßu ra cu·ªëi c√πng ƒë∆∞·ª£c ƒë∆∞a qua ph√©p measurement v√† h·∫≠u x·ª≠ l√Ω ƒë·ªÉ tr√≠ch xu·∫•t output c·ªßa model v√† mapping v·ªÅ d·∫°ng classical.
## QClassifier
Nh∆∞ v·∫≠y l√† ch√∫ng ta ƒë√£ ƒëi qua nh·ªØng ph·∫ßn l√Ω thuy·∫øt c∆° b·∫£n v√† c·∫ßn thi·∫øt ƒë·ªÉ c√≥ th·ªÉ x√¢y d·ª±ng m·ªôt m·∫°ng neuron l∆∞·ª£ng t·ª≠ ƒë∆°n gi·∫£n, b√¢y gi·ªù s·∫Ω ƒëi v√†o v√≠ d·ª• ƒë·ªÉ c√≥ th·ªÉ tr·ª±c quan h√≥a nh·ªØng g√¨ ch√∫ng ta v·ª´a t√¨m hi·ªÉu nh√© !

M√¨nh s·∫Ω ti·∫øn h√†nh x√¢y d·ª±ng pipeline cho b√†i to√°n adhoc ph√¢n lo·∫°i ƒë∆°n gi·∫£n. ƒê·∫ßu ti√™n ta c·∫ßn import c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt:
```
# Import numpy,paddle and paddle_quantum
import numpy as np
import paddle
import paddle_quantum

# To construct quantum circuit
from paddle_quantum.ansatz import Circuit

# Some functions
from numpy import pi as PI
from paddle import matmul, transpose, reshape  # paddle matrix multiplication and transpose
from paddle_quantum.qinfo import pauli_str_to_matrix # N qubits Pauli matrix
from paddle_quantum.linalg import dagger  # complex conjugate

# Plot figures, calculate the run time
from matplotlib import pyplot as plt
import time
```
Khai b√°o c√°c tham s·ªë ƒë∆∞·ª£c s·ª≠ d·ª•ng cho model :
```
# Parameters for generating the data set
Ntrain = 200        # Specify the training set size
Ntest = 100         # Specify the test set size
boundary_gap = 0.5  # Set the width of the decision boundary
seed_data = 2       # Fixed random seed required to generate the data set
# Parameters for training
N = 4               # Number of qubits required
DEPTH = 1           # Circuit depth
BATCH = 20          # Batch size during training
EPOCH = int(200 * BATCH / Ntrain)
                    # Number of training epochs, the total iteration number "EPOCH * (Ntrain / BATCH)" is chosen to be about 200
LR = 0.01           # Set the learning rate
seed_paras = 19     # Set random seed to initialize various parameters
```
###  Data processing
·ªû v√≠ d·ª• n√†y m√¨nh s·∫Ω d√πng b·ªô d·ªØ li·ªáu c·ªßa paper **Supervised learning with quantum enhanced feature spaces**
H√†m kh·ªüi t·∫°o d·ªØ li·ªáu cho b√†i to√°n ph√¢n lo·∫°i nh·ªã ph√¢n:

```
# Generate a binary classification data set with circular decision boundary
def circle_data_point_generator(Ntrain, Ntest, boundary_gap, seed_data):
    """
    :param Ntrain: number of training samples
    :param Ntest: number of test samples
    :param boundary_gap: value in (0, 0.5), means the gap between two labels
    :param seed_data: random seed
    :return: 'Ntrain' samples for training and
             'Ntest' samples for testing
    """
    # Generate "Ntrain + Ntest" pairs of data, x for 2-dim data points, y for labels.
    # The first "Ntrain" pairs are used as training set, the last "Ntest" pairs are used as testing set
    train_x, train_y = [], []
    num_samples, seed_para = 0, 0
    while num_samples < Ntrain + Ntest:
        np.random.seed((seed_data + 10) * 1000 + seed_para + num_samples)
        data_point = np.random.rand(2) * 2 - 1  # 2-dim vector in range [-1, 1]

        # If the modulus of the data point is less than (0.7 - gap), mark it as 0
        if np.linalg.norm(data_point) < 0.7-boundary_gap / 2:
            train_x.append(data_point)
            train_y.append(0.)
            num_samples += 1

        # If the modulus of the data point is greater than (0.7 + gap), mark it as 1
        elif np.linalg.norm(data_point) > 0.7 + boundary_gap / 2:
            train_x.append(data_point)
            train_y.append(1.)
            num_samples += 1
        else:
            seed_para += 1

    train_x = np.array(train_x).astype("float64")
    train_y = np.array([train_y]).astype("float64").T

    print("The dimensions of the training set x {} and y {}".format(np.shape(train_x[0:Ntrain]), np.shape(train_y[0:Ntrain])))
    print("The dimensions of the test set x {} and y {}".format(np.shape(train_x[Ntrain:]), np.shape(train_y[Ntrain:])), "\n")

    return train_x[0:Ntrain], train_y[0:Ntrain], train_x[Ntrain:], train_y[Ntrain:]

```

·ªû ƒë√¢y m√¨nh s·∫Ω t·∫°o training set l√† 200 m·∫´u v√† test set l√† 100 m·∫´u, sau ƒë√≥ visualize d·ªØ li·ªáu ƒë·ªÉ d·ªÖ h√¨nh dung h∆°n nh√© :
```
def data_point_plot(data, label):
    """
    :param data: shape [M, 2], means M 2-D data points
    :param label: value 0 or 1
    :return: plot these data points
    """
    dim_samples, dim_useless = np.shape(data)
    plt.figure(1)
    for i in range(dim_samples):
        if label[i] == 0:
            plt.plot(data[i][0], data[i][1], color="r", marker="o")
        elif label[i] == 1:
            plt.plot(data[i][0], data[i][1], color="b", marker="o")
    plt.show()
# Generate data set
train_x, train_y, test_x, test_y = circle_data_point_generator(
        Ntrain, Ntest, boundary_gap, seed_data)

# Visualization
print("Visualization of {} data points in the training set: ".format(Ntrain))
data_point_plot(train_x, train_y)
print("Visualization of {} data points in the test set: ".format(Ntest))
data_point_plot(test_x, test_y)

```
The dimensions of the training set x (200, 2) and y (200, 1)

The dimensions of the test set x (100, 2) and y (100, 1) 

Visualization of 200 data points in the training set: 

![image.png](https://images.viblo.asia/c964634d-730c-447d-817c-a96e31c96e55.png)
Visualization of 100 data points in the test set: 

![image.png](https://images.viblo.asia/6889a204-b237-40ed-92ad-efb414335589.png)

Kh√°c v·ªõi h·ªçc m√°y c·ªï ƒëi·ªÉn, m·∫°ng neuron l∆∞·ª£ng t·ª≠ c·∫ßn ph·∫£i xem x√©t nhi·ªÅu h∆°n ƒë·∫øn vi·ªác ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu. Ch√∫ng ta c·∫ßn th√™m m·ªôt b∆∞·ªõc  ƒë·ªÉ chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu c·ªï ƒëi·ªÉn th√†nh d·ªØ li·ªáu l∆∞·ª£ng t·ª≠ tr∆∞·ªõc khi ch·∫°y m√¥ ph·ªèng thu·∫≠t to√°n. Ti·∫øp theo ƒë√¢y m√¨nh s·∫Ω s·ª≠ d·ª•ng ph∆∞∆°ng ph√°p "Angle Encoding" ƒë·ªÉ m√£ h√≥a d·ªØ li·ªáu sang kh√¥ng gian $Hilbert$.

ƒê·∫ßu ti√™n ch√∫ng ta c·∫ßn quy·∫øt ƒë·ªãnh xem c·∫ßn s·ª≠ d·ª•ng bao nhi√™u qubit, b·ªüi v√¨ d·ªØ li·ªáu m√¨nh s·ª≠ d·ª•ng ch·ªâ c√≥ 2 chi·ªÅu $\{x^{k} = (x^{k}_0, x^{k}_1)\}$, theo nh∆∞ paper Quantum Circuit Learning th√¨ m√¨nh s·∫Ω c·∫ßn √≠t nh·∫•t 2 qubit ƒë·ªÉ m√£ h√≥a d·ªØ li·ªáu. Sau ƒë√≥ ƒë∆∞a $\{x^{k}\}$ qua m·ªôt t·ªï h·ª£p c·ªïng l∆∞·ª£ng t·ª≠ $U(x^{k})$ v√† x·ª≠ l√Ω d·ª±a tr√™n tr·∫°ng th√°i kh·ªüi t·∫°o $|00\rangle$. Th√¥ng qua c√°ch n√†y, m√¨nh ƒë√£ m√£ h√≥a ƒë∆∞·ª£c d·ªØ li·ªáu $|\psi_{\rm in}\rangle$ t·ª´ kh√¥ng gian 2 chi·ªÅu ·ªü h·ªá  $Descartes$ sang kh√¥ng gian l∆∞·ª£ng t·ª≠ $Hilbert$:
$$|\psi_{\rm in}\rangle =
U(x)|00\rangle = \frac{1}{2}
\begin{bmatrix}
1-i &0 &-1+i &0 \\
0 &1+i &0 &-1-i \\
1-i &0 &1-i &0 \\
0 &1+i &0 &1+i
\end{bmatrix}
\begin{bmatrix}
1 \\
0 \\
0 \\
0
\end{bmatrix}
= \frac{1}{2}
\begin{bmatrix}
1-i \\
0 \\
1-i \\
0
\end{bmatrix}.
$$
```
# Gate: rotate around Y-axis, Z-axis with angle theta
def Ry(theta):
    """
    :param theta: parameter
    :return: Y rotation matrix
    """
    return np.array([[np.cos(theta / 2), -np.sin(theta / 2)],
                     [np.sin(theta / 2), np.cos(theta / 2)]])

def Rz(theta):
    """
    :param theta: parameter
    :return: Z rotation matrix
    """
    return np.array([[np.cos(theta / 2) - np.sin(theta / 2) * 1j, 0],
                     [0, np.cos(theta / 2) + np.sin(theta / 2) * 1j]])

# Classical -> Quantum Data Encoder
def datapoints_transform_to_state(data, n_qubits):
    """
    :param data: shape [-1, 2]
    :param n_qubits: the number of qubits to which
    the data transformed
    :return: shape [-1, 1, 2 ^ n_qubits]
        the first parameter -1 in this shape means can be arbitrary. In this tutorial, it equals to BATCH.
    """
    dim1, dim2 = data.shape
    res = []
    for sam in range(dim1):
        res_state = 1.
        zero_state = np.array([[1, 0]])
        # Angle Encoding
        for i in range(n_qubits):
            # For even number qubits, perform Rz(arccos(x0^2)) Ry(arcsin(x0))
            if i % 2 == 0:
                state_tmp=np.dot(zero_state, Ry(np.arcsin(data[sam][0])).T)
                state_tmp=np.dot(state_tmp, Rz(np.arccos(data[sam][0] ** 2)).T)
                res_state=np.kron(res_state, state_tmp)
            # For odd number qubits, perform Rz(arccos(x1^2)) Ry(arcsin(x1))
            elif i% 2 == 1:
                state_tmp=np.dot(zero_state, Ry(np.arcsin(data[sam][1])).T)
                state_tmp=np.dot(state_tmp, Rz(np.arccos(data[sam][1] ** 2)).T)
                res_state=np.kron(res_state, state_tmp)
        res.append(res_state)
    res = np.array(res, dtype=paddle_quantum.get_dtype())
    
    return res
```

D·ªØ li·ªáu sau khi ƒë∆∞·ª£c encode :
```
print("As a test, we enter the classical information:")
print("(x_0, x_1) = (1, 0)")
print("The 2-qubit quantum state output after encoding is:")
print(datapoints_transform_to_state(np.array([[1, 0]]), n_qubits=2))
```
![image.png](https://images.viblo.asia/d89d182b-1fc3-4386-b88f-bf52446222a7.png)

### Build Quantum Neural Network
ƒê·ªÉ thu·∫≠n ti·ªán th√¨ ch√∫ng ta s·∫Ω g·ªçi m·∫°ng l∆∞·ª£ng t·ª≠ tham s·ªë h√≥a l√† $U(\boldsymbol{\theta})$. T∆∞∆°ng t·ª± nh∆∞ c√°c m·∫°ng neuron c·ªï ƒëi·ªÉn, ch√∫ng ta ho√†n to√†n c√≥ th·ªÉ t·ª± ƒë·ªãnh nghƒ©a c·∫•u tr√∫c c·ªßa m·∫°ng neuron l∆∞·ª£ng t·ª≠ th√¥ng qua c√°c c·ªïng logic l∆∞·ª£ng t·ª≠. Sau khi c√≥ ƒë∆∞·ª£c d·ªØ li·ªáu ƒë√£ qua m√£ h√≥a $|\psi_{\rm in}\rangle$ ta s·∫Ω ƒë∆∞a n√≥ v√†o m·∫°ng neuron l∆∞·ª£ng t·ª≠, th·ª±c ch·∫•t ch·ªâ l√† m·ªôt ph√©p nh√¢n ma tr·∫≠n ƒë∆°n nh·∫•t v·ªõi vector ƒë·∫ßu v√†o ƒë·ªÉ l·∫•y tr·∫°ng th√°i quantum ƒë·∫ßu ra $|\varphi\rangle$
$$|\psi_{\rm out}\rangle = U(\boldsymbol{\theta})|\psi_{\rm in}\rangle.$$
Gi·∫£ s·ª≠ to√†n b·ªô tham s·ªë $\theta = \pi$ ta s·∫Ω c√≥ tr·∫°ng th√°i ƒë·∫ßu ra nh∆∞ sau :
$$|\psi_{\rm out}\rangle =
U(\boldsymbol{\theta} =\pi)|\psi_{\rm in}\rangle =
\begin{bmatrix}
0 &0 &-1 &0 \\
-1 &0 &0 &0 \\
0 &1 &0 &0 \\
0 &0 &0 &1
\end{bmatrix}
\cdot
\frac{1}{2}
\begin{bmatrix}
1-i \\
0 \\
1-i \\
0
\end{bmatrix}
= \frac{1}{2}
\begin{bmatrix}
-1+i \\
-1+i \\
0 \\
0
\end{bmatrix}.
$$

### Measurement
Sau khi ƒëi qua PQC $U(\theta)$, d·ªØ li·ªáu l∆∞·ª£ng t·ª≠ tr·ªü th√†nh $\lvert \psi_{\rm out}\rangle^k = U(\theta)\lvert \psi_{\rm in} \rangle^k$. ƒê·ªÉ c√≥ ƒë∆∞·ª£c nh√£n c·ªßa d·ªØ li·ªáu, ch√∫ng ta c·∫ßn measure tr·∫°ng th√°i l∆∞·ª£ng t·ª≠ m·ªõi ƒë·ªÉ thu ƒë∆∞·ª£c d·ªØ li·ªáu classical. Nh·ªØng d·ªØ li·ªáu classica n√†y sau ƒë√≥ s·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t√≠nh to√°n h√†m m·∫•t m√°t $\mathcal{L}(\boldsymbol{\theta})$. Cu·ªëi c√πng, d·ª±a tr√™n thu·∫≠t to√°n gradient descent, ta li√™n t·ª•c c·∫≠p nh·∫≠t c√°c th√¥ng s·ªë PQC v√† t·ªëi ∆∞u h√≥a h√†m m·∫•t m√°t. Gi√° tr·ªã m√† ch√∫ng ta ƒë·∫°t ƒë∆∞·ª£c sau ph√©p measure : 
$$\langle Z \rangle =
\langle \psi_{\rm out} |Z\otimes I| \psi_{\rm out}\rangle =
\frac{1}{2}
\begin{bmatrix}
-1-i \quad
-1-i \quad
0 \quad
0
\end{bmatrix}
\begin{bmatrix}
1 &0 &0 &0 \\
0 &1 &0 &0 \\
0 &0 &-1 &0 \\
0 &0 &0 &-1
\end{bmatrix}
\cdot
\frac{1}{2}
\begin{bmatrix}
-1+i \\
-1+i \\
0 \\
0
\end{bmatrix}
= 1. $$
Th√¥ng th∆∞·ªùng ƒë·∫ßu ra $\langle Z \rangle$ s·∫Ω n·∫±m trong kho·∫£ng $[-1,1]$. ƒê·ªÉ ƒë·∫ßu ra n√†y kh·ªõp v·ªõi nh√£n ƒë√£ ƒë·ªãnh nghƒ©a tr∆∞·ªõc $y^{k} \in \{0,1\}$, ta s·∫Ω c·∫ßn 1 h√†m √°nh x·∫° ƒë∆°n gi·∫£n: 
$$\tilde{y}^{k} = \frac{\langle Z \rangle}{2} + \frac{1}{2} + bias \quad \in [0, 1].$$
Sau khi √°nh x·∫°, ch√∫ng ta c√≥ th·ªÉ coi $\tilde{y}^{k}$ l√† nh√£n m√† c·∫ßn t√¨m v·ªõi $\tilde{y}^{k}< 0.5$ t∆∞∆°ng ·ª©ng nh√£n 0 v√†  $\tilde{y}^{k}\geq 0.5$ t∆∞∆°ng ·ª©ng nh√£n 1. To√†n b·ªô qu√° tr√¨nh t·ª´ b∆∞·ªõc x·ª≠ l√Ω d·ªØ li·ªáu ƒë·∫øn t√≠nh to√°n ƒë·∫ßu ra c√≥ th·ªÉ m√¥ t·∫£ nh∆∞ sau:
$$x^{k} \rightarrow |\psi_{\rm in}\rangle^{k} \rightarrow U(\boldsymbol{\theta})|\psi_{\rm in}\rangle^{k} \rightarrow
|\psi_{\rm out}\rangle^{k} \rightarrow ^{k}\langle \psi_{\rm out} |Z\otimes I\cdots \otimes I| \psi_{\rm out} \rangle^{k}
\rightarrow \langle Z \rangle  \rightarrow \tilde{y}^{k}.$$

### Loss function
H√†m loss ƒë∆∞·ª£c t√≠nh to√°n nh∆∞ sau :
$$\mathcal{L}_{i} = \sum_{k=1}^{BATCH} \frac{1}{BATCH} |y^{i,k} - \tilde{y}^{i,k}|^2$$

**Quantum Neural Network**:
```
# Generate Pauli Z operator that only acts on the first qubit
# Act the identity matrix on rest of the qubits
def Observable(n):
    r"""
    :param n: number of qubits
    :return: local observable: Z \otimes I \otimes ...\otimes I
    """
    Ob = pauli_str_to_matrix([[1.0, 'z0']], n)

    return Ob
```
```
# Build the computational graph
class Opt_Classifier(paddle_quantum.gate.Gate):
    """
    Construct the model net
    """
    def __init__(self, n, depth, seed_paras=1):
        # Initialization, use n, depth give the initial PQC
        super(Opt_Classifier, self).__init__()
        self.n = n
        self.depth = depth
        # Initialize bias
        self.bias = self.create_parameter(
            shape=[1],
            default_initializer=paddle.nn.initializer.Normal(std=0.01),
            dtype='float32',
            is_bias=False)
        
        self.circuit = Circuit(n)
        # Build a generalized rotation layer
        for i in range(n):
            self.circuit.rz(qubits_idx=i)
            self.circuit.ry(qubits_idx=i)
            self.circuit.rz(qubits_idx=i)

        # The default depth is depth = 1
        # Build the entangleed layer and Ry rotation layer
        for d in range(3, depth + 3):
            # The entanglement layer
            for i in range(n-1):
                self.circuit.cnot(qubits_idx=[i, i + 1])
            self.circuit.cnot(qubits_idx=[n-1, 0])
            # Add Ry to each qubit
            for i in range(n):
                self.circuit.ry(qubits_idx=i)

    # Define forward propagation mechanism, and then calculate loss function and cross-validation accuracy
    def forward(self, state_in, label):
        """
        Args:
            state_in: The input quantum state, shape [-1, 1, 2^n] -- in this tutorial: [BATCH, 1, 2^n]
            label: label for the input state, shape [-1, 1]
        Returns:
            The loss:
                L = 1/BATCH * ((<Z> + 1)/2 + bias - label)^2
        """
        # Convert Numpy array to tensor
        Ob = paddle.to_tensor(Observable(self.n))
        label_pp = reshape(paddle.to_tensor(label), [-1, 1])

        # Build the quantum circuit
        Utheta = self.circuit.unitary_matrix()

        # Because Utheta is achieved by learning, we compute with row vectors to speed up without affecting the training effect
        state_out = matmul(state_in, Utheta)  # shape:[-1, 1, 2 ** n], the first parameter is BATCH in this tutorial

        # Measure the expectation value of Pauli Z operator <Z> -- shape [-1,1,1]
        E_Z = matmul(matmul(state_out, Ob), transpose(paddle.conj(state_out), perm=[0, 2, 1]))

        # Mapping <Z> to the estimated value of the label
        state_predict = paddle.real(E_Z)[:, 0] * 0.5 + 0.5 + self.bias  # |y^{i,k} - \tilde{y}^{i,k}|^2
        loss = paddle.mean((state_predict - label_pp) ** 2)  # Get average for "BATCH" |y^{i,k} - \tilde{y}^{i,k}|^2: L_iÔºöshape:[1,1]

        # Calculate the accuracy of cross-validation
        is_correct = (paddle.abs(state_predict - label_pp) < 0.5).nonzero().shape[0]
        acc = is_correct / label.shape[0]

        return loss, acc, state_predict.numpy(), self.circuit
```

**Training Process**
```
# Draw the figure of the final training classifier
def heatmap_plot(Opt_Classifier, N):
    # generate data points x_y_
    Num_points = 30
    x_y_ = []
    for row_y in np.linspace(0.9, -0.9, Num_points):
        row = []
        for row_x in np.linspace(-0.9, 0.9, Num_points):
            row.append([row_x, row_y])
        x_y_.append(row)
    x_y_ = np.array(x_y_).reshape(-1, 2).astype("float64")

    # make prediction: heat_data
    input_state_test = paddle.to_tensor(
        datapoints_transform_to_state(x_y_, N))
    loss_useless, acc_useless, state_predict, cir = Opt_Classifier(state_in=input_state_test, label=x_y_[:, 0])
    heat_data = state_predict.reshape(Num_points, Num_points)

    # plot
    fig = plt.figure(1)
    ax = fig.add_subplot(111)
    x_label = np.linspace(-0.9, 0.9, 3)
    y_label = np.linspace(0.9, -0.9, 3)
    ax.set_xticks([0, Num_points // 2, Num_points - 1])
    ax.set_xticklabels(x_label)
    ax.set_yticks([0, Num_points // 2, Num_points - 1])
    ax.set_yticklabels(y_label)
    im = ax.imshow(heat_data, cmap=plt.cm.RdBu)
    plt.colorbar(im)
    plt.show()

# Learn the PQC via Adam

def QClassifier(Ntrain, Ntest, gap, N, DEPTH, EPOCH, LR, BATCH, seed_paras, seed_data):
    """
    Quantum Binary Classifier
    Input:
        Ntrain         # Specify the training set size
        Ntest          # Specify the test set size
        gap            # Set the width of the decision boundary
        N              # Number of qubits required
        DEPTH          # Circuit depth
        BATCH          # Batch size during training
        EPOCH          # Number of training epochs, the total iteration number "EPOCH * (Ntrain / BATCH)" is chosen to be about 200
        LR             # Set the learning rate
        seed_paras     # Set random seed to initialize various parameters
        seed_data      # Fixed random seed required to generate the data set
        plot_heat_map  # Whether to plot heat map, default True
    """
    # Generate data set
    train_x, train_y, test_x, test_y = circle_data_point_generator(Ntrain=Ntrain, Ntest=Ntest, boundary_gap=gap, seed_data=seed_data)
    # Read the dimension of the training set
    N_train = train_x.shape[0]
    
    paddle.seed(seed_paras)
    # Initialize the registers to store the accuracy rate and other information
    summary_iter, summary_test_acc = [], []

    # Generally, we use Adam optimizer to get relatively good convergence
    # Of course, it can be changed to SGD or RMSprop
    myLayer = Opt_Classifier(n=N, depth=DEPTH)  # Initial PQC
    opt = paddle.optimizer.Adam(learning_rate=LR, parameters=myLayer.parameters())


    # Optimize iteration
    # We divide the training set into "Ntrain/BATCH" groups
    # For each group the final circuit will be used as the initial circuit for the next group
    # Use cir to record the final circuit after learning.
    i = 0  # Record the iteration number
    for ep in range(EPOCH):
        # Learn for each group
        for itr in range(N_train // BATCH):
            i += 1  # Record the iteration number
            # Encode classical data into a quantum state |psi>, dimension [BATCH, 2 ** N]
            input_state = paddle.to_tensor(datapoints_transform_to_state(train_x[itr * BATCH:(itr + 1) * BATCH], N))

            # Run forward propagation to calculate loss function
            loss, train_acc, state_predict_useless, cir \
                = myLayer(state_in=input_state, label=train_y[itr * BATCH:(itr + 1) * BATCH])  # optimize the given PQC
            # Print the performance in iteration
            if i % 30 == 5:
                # Calculate the correct rate on the test set test_acc
                input_state_test = paddle.to_tensor(datapoints_transform_to_state(test_x, N))
                loss_useless, test_acc, state_predict_useless, t_cir \
                    = myLayer(state_in=input_state_test,label=test_y)
                print("epoch:", ep, "iter:", itr,
                      "loss: %.4f" % loss.numpy(),
                      "train acc: %.4f" % train_acc,
                      "test acc: %.4f" % test_acc)
                # Store accuracy rate and other information
                summary_iter.append(itr + ep * N_train)
                summary_test_acc.append(test_acc) 

            # Run back propagation to minimize the loss function
            loss.backward()
            opt.minimize(loss)
            opt.clear_grad()
            
    # Print the final circuit
    print("The trained circuit:")
    print(cir)
    # Draw the decision boundary represented by heatmap
    heatmap_plot(myLayer, N=N)

    return summary_test_acc
```

```
def main():
    """
    main
    """
    time_start = time.time()
    acc = QClassifier(
        Ntrain = 200,    # Specify the training set size
        Ntest = 100,     # Specify the test set size
        gap = 0.5,       # Set the width of the decision boundary
        N = 4,           # Number of qubits required
        DEPTH = 1,       # Circuit depth
        BATCH = 20,      # Batch size during training
        EPOCH = int(200 * BATCH / Ntrain),
                        # Number of training epochs, the total iteration number "EPOCH * (Ntrain / BATCH)" is chosen to be about 200
        LR = 0.01,       # Set the learning rate
        seed_paras = 19, # Set random seed to initialize various parameters
        seed_data = 2,   # Fixed random seed required to generate the data set
    )
    
    time_span = time.time()-time_start
    print('The main program finished running in ', time_span, 'seconds.')

if __name__ == '__main__':
    main()
```
```
The dimensions of the training set x (200, 2) and y (200, 1)
The dimensions of the test set x (100, 2) and y (100, 1) 

epoch: 0 iter: 4 loss: 0.2750 train acc: 0.7000 test acc: 0.6700

epoch: 3 iter: 4 loss: 0.2471 train acc: 0.2500 test acc: 0.5500
epoch: 6 iter: 4 loss: 0.1976 train acc: 0.8000 test acc: 0.9200
epoch: 9 iter: 4 loss: 0.1639 train acc: 1.0000 test acc: 1.0000
epoch: 12 iter: 4 loss: 0.1441 train acc: 1.0000 test acc: 1.0000
epoch: 15 iter: 4 loss: 0.1337 train acc: 1.0000 test acc: 1.0000
epoch: 18 iter: 4 loss: 0.1287 train acc: 1.0000 test acc: 1.0000
The trained circuit:
--Rz(3.490)----Ry(5.436)----Rz(3.281)----*--------------x----Ry(0.098)--
                                         |              |               
--Rz(1.499)----Ry(2.579)----Rz(3.496)----x----*---------|----Ry(1.282)--
                                              |         |               
--Rz(5.956)----Ry(3.158)----Rz(3.949)---------x----*----|----Ry(1.418)--
                                                   |    |               
--Rz(1.604)----Ry(0.722)----Rz(5.037)--------------x----*----Ry(2.437)--
```
![image.png](https://images.viblo.asia/539c62af-82e6-4bc9-b676-3f3d159042e7.png)
```
The main program finished running in  7.628719806671143 seconds.
```

# T·ªïng k·∫øt
Nh∆∞ v·∫≠y ch√∫ng ta ƒë√£ ƒëi qua m·ªôt lo·∫°t c√°c kh√°i ni·ªám c∆° b·∫£n v·ªÅ Quantum Computing v√† Quantum Neural Network, ƒë·ªìng th·ªùi x√¢y d·ª±ng m·ªôt m·∫°ng neuron l∆∞·ª£ng t·ª≠ ƒë∆°n gi·∫£n. Theo nh∆∞ nh·ªØng nghi√™n c·ª©u g·∫ßn ƒë√¢y th√¨ m·∫∑c d√π ƒë√£ c√≥ nhi·ªÅu b∆∞·ªõc ph√°t tri·ªÉn trong lƒ©nh v·ª±c h·ªçc m√°y l∆∞·ª£ng t·ª≠ th·∫ø nh∆∞ng c√¢u h·ªèi li·ªáu m·∫°ng n∆°-ron l∆∞·ª£ng t·ª≠ c√≥ m·∫°nh h∆°n m·∫°ng n∆°-ron c·ªï ƒëi·ªÉn hay kh√¥ng v·∫´n c√≤n b·ªè ng·ªè. ƒê√¢y l√† m·ªôt c√¥ng ngh·ªá kh√° non tr·∫ª nh∆∞ng ti·ªÅm nƒÉng c·ªßa n√≥ l·∫°i r·∫•t l·ªõn trong ng√†nh tr√≠ tu·ªá nh√¢n t·∫°o. B√†i vi·∫øt c≈©ng ƒë√£ d√†i, c·∫£m ∆°n c√°c b·∫°n d√†nh th·ªùi gian ƒë·ªçc, n·∫øu c√≥ sai s√≥t ho·∫∑c th·∫Øc m·∫Øc c√°c b·∫°n c√≥ th·ªÉ comment ·ªü b√™n d∆∞·ªõi v√† m√¨nh s·∫Ω c·ªë g·∫Øng gi·∫£i ƒë√°p n·∫øu trong t·∫ßm hi·ªÉu bi·∫øt c·ªßa m√¨nh üòÖ. H·∫πn c√°c b·∫°n trong b√†i vi·∫øt ti·∫øp theo. 

# References
1. [Quantum Neural Networks: Concepts, Applications, and Challenges](https://arxiv.org/pdf/2108.01468.pdf)
2. [The power of quantum neural networks](https://arxiv.org/pdf/2011.00027.pdf)
3. [Supervised learning with quantum enhanced feature spaces](https://arxiv.org/pdf/1804.11326.pdf)
4. [Classification with Quantum Neural Networks on Near Term Processors](https://arxiv.org/abs/1802.06002)
5. https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics
6. https://vi.wikibooks.org/wiki/T%C3%ADnh_to%C3%A1n_l%C6%B0%E1%BB%A3ng_t%E1%BB%AD/T%C3%ADnh_to%C3%A1n_l%C6%B0%E1%BB%A3ng_t%E1%BB%AD
7. https://en.wikipedia.org/wiki/Quantum_logic_gate
8. https://github.com/PaddlePaddle/Quantum