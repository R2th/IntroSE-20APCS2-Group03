Chào các bạn, ở phần 2 này mình sẽ nói về các gem được sử dụng với mục đích debug, xác thực, bảo mật, API, deploy và upload. 
# Debugging
Đã là developer thì việc gặp bug cũng là chuyện xảy ra hàng ngày. Bug có thể xảy ra bởi bất cứ nguyên nhân nào, do sai cú pháp, do sai logic, ... Tuy nhiên, trang thông báo lỗi mặc định của rails trông lại có vẻ hơi... ngớ ngẩn. Do vậy các developer đã tìm ra các biện pháp khác để thay thế. Ví dụ, gem [better rrors](https://github.com/charliesome/better_errors) sẽ show ra một trang tĩnh để hiển thị lỗi cho Rack app, nhưng sẽ có một chút bất tiện bởi chúng ta không thể xem được nguyên nhân nào gây ra lỗi ngoại trừ cách thông qua `stack trace`.

Một gem khác, [binding of caller](https://github.com/banister/binding_of_caller), đưa ra một màn hình báo lỗi đầy đủ hơn trên browser và cho phép inspec các biến trong app khi nó crash. Bản thân mình cũng đã được một anh senior tr+ong công ty gợi ý sử dụng gem này trước khi phải dùng đến byebug. Đây là những gem giúp hiển thị lỗi trên browser. 

Trong trường hợp chúng không giúp gì bạn trong quá trình fix bug, ta cần sử dụng đến những gem khác để can thiệp trực tiếp vào server. Và đó là lúc ra cần đến [pry-byebug](https://github.com/deivid-rodriguez/pry-byebug). Mình có thể khẳng định bất cứ ai đã code rails thì không thể không biết đến gem này. Đây là một gem cực  kỳ hữu ích. Bạn có thể đặt `breakpoint` rồi chạy `step-by-step` để tìm xem bug xuất hiện ở dòng nào. Nó cho phép bạn sử dụng console ngay tại chỗ đặt `breakpoint` để kiểm tra và thực thi từng dòng code ở đoạn đó. Một trong những tính năng mình thích nhất ở gem này là nó đã đổi màu text ở trong console để dễ nhìn và giúp tăng tốc độ debug đáng kể.
# Authentication and Authorization
 Một trong các chức năng mà hầu hết các website bây giờ đều có, đó là chức năng đăng nhập. Điều đó đồng nghĩa với việc bạn cần phải có các method `authentication` và `authorization`. Với những dev thuộc dạng tay to thì họ thích viết những `custom method` hơn do đã hiểu và nắm rõ về cách thức hoạt động của các method này, tuy nhiên với một số dev khác thì lại thích sử dụng các gem có sẵn do nó đã có đầy đủ các method mà họ mong muốn, giúp tiết kiệm được kha khá thời gian và tăng effort.
 
 Một trong những việc khó nhất đó là tìm được một ruby dev chưa từng nghe tới gem [Devise](https://github.com/plataformatec/devise). Devise dựa trên `Rails MVC stack`, thêm các hỗ trợ OmniAuth để xác thực người dùng, reset password, và nếu cần thì lưu trữ password trong database để đơn giản hóa việc xác thực. Không chỉ có vậy, Devise còn theo dõi số liệu bao gồm địa chỉ IP và timestamps, kết thúc các phiên làm việc của user sau một khoảng thời gian xác định, và khóa account trong trường hợp login fail quá nhiều và còn nhiều tính năng khác mà bạn nên đọc trên docs của gem. 
 
 
 Bên cạnh việc tạo tài khoản mới trên trang web đó rồi mới login, chúng ta cũng có thể login thông qua một account bên thứ 3 như Facebook hay Google, Linkedln, Steam, GitHub ..v...v... Điều này giúp người dùng tiết kiệm thời gian. Đặc biệt là với những người lười như mình thì rất ngại việc tạo một acc mới mỗi khi truy cập một trang web bởi một lý do khá đơn giản, mình thường xuyên quên mật khẩu, nhiều lúc vào lại một trang nào đó lại mất tới 10p là ít chỉ để nghĩ xem mật khẩu đã tạo là gì và cuối cùng thì mình vẫn phải tạo acc mới. Và với gem [ OmniAuth](https://github.com/omniauth/omniauth) ta có thể thực hiện một cách dễ dàng. Nó cung cấp đầy đủ các `authentication method ` hỗ trợ. Các bạn có thể đọc docs để hiểu rõ hơn về phương thức hoạt động của nó. 
 
 Và gem cuối cùng mình muốn đề cập đến là [CanCanCan](https://github.com/CanCanCommunity/cancancan). Khi xây dụng một ứng dụng phức tạp, trong đó người dùng phải chia thành nhiều role khác nhau, bạn sẽ phải set quyền truy cập cho từng loại user một. User này sẽ chỉ có thể được truy cập vào chỗ này, user khác sẽ chỉ được truy cập chỗ khác, ... Gem `cancancan` cho phép bạn định nghĩa chính xác chức năng của từng loại user một.
 # APIs
 Một cách hiểu đơn giản thì API là một tập các `requirement` cho việc trao đổi data giữa các applications. Bạn có thể đăng nhập vào các trang web bằng tài khoản FB của mình nhờ có API, tìm kiếm các quán ăn trên [Foody](https://www.foody.vn/ha-noi) hay [Lozi](https://lozi.vn/) thông qua Google Maps cũng là nhờ các API..v..v.. Việc xây dựng các API đôi lúc có thể khá khó khăn, nhưng có khi lại chỉ cần một vài dòng code đơn giản. 
 Hiện có khá nhiều gem hỗ trợ việc viết API trong Rails, và chính bản thân Rails 5 cũng đã hỗ trợ cho việc này. Tuy nhiên thì mình vẫn suggest các bạn sử dụng gem [Grape](https://github.com/ruby-grape/grape). Theo đánh giá của mình thì đây là một gem khá đơn giản và dễ sử dụng. 

Và đi kèm với `Grape`  là một gem mà theo mình thấy là xuất hiện ở hầu hết các project về rails API ở công ty, đó là gem [Active Model Serializer](https://github.com/rails-api/active_model_serializers). Với gem này ta có thể quyết định xem các `attributes` nào của record sẽ được trả về, tùy thuộc vào spec của dự án. 
# Security 
Khi chúng ta xây dựng một web app mà có lưu trữ thông tin cá nhân người dùng hoặc các thông tin giao dịch thì việc bảo mật là điều vô cùng quan trọng. 
[Brakeman](https://github.com/presidentbeef/brakeman) có thể coi như là một máy quét bảo mật, giúp phát hiện các lỗ hổng trong một `Rails application`. Trong trường hợp nó report các lỗ hổng mặc dù chúng không quan trọng, bạn cũng có thể dễ dàng config lại list các warning để tránh phải nhận các thông báo không cần thiết. Bản thân mình cũng đã từng có thời gian khá vất vả để viết sql sao cho pass được brakeman nên mình đánh giá đây là một gem rất tốt.

Trong trường hợp bạn muốn kiểm tra các gem trong app để tìm kiếm các lỗ hổng, hãy thử với gem [bunlder-audit](https://github.com/rubysec/bundler-audit). Với gem này bạn sẽ không mất thời gian để kiểm tra từng gem một bởi nó sẽ review file gemflie.lock giúp bạn để tìm ra các version gem không tốt và ngăn chặn việc fetching các gem không đáng tin cậy.

Một gem nữa là [Secure Header](https://github.com/twitter/secure_headers), tuy nhiên gem này thì mình chưa sử dụng bao giờ nên cũng không dám đưa ra nhận xét gì nhiều, các bạn có thể đọc docs của nó để tìm hiểu thêm.

# Deployment
Deployment là một trong những bước quan trọng trong vòng đời phát triển phần mềm, khi ứng dụng của chúng ta đã sẵn sàng để đưa vào sử dụng. Có rất nhiều web server có thể host một Rails web apps. Ví dụ, Puma và Unicorn là các `HTTP web server` thường được sử dụng để deploy một rails app. Và tương ứng với chúng, ta cũng có gem [Puma](https://github.com/puma/puma) và [Unicorn](https://github.com/samuelkadolph/unicorn-rails) để thực hiện việc này. 

Một web app phải trải qua khá nhiều bước trước khi được deploy, bao gồm `copy file`, `migrate database` và `compiling assest`. Các task tẻ nhạt đó có thể hoàn thành với một công cụ deploy tự động - [Caspitrano](https://github.com/capistrano/capistrano). [Caspitrano](https://github.com/capistrano/capistrano) xử lý nhiều hoạt động bao gồm `tagging server` cho các role khác nhau, xử lý `multiple stage` và thực hiện `parallel deployment`. `Caspitrano` hoạt động hiệu quả với [Chef](https://github.com/poise/application), cài đặt và quản lý server bằng cách cài các `package`, đặt các file vào các vị trí xác định... `Chef` hiếm khi được sử dụng để deploy do nó có khá ít tài nguyên phục vụ cho việc custom và deploy tự động.

# Uploading Files
Khi xây dựng một trang web, chắc chắn sẽ có những lúc người dùng cần phải upload file để sử dụng tùy theo mục đích của họ. File có thể bao gồm ảnh, documents, audio, video, ..v.v.. Và một trong những phương pháp hiệu quả nhất cho việc này là sử dụng gem [Carrierwave](https://github.com/carrierwaveuploader/carrierwave). Mình cá là ở đây cũng đã có khá nhiều bạn đã nghe qua hoặc sử dụng gem này trong các dự án của mình.  Các `function` của `Carrierwave` giống như một file uploader. Đặc biệt với ảnh thì nó còn hỗ trợ crop và resize lại kích cỡ của ảnh. Hơn nữa, trong trường hợp bạn upload file bị lỗi, thì `Carrierwave` cũng đã hỗ trợ việc `cache` file, có nghĩa là bạn không cần phải upload lại file đó. Một điều khá hay nữa của `Carrierwave` đó là nó sẽ lưu trữ tất cả data trong các class uploader, giúp cho code của bạn trông gọn gàng hơn rất nhiều. 

Một gem khác là [Minimagick](https://github.com/minimagick/minimagick) giúp xử lý ảnh dễ dàng hơn. Không chỉ vậy, nó còn giúp tiết kiệm RAM một cách hiệu quả và thực hiện các task chỉnh sửa ảnh phức tạp như resize (thay đổi kích cỡ), flip (lật), rotate (xoay), blur (làm mờ) cũng như chuyển đổi định dạng ảnh. 

Cuối cùng, nếu như bạn muốn upload ảnh và lưu trữ trên các server ngoài như `S3` của Amazon hay `Cloud Storage` của Google, hãy tìm đến [Fog](https://github.com/fog/fog). Nó hoạt động với nhiều `cloud service` khác nhau như `AWS`, `Rackspace Server` hay `Brightbox`
# Kết luận
Còn rất rất nhiều gem bổ ích khác mà mình chưa thể liệt kê trong bài viết này như [Ransack](https://github.com/activerecord-hackery/ransack), [Active Admin](https://github.com/activeadmin/activeadmin) hay [Draper](https://github.com/drapergem/draper) ..v..v.. Các gem đó giúp giả quyết các vấn đề thường gặp trong Rails application một cách dễ dàng. Nó cũng giải quyết việc lặp code và giúp xây dựng các `solutions` của riêng bạn cho từng app riêng biệt. Tuy nhiên, gem không phải là vạn năng. Nó không thể hoàn toàn giải quyết 100% các vấn đề mà bạn gặp phải. Bởi vậy, sử dụng thường xuyên, nhưng hãy nhớ sử dụng đúng cách.

Bài viết của mình đến đây là hết, cảm ơn các bạn đã theo dõi

Nguồn: https://rubygarage.org/blog/best-ruby-gems-we-use