![image.png](https://images.viblo.asia/22e73bfd-1c40-428d-968e-ec5700279a77.png)
Anh là ai? Tôi là tôi. Tôi giống anh, tôi làm những thứ gần giống anh làm nhưng tôi không phải là anh.
# Tôi là tôi mà không phải là tôi
Khi mộng du trong đa vũ trụ, đi từ vụ trũ này sang vũ trụ khác, người du hành sẽ gặp được bản thể của chính mình tại vũ trụ đó. Nhưng hơi khác lạ, có thể phiên bản này đẹp trai hơn, giàu hơn, mạnh hơn hoặc yếu hơn, cơ mà cuối cùng cũng giống nhau là không có được tình yêu cả đời mình như ai đó. Như vậy, những người này tuy khác vũ trụ, nhưng lại giống nhau nhưng lại khác một tẹo về cuộc đời, vậy họ có giống nhau không? Về bản chất là có và về thực tế là không. 
# Khác vũ trụ, cùng tên gọi
Ở earth 73 nào đó, kênh [Thích Học](https://www.youtube.com/channel/UCu3Dx6gL3mJ8hf5NTPOXTpw) rất là thành công, mọi người đều biết đến Thích Học. Nhờ có Thích Học mà mọi người cảm thấy thích học hơn, học hỏi được nhiều hơn, biết nhiều hơn, cuộc sống tốt hơn, vui vẻ hơn. Ở Earth 74 nào đó, Thích Học không thành công như vậy, nhờ Thích Học mà mọi người không thích học. Ai cũng chán ghét kênh này, họ đã từng tìm cách để tiêu diệt kênh này nhưng không thành công. Người du hành vũ trụ từ earth 73 sang earth 74, họ nói về kênh Thích Học rất thành công thì người ở Earth 74 kiểu nói gì vậy, ở đây ai cũng ghét nó. Và ngược lại, khi người earth 74 qua bên earth 73 và nói rằng Thích Học rất fail thì người ở đây kiểu thôi nào, đừng GATO như vậy, họ rất thành công mà. Do đó, khi nói Thích Học, để câu nói đúng thì phải kèm theo, Thích Học earth 73, Thích Học earth 74. Như vụ đèn đỏ chẳng hạn, ở earth 1 thì dừng, còn ở earth 2 thì đi :D. Vậy đèn đỏ nên đi hay nên dừng? Đèn đỏ earth 1 thì nên dừng và đèn đỏ earth 2 thì nên đi còn đèn đỏ nên đi hay nên dừng thì no idea. 
# Khái niệm overloading
Trong lập trình, chúng ta có những khái niệm tương tự. Trong một class, chúng ta có thể có nhiều Constructor, về bản chất, chúng đều là constructor, nhưng constructor này không phải là constructor kia và constructor kia không giống với constructor nọ. Nó giống nhau nhưng lại khác nhau. Về bản chất thì giống nhau về thực tế thì khác nhau. 
```
public ThichHoc() {}

public ThichHoc(int n) {}

public ThichHoc(float n) {}

public ThichHoc(string n) {}
```
Để sử dụng, chúng ta phải gọi tên kèm với vũ trụ đó bằng cách truyền tham trị. 
```
new ThichHoc() // earth 1

new ThichHoc(2) // earth 2

new ThichHoc(3.234) // earth 3

new ThichHoc("Thich Hoc") // earth 4
```
Tương tự cho hàm, tên gọi y chang, nhưng tham số sẽ khác nhau về kiểu chẳng hạn. Khi gọi tên hàm, giả sử hàm calculate, chúng ta không thể đơn giản gọi là hàm calculate, mà phải chỉ rõ ra calculate earth 1 hay earth 2 bằng cách thêm tham số vào:
```
public int calculate(int n) {}

public int calculate(float n) {}

public int calculate(string n) {}
```
Vậy calculate nên nhận giá trị là int, float hay string. Calculate ở earth 1 nhận giá trị là int, calculate ở earth 2 nhận giá trị là float và calculate ở earth 3 nhận giá trị là string. Giống nhau nhưng lại khác nhau nên khi dùng phải chỉ rõ ra là dùng calculate của earth nào bằng cách truyền tham trị vào hợp với tham số.
```
calculate(2) // calculate earth 1

calculate(2.3) // calculate earth 2

calculate('Hello World') // calculate earth 3
```
Vậy thì trong đa vũ trụ, tôi là tôi mà không phải là tôi. Muốn biết chính xác tôi là ai thì phải chỉ rõ ra là ở vũ trụ nào. Như constructor ThichHoc hay hàm calculate, chỉ rõ ra ở vũ trụ nào thì mới có thể dùng chính xác được.