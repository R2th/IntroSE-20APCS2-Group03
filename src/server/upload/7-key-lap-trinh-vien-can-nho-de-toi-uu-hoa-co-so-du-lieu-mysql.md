![](https://images.viblo.asia/6f2d5823-5d73-4cb4-8af8-15e6ae9cf2e2.png)

Một ngày đẹp trời app hay phần mềm của bạn phổ biến với công chúng. Hàng triệu record xuất hiện trong DB, máy chủ thì luôn chạy 100% cpu, khách hàng la ó vì sao ngày càng chậm vậy. Làm sao cho nó nhanh hơn khi phải lưu lượng data khổng lồ. Về cơ bản dev nào cũng sẽ nghĩ đến đến mấy thứ như sql server, oracle, mongodb, vv.. nhưng về bản chất chúng cũng ko làm cho phần mềm của bạn nhanh hơn. Những thứ như mysql, sql server, db2 đều được xây dựng từ 1 core huyền thoại. Một thời gian dài ngâm cứu thì mình thấy tốt nhất là học cách tối ưu cái hiện có, thay đổi chứ ko phải là đập đi xây lại để chỉ làm ra 1 phần mềm ngang phần mềm cũ. Có vài cái key kiến thức sau có thể giúp lập trình viên pro hơn khi xài các loại sql:
1. **bool và enum** luôn là lựa chọn tồi vì không thể index, nguyên nhân bởi cách nó lưu data. Xài tinyint là chân lý.
2.  **Nullable** ko bao giờ tốt cho tìm kiếm, cho column giá trị default nhé. Cái  nullable thì mình cũng hay xài nhiều vì nhanh và lười migrate data 😊
3.  **Single index và composite index** tức là đánh index riêng từng cột một và index theo 1 nhóm cột thì các bạn nên xài single, đơn giản khi thay đổi code hơn. Composite chỉ phù hợp với nhóm cột chứa những dữ liệu mà chỉ có vài giá trị.
4.  **Index thế nào gọi là hiệu quả**, có 1 công thức thế này:số bản ghi ảnh hưởng select distinct với điều kiện tìm kiếm của bạn/số bản ghi ảnh hưởng select của bạn > 17 % thì index được coi là hiệu quả. Tại sao thì mấy bồ hỏi tác giả của mysql nha 😭
5.  **Index chỉ thực sự mạnh mẽ với khoảng 35 ký tự,** nếu có 1 cái tên dài 200 ký tự thì các bạn nên đánh index 35 ký tự đầu tiên thôi nhé. Tại sao hỏi thằng tạo ra SQL
6.  **Inverted Index**: Khi cần lưu 1 lượng bài viết lớn khoảng vài trăm triệu chẳng hạn. Muốn tìm kiếm nhanh thì hãy xài kỹ thuật Inverted Index:Parse từng dòng của bài viết hoặc những chuỗi có độ dài khoảng 35 ký tự, lưu vào 1 bảng, có thể lưu index đc, gắn post_id chuỗi đó  link đến bài viết nhé. Search bình thường trên bảng mới, dựa vào vị trí của chuỗi đã parse ra có thể bôi vàng đc kết quả tìm kiếm.
7.  **Xài RDS** đã được tối ưu của AWS, GPC vv..

**Tham khảo**: High Performance MySQL: Optimization, Backups, and Replication Third Edition